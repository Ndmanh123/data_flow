{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport { CellView } from './CellView.mjs';\nimport { Link } from './Link.mjs';\nimport V from '../V/index.mjs';\nimport { addClassNamePrefix, removeClassNamePrefix, merge, template, assign, toArray, isObject, isFunction, clone, isPercentage, result, isEqual } from '../util/index.mjs';\nimport { Point, Line, Path, normalizeAngle, Rect, Polyline } from '../g/index.mjs';\nimport * as routers from '../routers/index.mjs';\nimport * as connectors from '../connectors/index.mjs';\nimport $ from 'jquery';\nconst Flags = {\n  RENDER: 'RENDER',\n  UPDATE: 'UPDATE',\n  TOOLS: 'TOOLS',\n  LEGACY_TOOLS: 'LEGACY_TOOLS',\n  LABELS: 'LABELS',\n  VERTICES: 'VERTICES',\n  SOURCE: 'SOURCE',\n  TARGET: 'TARGET',\n  CONNECTOR: 'CONNECTOR'\n}; // Link base view and controller.\n// ----------------------------------------\n\nexport const LinkView = CellView.extend({\n  className: function () {\n    var classNames = CellView.prototype.className.apply(this).split(' ');\n    classNames.push('link');\n    return classNames.join(' ');\n  },\n  options: {\n    shortLinkLength: 105,\n    doubleLinkTools: false,\n    longLinkLength: 155,\n    linkToolsOffset: 40,\n    doubleLinkToolsOffset: 65,\n    sampleInterval: 50\n  },\n  _labelCache: null,\n  _labelSelectors: null,\n  _markerCache: null,\n  _V: null,\n  _dragData: null,\n  // deprecated\n  metrics: null,\n  decimalsRounding: 2,\n  initialize: function () {\n    CellView.prototype.initialize.apply(this, arguments); // `_.labelCache` is a mapping of indexes of labels in the `this.get('labels')` array to\n    // `<g class=\"label\">` nodes wrapped by Vectorizer. This allows for quick access to the\n    // nodes in `updateLabelPosition()` in order to update the label positions.\n\n    this._labelCache = {}; // a cache of label selectors\n\n    this._labelSelectors = {}; // keeps markers bboxes and positions again for quicker access\n\n    this._markerCache = {}; // cache of default markup nodes\n\n    this._V = {}; // connection path metrics\n\n    this.cleanNodesCache();\n  },\n  presentationAttributes: {\n    markup: [Flags.RENDER],\n    attrs: [Flags.UPDATE],\n    router: [Flags.UPDATE],\n    connector: [Flags.CONNECTOR],\n    smooth: [Flags.UPDATE],\n    manhattan: [Flags.UPDATE],\n    toolMarkup: [Flags.LEGACY_TOOLS],\n    labels: [Flags.LABELS],\n    labelMarkup: [Flags.LABELS],\n    vertices: [Flags.VERTICES, Flags.UPDATE],\n    vertexMarkup: [Flags.VERTICES],\n    source: [Flags.SOURCE, Flags.UPDATE],\n    target: [Flags.TARGET, Flags.UPDATE]\n  },\n  initFlag: [Flags.RENDER, Flags.SOURCE, Flags.TARGET, Flags.TOOLS],\n  UPDATE_PRIORITY: 1,\n  confirmUpdate: function (flags, opt) {\n    opt || (opt = {});\n\n    if (this.hasFlag(flags, Flags.SOURCE)) {\n      if (!this.updateEndProperties('source')) return flags;\n      flags = this.removeFlag(flags, Flags.SOURCE);\n    }\n\n    if (this.hasFlag(flags, Flags.TARGET)) {\n      if (!this.updateEndProperties('target')) return flags;\n      flags = this.removeFlag(flags, Flags.TARGET);\n    }\n\n    const {\n      paper,\n      sourceView,\n      targetView\n    } = this;\n\n    if (paper && (sourceView && !paper.isViewMounted(sourceView) || targetView && !paper.isViewMounted(targetView))) {\n      // Wait for the sourceView and targetView to be rendered\n      return flags;\n    }\n\n    if (this.hasFlag(flags, Flags.RENDER)) {\n      this.render();\n      this.updateHighlighters(true);\n      this.updateTools(opt);\n      flags = this.removeFlag(flags, [Flags.RENDER, Flags.UPDATE, Flags.VERTICES, Flags.LABELS, Flags.TOOLS, Flags.LEGACY_TOOLS, Flags.CONNECTOR]);\n      return flags;\n    }\n\n    let updateHighlighters = false;\n\n    if (this.hasFlag(flags, Flags.VERTICES)) {\n      this.renderVertexMarkers();\n      flags = this.removeFlag(flags, Flags.VERTICES);\n    }\n\n    const {\n      model\n    } = this;\n    const {\n      attributes\n    } = model;\n    let updateLabels = this.hasFlag(flags, Flags.LABELS);\n    let updateLegacyTools = this.hasFlag(flags, Flags.LEGACY_TOOLS);\n\n    if (updateLabels) {\n      this.onLabelsChange(model, attributes.labels, opt);\n      flags = this.removeFlag(flags, Flags.LABELS);\n      updateHighlighters = true;\n    }\n\n    if (updateLegacyTools) {\n      this.renderTools();\n      flags = this.removeFlag(flags, Flags.LEGACY_TOOLS);\n    }\n\n    const updateAll = this.hasFlag(flags, Flags.UPDATE);\n    const updateConnector = this.hasFlag(flags, Flags.CONNECTOR);\n\n    if (updateAll || updateConnector) {\n      if (!updateAll) {\n        // Keep the current route and update the geometry\n        this.updatePath();\n        this.updateDOM();\n      } else if (opt.translateBy && model.isRelationshipEmbeddedIn(opt.translateBy)) {\n        // The link is being translated by an ancestor that will\n        // shift source point, target point and all vertices\n        // by an equal distance.\n        this.translate(opt.tx, opt.ty);\n      } else {\n        this.update();\n      }\n\n      this.updateTools(opt);\n      flags = this.removeFlag(flags, [Flags.UPDATE, Flags.TOOLS, Flags.CONNECTOR]);\n      updateLabels = false;\n      updateLegacyTools = false;\n      updateHighlighters = true;\n    }\n\n    if (updateLabels) {\n      this.updateLabelPositions();\n    }\n\n    if (updateLegacyTools) {\n      this.updateToolsPosition();\n    }\n\n    if (updateHighlighters) {\n      this.updateHighlighters();\n    }\n\n    if (this.hasFlag(flags, Flags.TOOLS)) {\n      this.updateTools(opt);\n      flags = this.removeFlag(flags, Flags.TOOLS);\n    }\n\n    return flags;\n  },\n  requestConnectionUpdate: function (opt) {\n    this.requestUpdate(this.getFlag(Flags.UPDATE), opt);\n  },\n  isLabelsRenderRequired: function (opt = {}) {\n    const previousLabels = this.model.previous('labels');\n    if (!previousLabels) return true; // Here is an optimization for cases when we know, that change does\n    // not require re-rendering of all labels.\n\n    if ('propertyPathArray' in opt && 'propertyValue' in opt) {\n      // The label is setting by `prop()` method\n      var pathArray = opt.propertyPathArray || [];\n      var pathLength = pathArray.length;\n\n      if (pathLength > 1) {\n        // We are changing a single label here e.g. 'labels/0/position'\n        var labelExists = !!previousLabels[pathArray[1]];\n\n        if (labelExists) {\n          if (pathLength === 2) {\n            // We are changing the entire label. Need to check if the\n            // markup is also being changed.\n            return 'markup' in Object(opt.propertyValue);\n          } else if (pathArray[2] !== 'markup') {\n            // We are changing a label property but not the markup\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  },\n  onLabelsChange: function (_link, _labels, opt) {\n    // Note: this optimization works in async=false mode only\n    if (this.isLabelsRenderRequired(opt)) {\n      this.renderLabels();\n    } else {\n      this.updateLabels();\n    }\n  },\n  // Rendering.\n  // ----------\n  render: function () {\n    this.vel.empty();\n    this.unmountLabels();\n    this._V = {};\n    this.renderMarkup(); // rendering labels has to be run after the link is appended to DOM tree. (otherwise <Text> bbox\n    // returns zero values)\n\n    this.renderLabels();\n    this.update();\n    return this;\n  },\n  renderMarkup: function () {\n    var link = this.model;\n    var markup = link.get('markup') || link.markup;\n    if (!markup) throw new Error('dia.LinkView: markup required');\n    if (Array.isArray(markup)) return this.renderJSONMarkup(markup);\n    if (typeof markup === 'string') return this.renderStringMarkup(markup);\n    throw new Error('dia.LinkView: invalid markup');\n  },\n  renderJSONMarkup: function (markup) {\n    var doc = this.parseDOMJSON(markup, this.el); // Selectors\n\n    this.selectors = doc.selectors; // Fragment\n\n    this.vel.append(doc.fragment);\n  },\n  renderStringMarkup: function (markup) {\n    // A special markup can be given in the `properties.markup` property. This might be handy\n    // if e.g. arrowhead markers should be `<image>` elements or any other element than `<path>`s.\n    // `.connection`, `.connection-wrap`, `.marker-source` and `.marker-target` selectors\n    // of elements with special meaning though. Therefore, those classes should be preserved in any\n    // special markup passed in `properties.markup`.\n    var children = V(markup); // custom markup may contain only one children\n\n    if (!Array.isArray(children)) children = [children]; // Cache all children elements for quicker access.\n\n    var cache = this._V; // vectorized markup;\n\n    for (var i = 0, n = children.length; i < n; i++) {\n      var child = children[i];\n      var className = child.attr('class');\n\n      if (className) {\n        // Strip the joint class name prefix, if there is one.\n        className = removeClassNamePrefix(className);\n        cache[$.camelCase(className)] = child;\n      }\n    } // partial rendering\n\n\n    this.renderTools();\n    this.renderVertexMarkers();\n    this.renderArrowheadMarkers();\n    this.vel.append(children);\n  },\n  _getLabelMarkup: function (labelMarkup) {\n    if (!labelMarkup) return undefined;\n    if (Array.isArray(labelMarkup)) return this.parseDOMJSON(labelMarkup, null);\n    if (typeof labelMarkup === 'string') return this._getLabelStringMarkup(labelMarkup);\n    throw new Error('dia.linkView: invalid label markup');\n  },\n  _getLabelStringMarkup: function (labelMarkup) {\n    var children = V(labelMarkup);\n    var fragment = document.createDocumentFragment();\n\n    if (!Array.isArray(children)) {\n      fragment.appendChild(children.node);\n    } else {\n      for (var i = 0, n = children.length; i < n; i++) {\n        var currentChild = children[i].node;\n        fragment.appendChild(currentChild);\n      }\n    }\n\n    return {\n      fragment: fragment,\n      selectors: {}\n    }; // no selectors\n  },\n  // Label markup fragment may come wrapped in <g class=\"label\" />, or not.\n  // If it doesn't, add the <g /> container here.\n  _normalizeLabelMarkup: function (markup) {\n    if (!markup) return undefined;\n    var fragment = markup.fragment;\n    if (!(markup.fragment instanceof DocumentFragment) || !markup.fragment.hasChildNodes()) throw new Error('dia.LinkView: invalid label markup.');\n    var vNode;\n    var childNodes = fragment.childNodes;\n\n    if (childNodes.length > 1 || childNodes[0].nodeName.toUpperCase() !== 'G') {\n      // default markup fragment is not wrapped in <g />\n      // add a <g /> container\n      vNode = V('g').append(fragment);\n    } else {\n      vNode = V(childNodes[0]);\n    }\n\n    vNode.addClass('label');\n    return {\n      node: vNode.node,\n      selectors: markup.selectors\n    };\n  },\n  renderLabels: function () {\n    var cache = this._V;\n    var vLabels = cache.labels;\n    var labelCache = this._labelCache = {};\n    var labelSelectors = this._labelSelectors = {};\n    var model = this.model;\n    var labels = model.attributes.labels || [];\n    var labelsCount = labels.length;\n\n    if (labelsCount === 0) {\n      if (vLabels) vLabels.remove();\n      return this;\n    }\n\n    if (vLabels) {\n      vLabels.empty();\n    } else {\n      // there is no label container in the markup but some labels are defined\n      // add a <g class=\"labels\" /> container\n      vLabels = cache.labels = V('g').addClass('labels');\n\n      if (this.options.labelsLayer) {\n        vLabels.addClass(addClassNamePrefix(result(this, 'className')));\n        vLabels.attr('model-id', model.id);\n      }\n    }\n\n    for (var i = 0; i < labelsCount; i++) {\n      var label = labels[i];\n\n      var labelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(label.markup));\n\n      var labelNode;\n      var selectors;\n\n      if (labelMarkup) {\n        labelNode = labelMarkup.node;\n        selectors = labelMarkup.selectors;\n      } else {\n        var builtinDefaultLabel = model._builtins.defaultLabel;\n\n        var builtinDefaultLabelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(builtinDefaultLabel.markup));\n\n        var defaultLabel = model._getDefaultLabel();\n\n        var defaultLabelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(defaultLabel.markup));\n\n        var defaultMarkup = defaultLabelMarkup || builtinDefaultLabelMarkup;\n        labelNode = defaultMarkup.node;\n        selectors = defaultMarkup.selectors;\n      }\n\n      labelNode.setAttribute('label-idx', i); // assign label-idx\n\n      vLabels.append(labelNode);\n      labelCache[i] = labelNode; // cache node for `updateLabels()` so it can just update label node positions\n\n      var rootSelector = this.selector;\n      if (selectors[rootSelector]) throw new Error('dia.LinkView: ambiguous label root selector.');\n      selectors[rootSelector] = labelNode;\n      labelSelectors[i] = selectors; // cache label selectors for `updateLabels()`\n    }\n\n    if (!vLabels.parent()) {\n      this.mountLabels();\n    }\n\n    this.updateLabels();\n    return this;\n  },\n  mountLabels: function () {\n    const {\n      el,\n      paper,\n      model,\n      _V,\n      options\n    } = this;\n    const {\n      labels: vLabels\n    } = _V;\n    if (!vLabels || !model.hasLabels()) return;\n    const {\n      node\n    } = vLabels;\n\n    if (options.labelsLayer) {\n      paper.getLayerView(options.labelsLayer).insertSortedNode(node, model.get('z'));\n    } else {\n      if (node.parentNode !== el) {\n        el.appendChild(node);\n      }\n    }\n  },\n  unmountLabels: function () {\n    const {\n      options,\n      _V\n    } = this;\n    if (!_V) return;\n    const {\n      labels: vLabels\n    } = _V;\n\n    if (vLabels && options.labelsLayer) {\n      vLabels.remove();\n    }\n  },\n  onMount: function () {\n    this.mountLabels();\n  },\n  unmount: function () {\n    CellView.prototype.unmount.apply(this, arguments);\n    this.unmountLabels();\n  },\n  findLabelNode: function (labelIndex, selector) {\n    const labelRoot = this._labelCache[labelIndex];\n    if (!labelRoot) return null;\n    const labelSelectors = this._labelSelectors[labelIndex];\n    const [node = null] = this.findBySelector(selector, labelRoot, labelSelectors);\n    return node;\n  },\n  // merge default label attrs into label attrs\n  // keep `undefined` or `null` because `{}` means something else\n  _mergeLabelAttrs: function (hasCustomMarkup, labelAttrs, defaultLabelAttrs, builtinDefaultLabelAttrs) {\n    if (labelAttrs === null) return null;\n\n    if (labelAttrs === undefined) {\n      if (defaultLabelAttrs === null) return null;\n\n      if (defaultLabelAttrs === undefined) {\n        if (hasCustomMarkup) return undefined;\n        return builtinDefaultLabelAttrs;\n      }\n\n      if (hasCustomMarkup) return defaultLabelAttrs;\n      return merge({}, builtinDefaultLabelAttrs, defaultLabelAttrs);\n    }\n\n    if (hasCustomMarkup) return merge({}, defaultLabelAttrs, labelAttrs);\n    return merge({}, builtinDefaultLabelAttrs, defaultLabelAttrs, labelAttrs);\n  },\n  updateLabels: function () {\n    if (!this._V.labels) return this;\n    var model = this.model;\n    var labels = model.get('labels') || [];\n    var canLabelMove = this.can('labelMove');\n    var builtinDefaultLabel = model._builtins.defaultLabel;\n    var builtinDefaultLabelAttrs = builtinDefaultLabel.attrs;\n\n    var defaultLabel = model._getDefaultLabel();\n\n    var defaultLabelMarkup = defaultLabel.markup;\n    var defaultLabelAttrs = defaultLabel.attrs;\n\n    for (var i = 0, n = labels.length; i < n; i++) {\n      var labelNode = this._labelCache[i];\n      labelNode.setAttribute('cursor', canLabelMove ? 'move' : 'default');\n      var selectors = this._labelSelectors[i];\n      var label = labels[i];\n      var labelMarkup = label.markup;\n      var labelAttrs = label.attrs;\n\n      var attrs = this._mergeLabelAttrs(labelMarkup || defaultLabelMarkup, labelAttrs, defaultLabelAttrs, builtinDefaultLabelAttrs);\n\n      this.updateDOMSubtreeAttributes(labelNode, attrs, {\n        rootBBox: new Rect(label.size),\n        selectors: selectors\n      });\n    }\n\n    return this;\n  },\n  renderTools: function () {\n    if (!this._V.linkTools) return this; // Tools are a group of clickable elements that manipulate the whole link.\n    // A good example of this is the remove tool that removes the whole link.\n    // Tools appear after hovering the link close to the `source` element/point of the link\n    // but are offset a bit so that they don't cover the `marker-arrowhead`.\n\n    var $tools = $(this._V.linkTools.node).empty();\n    var toolTemplate = template(this.model.get('toolMarkup') || this.model.toolMarkup);\n    var tool = V(toolTemplate());\n    $tools.append(tool.node); // Cache the tool node so that the `updateToolsPosition()` can update the tool position quickly.\n\n    this._toolCache = tool; // If `doubleLinkTools` is enabled, we render copy of the tools on the other side of the\n    // link as well but only if the link is longer than `longLinkLength`.\n\n    if (this.options.doubleLinkTools) {\n      var tool2;\n\n      if (this.model.get('doubleToolMarkup') || this.model.doubleToolMarkup) {\n        toolTemplate = template(this.model.get('doubleToolMarkup') || this.model.doubleToolMarkup);\n        tool2 = V(toolTemplate());\n      } else {\n        tool2 = tool.clone();\n      }\n\n      $tools.append(tool2.node);\n      this._tool2Cache = tool2;\n    }\n\n    return this;\n  },\n  renderVertexMarkers: function () {\n    if (!this._V.markerVertices) return this;\n    var $markerVertices = $(this._V.markerVertices.node).empty(); // A special markup can be given in the `properties.vertexMarkup` property. This might be handy\n    // if default styling (elements) are not desired. This makes it possible to use any\n    // SVG elements for .marker-vertex and .marker-vertex-remove tools.\n\n    var markupTemplate = template(this.model.get('vertexMarkup') || this.model.vertexMarkup);\n    this.model.vertices().forEach(function (vertex, idx) {\n      $markerVertices.append(V(markupTemplate(assign({\n        idx: idx\n      }, vertex))).node);\n    });\n    return this;\n  },\n  renderArrowheadMarkers: function () {\n    // Custom markups might not have arrowhead markers. Therefore, jump of this function immediately if that's the case.\n    if (!this._V.markerArrowheads) return this;\n    var $markerArrowheads = $(this._V.markerArrowheads.node);\n    $markerArrowheads.empty(); // A special markup can be given in the `properties.vertexMarkup` property. This might be handy\n    // if default styling (elements) are not desired. This makes it possible to use any\n    // SVG elements for .marker-vertex and .marker-vertex-remove tools.\n\n    var markupTemplate = template(this.model.get('arrowheadMarkup') || this.model.arrowheadMarkup);\n    this._V.sourceArrowhead = V(markupTemplate({\n      end: 'source'\n    }));\n    this._V.targetArrowhead = V(markupTemplate({\n      end: 'target'\n    }));\n    $markerArrowheads.append(this._V.sourceArrowhead.node, this._V.targetArrowhead.node);\n    return this;\n  },\n  // remove vertices that lie on (or nearly on) straight lines within the link\n  // return the number of removed points\n  removeRedundantLinearVertices: function (opt) {\n    const SIMPLIFY_THRESHOLD = 0.001;\n    const link = this.model;\n    const vertices = link.vertices();\n    const routePoints = [this.sourceAnchor, ...vertices, this.targetAnchor];\n    const numRoutePoints = routePoints.length; // put routePoints into a polyline and try to simplify\n\n    const polyline = new Polyline(routePoints);\n    polyline.simplify({\n      threshold: SIMPLIFY_THRESHOLD\n    });\n    const polylinePoints = polyline.points.map(point => point.toJSON()); // JSON of points after simplification\n\n    const numPolylinePoints = polylinePoints.length; // number of points after simplification\n    // shortcut if simplification did not remove any redundant vertices:\n\n    if (numRoutePoints === numPolylinePoints) return 0; // else: set simplified polyline points as link vertices\n    // remove first and last polyline points again (= source/target anchors)\n\n    link.vertices(polylinePoints.slice(1, numPolylinePoints - 1), opt);\n    return numRoutePoints - numPolylinePoints;\n  },\n  updateDefaultConnectionPath: function () {\n    var cache = this._V;\n\n    if (cache.connection) {\n      cache.connection.attr('d', this.getSerializedConnection());\n    }\n\n    if (cache.connectionWrap) {\n      cache.connectionWrap.attr('d', this.getSerializedConnection());\n    }\n\n    if (cache.markerSource && cache.markerTarget) {\n      this._translateAndAutoOrientArrows(cache.markerSource, cache.markerTarget);\n    }\n  },\n  getEndView: function (type) {\n    switch (type) {\n      case 'source':\n        return this.sourceView || null;\n\n      case 'target':\n        return this.targetView || null;\n\n      default:\n        throw new Error('dia.LinkView: type parameter required.');\n    }\n  },\n  getEndAnchor: function (type) {\n    switch (type) {\n      case 'source':\n        return new Point(this.sourceAnchor);\n\n      case 'target':\n        return new Point(this.targetAnchor);\n\n      default:\n        throw new Error('dia.LinkView: type parameter required.');\n    }\n  },\n  getEndConnectionPoint: function (type) {\n    switch (type) {\n      case 'source':\n        return new Point(this.sourcePoint);\n\n      case 'target':\n        return new Point(this.targetPoint);\n\n      default:\n        throw new Error('dia.LinkView: type parameter required.');\n    }\n  },\n  getEndMagnet: function (type) {\n    switch (type) {\n      case 'source':\n        var sourceView = this.sourceView;\n        if (!sourceView) break;\n        return this.sourceMagnet || sourceView.el;\n\n      case 'target':\n        var targetView = this.targetView;\n        if (!targetView) break;\n        return this.targetMagnet || targetView.el;\n\n      default:\n        throw new Error('dia.LinkView: type parameter required.');\n    }\n\n    return null;\n  },\n  // Updating.\n  // ---------\n  update: function () {\n    this.updateRoute();\n    this.updatePath();\n    this.updateDOM();\n    return this;\n  },\n  translate: function (tx = 0, ty = 0) {\n    const {\n      route,\n      path\n    } = this;\n    if (!route || !path) return; // translate the route\n\n    const polyline = new Polyline(route);\n    polyline.translate(tx, ty);\n    this.route = polyline.points; // translate source and target connection and marker points.\n\n    this._translateConnectionPoints(tx, ty); // translate the geometry path\n\n\n    path.translate(tx, ty);\n    this.updateDOM();\n  },\n\n  updateDOM() {\n    const {\n      el,\n      model,\n      selectors\n    } = this;\n    this.cleanNodesCache(); // update SVG attributes defined by 'attrs/'.\n\n    this.updateDOMSubtreeAttributes(el, model.attr(), {\n      selectors\n    }); // legacy link path update\n\n    this.updateDefaultConnectionPath(); // update the label position etc.\n\n    this.updateLabelPositions();\n    this.updateToolsPosition();\n    this.updateArrowheadMarkers(); // *Deprecated*\n    // Local perpendicular flag (as opposed to one defined on paper).\n    // Could be enabled inside a connector/router. It's valid only\n    // during the update execution.\n\n    this.options.perpendicular = null;\n  },\n\n  updateRoute: function () {\n    const {\n      model\n    } = this;\n    const vertices = model.vertices(); // 1. Find Anchors\n\n    const anchors = this.findAnchors(vertices);\n    const sourceAnchor = this.sourceAnchor = anchors.source;\n    const targetAnchor = this.targetAnchor = anchors.target; // 2. Find Route\n\n    const route = this.findRoute(vertices);\n    this.route = route; // 3. Find Connection Points\n\n    var connectionPoints = this.findConnectionPoints(route, sourceAnchor, targetAnchor);\n    this.sourcePoint = connectionPoints.source;\n    this.targetPoint = connectionPoints.target;\n  },\n  updatePath: function () {\n    const {\n      route,\n      sourcePoint,\n      targetPoint\n    } = this; // 3b. Find Marker Connection Point - Backwards Compatibility\n\n    const markerPoints = this.findMarkerPoints(route, sourcePoint, targetPoint); // 4. Find Connection\n\n    const path = this.findPath(route, markerPoints.source || sourcePoint, markerPoints.target || targetPoint);\n    this.path = path;\n  },\n  findMarkerPoints: function (route, sourcePoint, targetPoint) {\n    var firstWaypoint = route[0];\n    var lastWaypoint = route[route.length - 1]; // Move the source point by the width of the marker taking into account\n    // its scale around x-axis. Note that scale is the only transform that\n    // makes sense to be set in `.marker-source` attributes object\n    // as all other transforms (translate/rotate) will be replaced\n    // by the `translateAndAutoOrient()` function.\n\n    var cache = this._markerCache; // cache source and target points\n\n    var sourceMarkerPoint, targetMarkerPoint;\n\n    if (this._V.markerSource) {\n      cache.sourceBBox = cache.sourceBBox || this._V.markerSource.getBBox();\n      sourceMarkerPoint = Point(sourcePoint).move(firstWaypoint || targetPoint, cache.sourceBBox.width * this._V.markerSource.scale().sx * -1).round();\n    }\n\n    if (this._V.markerTarget) {\n      cache.targetBBox = cache.targetBBox || this._V.markerTarget.getBBox();\n      targetMarkerPoint = Point(targetPoint).move(lastWaypoint || sourcePoint, cache.targetBBox.width * this._V.markerTarget.scale().sx * -1).round();\n    } // if there was no markup for the marker, use the connection point.\n\n\n    cache.sourcePoint = sourceMarkerPoint || sourcePoint.clone();\n    cache.targetPoint = targetMarkerPoint || targetPoint.clone();\n    return {\n      source: sourceMarkerPoint,\n      target: targetMarkerPoint\n    };\n  },\n  findAnchorsOrdered: function (firstEndType, firstRef, secondEndType, secondRef) {\n    var firstAnchor, secondAnchor;\n    var firstAnchorRef, secondAnchorRef;\n    var model = this.model;\n    var firstDef = model.get(firstEndType);\n    var secondDef = model.get(secondEndType);\n    var firstView = this.getEndView(firstEndType);\n    var secondView = this.getEndView(secondEndType);\n    var firstMagnet = this.getEndMagnet(firstEndType);\n    var secondMagnet = this.getEndMagnet(secondEndType); // Anchor first\n\n    if (firstView) {\n      if (firstRef) {\n        firstAnchorRef = new Point(firstRef);\n      } else if (secondView) {\n        firstAnchorRef = secondMagnet;\n      } else {\n        firstAnchorRef = new Point(secondDef);\n      }\n\n      firstAnchor = this.getAnchor(firstDef.anchor, firstView, firstMagnet, firstAnchorRef, firstEndType);\n    } else {\n      firstAnchor = new Point(firstDef);\n    } // Anchor second\n\n\n    if (secondView) {\n      secondAnchorRef = new Point(secondRef || firstAnchor);\n      secondAnchor = this.getAnchor(secondDef.anchor, secondView, secondMagnet, secondAnchorRef, secondEndType);\n    } else {\n      secondAnchor = new Point(secondDef);\n    }\n\n    var res = {};\n    res[firstEndType] = firstAnchor;\n    res[secondEndType] = secondAnchor;\n    return res;\n  },\n  findAnchors: function (vertices) {\n    var model = this.model;\n    var firstVertex = vertices[0];\n    var lastVertex = vertices[vertices.length - 1];\n\n    if (model.target().priority && !model.source().priority) {\n      // Reversed order\n      return this.findAnchorsOrdered('target', lastVertex, 'source', firstVertex);\n    } // Usual order\n\n\n    return this.findAnchorsOrdered('source', firstVertex, 'target', lastVertex);\n  },\n  findConnectionPoints: function (route, sourceAnchor, targetAnchor) {\n    var firstWaypoint = route[0];\n    var lastWaypoint = route[route.length - 1];\n    var model = this.model;\n    var sourceDef = model.get('source');\n    var targetDef = model.get('target');\n    var sourceView = this.sourceView;\n    var targetView = this.targetView;\n    var paperOptions = this.paper.options;\n    var sourceMagnet, targetMagnet; // Connection Point Source\n\n    var sourcePoint;\n\n    if (sourceView && !sourceView.isNodeConnection(this.sourceMagnet)) {\n      sourceMagnet = this.sourceMagnet || sourceView.el;\n      var sourceConnectionPointDef = sourceDef.connectionPoint || paperOptions.defaultConnectionPoint;\n      var sourcePointRef = firstWaypoint || targetAnchor;\n      var sourceLine = new Line(sourcePointRef, sourceAnchor);\n      sourcePoint = this.getConnectionPoint(sourceConnectionPointDef, sourceView, sourceMagnet, sourceLine, 'source');\n    } else {\n      sourcePoint = sourceAnchor;\n    } // Connection Point Target\n\n\n    var targetPoint;\n\n    if (targetView && !targetView.isNodeConnection(this.targetMagnet)) {\n      targetMagnet = this.targetMagnet || targetView.el;\n      var targetConnectionPointDef = targetDef.connectionPoint || paperOptions.defaultConnectionPoint;\n      var targetPointRef = lastWaypoint || sourceAnchor;\n      var targetLine = new Line(targetPointRef, targetAnchor);\n      targetPoint = this.getConnectionPoint(targetConnectionPointDef, targetView, targetMagnet, targetLine, 'target');\n    } else {\n      targetPoint = targetAnchor;\n    }\n\n    return {\n      source: sourcePoint,\n      target: targetPoint\n    };\n  },\n  getAnchor: function (anchorDef, cellView, magnet, ref, endType) {\n    var isConnection = cellView.isNodeConnection(magnet);\n    var paperOptions = this.paper.options;\n\n    if (!anchorDef) {\n      if (isConnection) {\n        anchorDef = paperOptions.defaultLinkAnchor;\n      } else {\n        if (paperOptions.perpendicularLinks || this.options.perpendicular) {\n          // Backwards compatibility\n          // If `perpendicularLinks` flag is set on the paper and there are vertices\n          // on the link, then try to find a connection point that makes the link perpendicular\n          // even though the link won't point to the center of the targeted object.\n          anchorDef = {\n            name: 'perpendicular'\n          };\n        } else {\n          anchorDef = paperOptions.defaultAnchor;\n        }\n      }\n    }\n\n    if (!anchorDef) throw new Error('Anchor required.');\n    var anchorFn;\n\n    if (typeof anchorDef === 'function') {\n      anchorFn = anchorDef;\n    } else {\n      var anchorName = anchorDef.name;\n      var anchorNamespace = isConnection ? 'linkAnchorNamespace' : 'anchorNamespace';\n      anchorFn = paperOptions[anchorNamespace][anchorName];\n      if (typeof anchorFn !== 'function') throw new Error('Unknown anchor: ' + anchorName);\n    }\n\n    var anchor = anchorFn.call(this, cellView, magnet, ref, anchorDef.args || {}, endType, this);\n    if (!anchor) return new Point();\n    return anchor.round(this.decimalsRounding);\n  },\n  getConnectionPoint: function (connectionPointDef, view, magnet, line, endType) {\n    var connectionPoint;\n    var anchor = line.end;\n    var paperOptions = this.paper.options; // Backwards compatibility\n\n    if (typeof paperOptions.linkConnectionPoint === 'function') {\n      var linkConnectionMagnet = magnet === view.el ? undefined : magnet;\n      connectionPoint = paperOptions.linkConnectionPoint(this, view, linkConnectionMagnet, line.start, endType);\n      if (connectionPoint) return connectionPoint;\n    }\n\n    if (!connectionPointDef) return anchor;\n    var connectionPointFn;\n\n    if (typeof connectionPointDef === 'function') {\n      connectionPointFn = connectionPointDef;\n    } else {\n      var connectionPointName = connectionPointDef.name;\n      connectionPointFn = paperOptions.connectionPointNamespace[connectionPointName];\n      if (typeof connectionPointFn !== 'function') throw new Error('Unknown connection point: ' + connectionPointName);\n    }\n\n    connectionPoint = connectionPointFn.call(this, line, view, magnet, connectionPointDef.args || {}, endType, this);\n    if (!connectionPoint) return anchor;\n    return connectionPoint.round(this.decimalsRounding);\n  },\n  _translateConnectionPoints: function (tx, ty) {\n    var cache = this._markerCache;\n    cache.sourcePoint.offset(tx, ty);\n    cache.targetPoint.offset(tx, ty);\n    this.sourcePoint.offset(tx, ty);\n    this.targetPoint.offset(tx, ty);\n    this.sourceAnchor.offset(tx, ty);\n    this.targetAnchor.offset(tx, ty);\n  },\n  // if label position is a number, normalize it to a position object\n  // this makes sure that label positions can be merged properly\n  _normalizeLabelPosition: function (labelPosition) {\n    if (typeof labelPosition === 'number') return {\n      distance: labelPosition,\n      offset: null,\n      angle: 0,\n      args: null\n    };\n    return labelPosition;\n  },\n  updateLabelPositions: function () {\n    if (!this._V.labels) return this;\n    var path = this.path;\n    if (!path) return this; // This method assumes all the label nodes are stored in the `this._labelCache` hash table\n    // by their indices in the `this.get('labels')` array. This is done in the `renderLabels()` method.\n\n    var model = this.model;\n    var labels = model.get('labels') || [];\n    if (!labels.length) return this;\n    var builtinDefaultLabel = model._builtins.defaultLabel;\n    var builtinDefaultLabelPosition = builtinDefaultLabel.position;\n\n    var defaultLabel = model._getDefaultLabel();\n\n    var defaultLabelPosition = this._normalizeLabelPosition(defaultLabel.position);\n\n    var defaultPosition = merge({}, builtinDefaultLabelPosition, defaultLabelPosition);\n\n    for (var idx = 0, n = labels.length; idx < n; idx++) {\n      var labelNode = this._labelCache[idx];\n      if (!labelNode) continue;\n      var label = labels[idx];\n\n      var labelPosition = this._normalizeLabelPosition(label.position);\n\n      var position = merge({}, defaultPosition, labelPosition);\n\n      var transformationMatrix = this._getLabelTransformationMatrix(position);\n\n      labelNode.setAttribute('transform', V.matrixToTransformString(transformationMatrix));\n\n      this._cleanLabelMatrices(idx);\n    }\n\n    return this;\n  },\n  _cleanLabelMatrices: function (index) {\n    // Clean magnetMatrix for all nodes of the label.\n    // Cached BoundingRect does not need to updated when the position changes\n    // TODO: this doesn't work for labels with XML String markups.\n    const {\n      metrics,\n      _labelSelectors\n    } = this;\n    const selectors = _labelSelectors[index];\n    if (!selectors) return;\n\n    for (let selector in selectors) {\n      const {\n        id\n      } = selectors[selector];\n      if (id && id in metrics) delete metrics[id].magnetMatrix;\n    }\n  },\n  updateToolsPosition: function () {\n    if (!this._V.linkTools) return this; // Move the tools a bit to the target position but don't cover the `sourceArrowhead` marker.\n    // Note that the offset is hardcoded here. The offset should be always\n    // more than the `this.$('.marker-arrowhead[end=\"source\"]')[0].bbox().width` but looking\n    // this up all the time would be slow.\n\n    var scale = '';\n    var offset = this.options.linkToolsOffset;\n    var connectionLength = this.getConnectionLength(); // Firefox returns connectionLength=NaN in odd cases (for bezier curves).\n    // In that case we won't update tools position at all.\n\n    if (!Number.isNaN(connectionLength)) {\n      // If the link is too short, make the tools half the size and the offset twice as low.\n      if (connectionLength < this.options.shortLinkLength) {\n        scale = 'scale(.5)';\n        offset /= 2;\n      }\n\n      var toolPosition = this.getPointAtLength(offset);\n\n      this._toolCache.attr('transform', 'translate(' + toolPosition.x + ', ' + toolPosition.y + ') ' + scale);\n\n      if (this.options.doubleLinkTools && connectionLength >= this.options.longLinkLength) {\n        var doubleLinkToolsOffset = this.options.doubleLinkToolsOffset || offset;\n        toolPosition = this.getPointAtLength(connectionLength - doubleLinkToolsOffset);\n\n        this._tool2Cache.attr('transform', 'translate(' + toolPosition.x + ', ' + toolPosition.y + ') ' + scale);\n\n        this._tool2Cache.attr('visibility', 'visible');\n      } else if (this.options.doubleLinkTools) {\n        this._tool2Cache.attr('visibility', 'hidden');\n      }\n    }\n\n    return this;\n  },\n  updateArrowheadMarkers: function () {\n    if (!this._V.markerArrowheads) return this; // getting bbox of an element with `display=\"none\"` in IE9 ends up with access violation\n\n    if ($.css(this._V.markerArrowheads.node, 'display') === 'none') return this;\n    var sx = this.getConnectionLength() < this.options.shortLinkLength ? .5 : 1;\n\n    this._V.sourceArrowhead.scale(sx);\n\n    this._V.targetArrowhead.scale(sx);\n\n    this._translateAndAutoOrientArrows(this._V.sourceArrowhead, this._V.targetArrowhead);\n\n    return this;\n  },\n  updateEndProperties: function (endType) {\n    const {\n      model,\n      paper\n    } = this;\n    const endViewProperty = `${endType}View`;\n    const endDef = model.get(endType);\n    const endId = endDef && endDef.id;\n\n    if (!endId) {\n      // the link end is a point ~ rect 0x0\n      this[endViewProperty] = null;\n      this.updateEndMagnet(endType);\n      return true;\n    }\n\n    const endModel = paper.getModelById(endId);\n    if (!endModel) throw new Error('LinkView: invalid ' + endType + ' cell.');\n    const endView = endModel.findView(paper);\n\n    if (!endView) {\n      // A view for a model should always exist\n      return false;\n    }\n\n    this[endViewProperty] = endView;\n    this.updateEndMagnet(endType);\n    return true;\n  },\n  updateEndMagnet: function (endType) {\n    const endMagnetProperty = `${endType}Magnet`;\n    const endView = this.getEndView(endType);\n\n    if (endView) {\n      let connectedMagnet = endView.getMagnetFromLinkEnd(this.model.get(endType));\n      if (connectedMagnet === endView.el) connectedMagnet = null;\n      this[endMagnetProperty] = connectedMagnet;\n    } else {\n      this[endMagnetProperty] = null;\n    }\n  },\n  _translateAndAutoOrientArrows: function (sourceArrow, targetArrow) {\n    // Make the markers \"point\" to their sticky points being auto-oriented towards\n    // `targetPosition`/`sourcePosition`. And do so only if there is a markup for them.\n    var route = toArray(this.route);\n\n    if (sourceArrow) {\n      sourceArrow.translateAndAutoOrient(this.sourcePoint, route[0] || this.targetPoint, this.paper.cells);\n    }\n\n    if (targetArrow) {\n      targetArrow.translateAndAutoOrient(this.targetPoint, route[route.length - 1] || this.sourcePoint, this.paper.cells);\n    }\n  },\n  _getLabelPositionAngle: function (idx) {\n    var labelPosition = this.model.label(idx).position || {};\n    return labelPosition.angle || 0;\n  },\n  _getLabelPositionArgs: function (idx) {\n    var labelPosition = this.model.label(idx).position || {};\n    return labelPosition.args;\n  },\n  _getDefaultLabelPositionArgs: function () {\n    var defaultLabel = this.model._getDefaultLabel();\n\n    var defaultLabelPosition = defaultLabel.position || {};\n    return defaultLabelPosition.args;\n  },\n  // merge default label position args into label position args\n  // keep `undefined` or `null` because `{}` means something else\n  _mergeLabelPositionArgs: function (labelPositionArgs, defaultLabelPositionArgs) {\n    if (labelPositionArgs === null) return null;\n\n    if (labelPositionArgs === undefined) {\n      if (defaultLabelPositionArgs === null) return null;\n      return defaultLabelPositionArgs;\n    }\n\n    return merge({}, defaultLabelPositionArgs, labelPositionArgs);\n  },\n  // Add default label at given position at end of `labels` array.\n  // Four signatures:\n  // - obj, obj = point, opt\n  // - obj, num, obj = point, angle, opt\n  // - num, num, obj = x, y, opt\n  // - num, num, num, obj = x, y, angle, opt\n  // Assigns relative coordinates by default:\n  // `opt.absoluteDistance` forces absolute coordinates.\n  // `opt.reverseDistance` forces reverse absolute coordinates (if absoluteDistance = true).\n  // `opt.absoluteOffset` forces absolute coordinates for offset.\n  // Additional args:\n  // `opt.keepGradient` auto-adjusts the angle of the label to match path gradient at position.\n  // `opt.ensureLegibility` rotates labels so they are never upside-down.\n  addLabel: function (p1, p2, p3, p4) {\n    // normalize data from the four possible signatures\n    var localX;\n    var localY;\n    var localAngle = 0;\n    var localOpt;\n\n    if (typeof p1 !== 'number') {\n      // {x, y} object provided as first parameter\n      localX = p1.x;\n      localY = p1.y;\n\n      if (typeof p2 === 'number') {\n        // angle and opt provided as second and third parameters\n        localAngle = p2;\n        localOpt = p3;\n      } else {\n        // opt provided as second parameter\n        localOpt = p2;\n      }\n    } else {\n      // x and y provided as first and second parameters\n      localX = p1;\n      localY = p2;\n\n      if (typeof p3 === 'number') {\n        // angle and opt provided as third and fourth parameters\n        localAngle = p3;\n        localOpt = p4;\n      } else {\n        // opt provided as third parameter\n        localOpt = p3;\n      }\n    } // merge label position arguments\n\n\n    var defaultLabelPositionArgs = this._getDefaultLabelPositionArgs();\n\n    var labelPositionArgs = localOpt;\n\n    var positionArgs = this._mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs); // append label to labels array\n\n\n    var label = {\n      position: this.getLabelPosition(localX, localY, localAngle, positionArgs)\n    };\n    var idx = -1;\n    this.model.insertLabel(idx, label, localOpt);\n    return idx;\n  },\n  // Add a new vertex at calculated index to the `vertices` array.\n  addVertex: function (x, y, opt) {\n    // accept input in form `{ x, y }, opt` or `x, y, opt`\n    var isPointProvided = typeof x !== 'number';\n    var localX = isPointProvided ? x.x : x;\n    var localY = isPointProvided ? x.y : y;\n    var localOpt = isPointProvided ? y : opt;\n    var vertex = {\n      x: localX,\n      y: localY\n    };\n    var idx = this.getVertexIndex(localX, localY);\n    this.model.insertVertex(idx, vertex, localOpt);\n    return idx;\n  },\n  // Send a token (an SVG element, usually a circle) along the connection path.\n  // Example: `link.findView(paper).sendToken(V('circle', { r: 7, fill: 'green' }).node)`\n  // `opt.duration` is optional and is a time in milliseconds that the token travels from the source to the target of the link. Default is `1000`.\n  // `opt.directon` is optional and it determines whether the token goes from source to target or other way round (`reverse`)\n  // `opt.connection` is an optional selector to the connection path.\n  // `callback` is optional and is a function to be called once the token reaches the target.\n  sendToken: function (token, opt, callback) {\n    function onAnimationEnd(vToken, callback) {\n      return function () {\n        vToken.remove();\n\n        if (typeof callback === 'function') {\n          callback();\n        }\n      };\n    }\n\n    var duration, isReversed, selector;\n\n    if (isObject(opt)) {\n      duration = opt.duration;\n      isReversed = opt.direction === 'reverse';\n      selector = opt.connection;\n    } else {\n      // Backwards compatibility\n      duration = opt;\n      isReversed = false;\n      selector = null;\n    }\n\n    duration = duration || 1000;\n    var animationAttributes = {\n      dur: duration + 'ms',\n      repeatCount: 1,\n      calcMode: 'linear',\n      fill: 'freeze'\n    };\n\n    if (isReversed) {\n      animationAttributes.keyPoints = '1;0';\n      animationAttributes.keyTimes = '0;1';\n    }\n\n    var vToken = V(token);\n    var connection;\n\n    if (typeof selector === 'string') {\n      // Use custom connection path.\n      connection = this.findBySelector(selector, this.el, this.selectors)[0];\n    } else {\n      // Select connection path automatically.\n      var cache = this._V;\n      connection = cache.connection ? cache.connection.node : this.el.querySelector('path');\n    }\n\n    if (!(connection instanceof SVGPathElement)) {\n      throw new Error('dia.LinkView: token animation requires a valid connection path.');\n    }\n\n    vToken.appendTo(this.paper.cells).animateAlongPath(animationAttributes, connection);\n    setTimeout(onAnimationEnd(vToken, callback), duration);\n  },\n  findRoute: function (vertices) {\n    vertices || (vertices = []);\n    var namespace = this.paper.options.routerNamespace || routers;\n    var router = this.model.router();\n    var defaultRouter = this.paper.options.defaultRouter;\n\n    if (!router) {\n      if (defaultRouter) router = defaultRouter;else return vertices.map(Point); // no router specified\n    }\n\n    var routerFn = isFunction(router) ? router : namespace[router.name];\n\n    if (!isFunction(routerFn)) {\n      throw new Error('dia.LinkView: unknown router: \"' + router.name + '\".');\n    }\n\n    var args = router.args || {};\n    var route = routerFn.call(this, // context\n    vertices, // vertices\n    args, // options\n    this // linkView\n    );\n    if (!route) return vertices.map(Point);\n    return route;\n  },\n  // Return the `d` attribute value of the `<path>` element representing the link\n  // between `source` and `target`.\n  findPath: function (route, sourcePoint, targetPoint) {\n    var namespace = this.paper.options.connectorNamespace || connectors;\n    var connector = this.model.connector();\n    var defaultConnector = this.paper.options.defaultConnector;\n\n    if (!connector) {\n      connector = defaultConnector || {};\n    }\n\n    var connectorFn = isFunction(connector) ? connector : namespace[connector.name];\n\n    if (!isFunction(connectorFn)) {\n      throw new Error('dia.LinkView: unknown connector: \"' + connector.name + '\".');\n    }\n\n    var args = clone(connector.args || {});\n    args.raw = true; // Request raw g.Path as the result.\n\n    var path = connectorFn.call(this, // context\n    sourcePoint, // start point\n    targetPoint, // end point\n    route, // vertices\n    args, // options\n    this // linkView\n    );\n\n    if (typeof path === 'string') {\n      // Backwards compatibility for connectors not supporting `raw` option.\n      path = new Path(V.normalizePathData(path));\n    }\n\n    return path;\n  },\n  // Public API.\n  // -----------\n  getConnection: function () {\n    var path = this.path;\n    if (!path) return null;\n    return path.clone();\n  },\n  getSerializedConnection: function () {\n    var path = this.path;\n    if (!path) return null;\n    var metrics = this.metrics;\n    if (metrics.hasOwnProperty('data')) return metrics.data;\n    var data = path.serialize();\n    metrics.data = data;\n    return data;\n  },\n  getConnectionSubdivisions: function () {\n    var path = this.path;\n    if (!path) return null;\n    var metrics = this.metrics;\n    if (metrics.hasOwnProperty('segmentSubdivisions')) return metrics.segmentSubdivisions;\n    var subdivisions = path.getSegmentSubdivisions();\n    metrics.segmentSubdivisions = subdivisions;\n    return subdivisions;\n  },\n  getConnectionLength: function () {\n    var path = this.path;\n    if (!path) return 0;\n    var metrics = this.metrics;\n    if (metrics.hasOwnProperty('length')) return metrics.length;\n    var length = path.length({\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n    metrics.length = length;\n    return length;\n  },\n  getPointAtLength: function (length) {\n    var path = this.path;\n    if (!path) return null;\n    return path.pointAtLength(length, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  },\n  getPointAtRatio: function (ratio) {\n    var path = this.path;\n    if (!path) return null;\n    if (isPercentage(ratio)) ratio = parseFloat(ratio) / 100;\n    return path.pointAt(ratio, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  },\n  getTangentAtLength: function (length) {\n    var path = this.path;\n    if (!path) return null;\n    return path.tangentAtLength(length, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  },\n  getTangentAtRatio: function (ratio) {\n    var path = this.path;\n    if (!path) return null;\n    return path.tangentAt(ratio, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  },\n  getClosestPoint: function (point) {\n    var path = this.path;\n    if (!path) return null;\n    return path.closestPoint(point, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  },\n  getClosestPointLength: function (point) {\n    var path = this.path;\n    if (!path) return null;\n    return path.closestPointLength(point, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  },\n  getClosestPointRatio: function (point) {\n    var path = this.path;\n    if (!path) return null;\n    return path.closestPointNormalizedLength(point, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  },\n  // Get label position object based on two provided coordinates, x and y.\n  // (Used behind the scenes when user moves labels around.)\n  // Two signatures:\n  // - num, num, obj = x, y, options\n  // - num, num, num, obj = x, y, angle, options\n  // Accepts distance/offset options = `absoluteDistance: boolean`, `reverseDistance: boolean`, `absoluteOffset: boolean`\n  // - `absoluteOffset` is necessary in order to move beyond connection endpoints\n  // Additional options = `keepGradient: boolean`, `ensureLegibility: boolean`\n  getLabelPosition: function (x, y, p3, p4) {\n    var position = {}; // normalize data from the two possible signatures\n\n    var localAngle = 0;\n    var localOpt;\n\n    if (typeof p3 === 'number') {\n      // angle and opt provided as third and fourth argument\n      localAngle = p3;\n      localOpt = p4;\n    } else {\n      // opt provided as third argument\n      localOpt = p3;\n    } // save localOpt as `args` of the position object that is passed along\n\n\n    if (localOpt) position.args = localOpt; // identify distance/offset settings\n\n    var isDistanceRelative = !(localOpt && localOpt.absoluteDistance); // relative by default\n\n    var isDistanceAbsoluteReverse = localOpt && localOpt.absoluteDistance && localOpt.reverseDistance; // non-reverse by default\n\n    var isOffsetAbsolute = localOpt && localOpt.absoluteOffset; // offset is non-absolute by default\n    // find closest point t\n\n    var path = this.path;\n    var pathOpt = {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    };\n    var labelPoint = new Point(x, y);\n    var t = path.closestPointT(labelPoint, pathOpt); // DISTANCE:\n\n    var labelDistance = path.lengthAtT(t, pathOpt);\n    if (isDistanceRelative) labelDistance = labelDistance / this.getConnectionLength() || 0; // fix to prevent NaN for 0 length\n\n    if (isDistanceAbsoluteReverse) labelDistance = -1 * (this.getConnectionLength() - labelDistance) || 1; // fix for end point (-0 => 1)\n\n    position.distance = labelDistance; // OFFSET:\n    // use absolute offset if:\n    // - opt.absoluteOffset is true,\n    // - opt.absoluteOffset is not true but there is no tangent\n\n    var tangent;\n    if (!isOffsetAbsolute) tangent = path.tangentAtT(t);\n    var labelOffset;\n\n    if (tangent) {\n      labelOffset = tangent.pointOffset(labelPoint);\n    } else {\n      var closestPoint = path.pointAtT(t);\n      var labelOffsetDiff = labelPoint.difference(closestPoint);\n      labelOffset = {\n        x: labelOffsetDiff.x,\n        y: labelOffsetDiff.y\n      };\n    }\n\n    position.offset = labelOffset; // ANGLE:\n\n    position.angle = localAngle;\n    return position;\n  },\n  _getLabelTransformationMatrix: function (labelPosition) {\n    var labelDistance;\n    var labelAngle = 0;\n    var args = {};\n\n    if (typeof labelPosition === 'number') {\n      labelDistance = labelPosition;\n    } else if (typeof labelPosition.distance === 'number') {\n      args = labelPosition.args || {};\n      labelDistance = labelPosition.distance;\n      labelAngle = labelPosition.angle || 0;\n    } else {\n      throw new Error('dia.LinkView: invalid label position distance.');\n    }\n\n    var isDistanceRelative = labelDistance > 0 && labelDistance <= 1;\n    var labelOffset = 0;\n    var labelOffsetCoordinates = {\n      x: 0,\n      y: 0\n    };\n\n    if (labelPosition.offset) {\n      var positionOffset = labelPosition.offset;\n      if (typeof positionOffset === 'number') labelOffset = positionOffset;\n      if (positionOffset.x) labelOffsetCoordinates.x = positionOffset.x;\n      if (positionOffset.y) labelOffsetCoordinates.y = positionOffset.y;\n    }\n\n    var isOffsetAbsolute = labelOffsetCoordinates.x !== 0 || labelOffsetCoordinates.y !== 0 || labelOffset === 0;\n    var isKeepGradient = args.keepGradient;\n    var isEnsureLegibility = args.ensureLegibility;\n    var path = this.path;\n    var pathOpt = {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    };\n    var distance = isDistanceRelative ? labelDistance * this.getConnectionLength() : labelDistance;\n    var tangent = path.tangentAtLength(distance, pathOpt);\n    var translation;\n    var angle = labelAngle;\n\n    if (tangent) {\n      if (isOffsetAbsolute) {\n        translation = tangent.start;\n        translation.offset(labelOffsetCoordinates);\n      } else {\n        var normal = tangent.clone();\n        normal.rotate(tangent.start, -90);\n        normal.setLength(labelOffset);\n        translation = normal.end;\n      }\n\n      if (isKeepGradient) {\n        angle = tangent.angle() + labelAngle;\n\n        if (isEnsureLegibility) {\n          angle = normalizeAngle((angle + 90) % 180 - 90);\n        }\n      }\n    } else {\n      // fallback - the connection has zero length\n      translation = path.start;\n      if (isOffsetAbsolute) translation.offset(labelOffsetCoordinates);\n    }\n\n    return V.createSVGMatrix().translate(translation.x, translation.y).rotate(angle);\n  },\n  getLabelCoordinates: function (labelPosition) {\n    var transformationMatrix = this._getLabelTransformationMatrix(labelPosition);\n\n    return new Point(transformationMatrix.e, transformationMatrix.f);\n  },\n  getVertexIndex: function (x, y) {\n    var model = this.model;\n    var vertices = model.vertices();\n    var vertexLength = this.getClosestPointLength(new Point(x, y));\n    var idx = 0;\n\n    for (var n = vertices.length; idx < n; idx++) {\n      var currentVertex = vertices[idx];\n      var currentVertexLength = this.getClosestPointLength(currentVertex);\n      if (vertexLength < currentVertexLength) break;\n    }\n\n    return idx;\n  },\n\n  // Interaction. The controller part.\n  // ---------------------------------\n  notifyPointerdown(evt, x, y) {\n    CellView.prototype.pointerdown.call(this, evt, x, y);\n    this.notify('link:pointerdown', evt, x, y);\n  },\n\n  notifyPointermove(evt, x, y) {\n    CellView.prototype.pointermove.call(this, evt, x, y);\n    this.notify('link:pointermove', evt, x, y);\n  },\n\n  notifyPointerup(evt, x, y) {\n    this.notify('link:pointerup', evt, x, y);\n    CellView.prototype.pointerup.call(this, evt, x, y);\n  },\n\n  pointerdblclick: function (evt, x, y) {\n    CellView.prototype.pointerdblclick.apply(this, arguments);\n    this.notify('link:pointerdblclick', evt, x, y);\n  },\n  pointerclick: function (evt, x, y) {\n    CellView.prototype.pointerclick.apply(this, arguments);\n    this.notify('link:pointerclick', evt, x, y);\n  },\n  contextmenu: function (evt, x, y) {\n    CellView.prototype.contextmenu.apply(this, arguments);\n    this.notify('link:contextmenu', evt, x, y);\n  },\n  pointerdown: function (evt, x, y) {\n    this.notifyPointerdown(evt, x, y); // Backwards compatibility for the default markup\n\n    var className = evt.target.getAttribute('class');\n\n    switch (className) {\n      case 'marker-vertex':\n        this.dragVertexStart(evt, x, y);\n        return;\n\n      case 'marker-vertex-remove':\n      case 'marker-vertex-remove-area':\n        this.dragVertexRemoveStart(evt, x, y);\n        return;\n\n      case 'marker-arrowhead':\n        this.dragArrowheadStart(evt, x, y);\n        return;\n\n      case 'connection':\n      case 'connection-wrap':\n        this.dragConnectionStart(evt, x, y);\n        return;\n\n      case 'marker-source':\n      case 'marker-target':\n        return;\n    }\n\n    this.dragStart(evt, x, y);\n  },\n  pointermove: function (evt, x, y) {\n    // Backwards compatibility\n    var dragData = this._dragData;\n    if (dragData) this.eventData(evt, dragData);\n    var data = this.eventData(evt);\n\n    switch (data.action) {\n      case 'vertex-move':\n        this.dragVertex(evt, x, y);\n        break;\n\n      case 'label-move':\n        this.dragLabel(evt, x, y);\n        break;\n\n      case 'arrowhead-move':\n        this.dragArrowhead(evt, x, y);\n        break;\n\n      case 'move':\n        this.drag(evt, x, y);\n        break;\n    } // Backwards compatibility\n\n\n    if (dragData) assign(dragData, this.eventData(evt));\n    this.notifyPointermove(evt, x, y);\n  },\n  pointerup: function (evt, x, y) {\n    // Backwards compatibility\n    var dragData = this._dragData;\n\n    if (dragData) {\n      this.eventData(evt, dragData);\n      this._dragData = null;\n    }\n\n    var data = this.eventData(evt);\n\n    switch (data.action) {\n      case 'vertex-move':\n        this.dragVertexEnd(evt, x, y);\n        break;\n\n      case 'label-move':\n        this.dragLabelEnd(evt, x, y);\n        break;\n\n      case 'arrowhead-move':\n        this.dragArrowheadEnd(evt, x, y);\n        break;\n\n      case 'move':\n        this.dragEnd(evt, x, y);\n    }\n\n    this.notifyPointerup(evt, x, y);\n    this.checkMouseleave(evt);\n  },\n  mouseover: function (evt) {\n    CellView.prototype.mouseover.apply(this, arguments);\n    this.notify('link:mouseover', evt);\n  },\n  mouseout: function (evt) {\n    CellView.prototype.mouseout.apply(this, arguments);\n    this.notify('link:mouseout', evt);\n  },\n  mouseenter: function (evt) {\n    CellView.prototype.mouseenter.apply(this, arguments);\n    this.notify('link:mouseenter', evt);\n  },\n  mouseleave: function (evt) {\n    CellView.prototype.mouseleave.apply(this, arguments);\n    this.notify('link:mouseleave', evt);\n  },\n  mousewheel: function (evt, x, y, delta) {\n    CellView.prototype.mousewheel.apply(this, arguments);\n    this.notify('link:mousewheel', evt, x, y, delta);\n  },\n  onevent: function (evt, eventName, x, y) {\n    // Backwards compatibility\n    var linkTool = V(evt.target).findParentByClass('link-tool', this.el);\n\n    if (linkTool) {\n      // No further action to be executed\n      evt.stopPropagation(); // Allow `interactive.useLinkTools=false`\n\n      if (this.can('useLinkTools')) {\n        if (eventName === 'remove') {\n          // Built-in remove event\n          this.model.remove({\n            ui: true\n          }); // Do not trigger link pointerdown\n\n          return;\n        } else {\n          // link:options and other custom events inside the link tools\n          this.notify(eventName, evt, x, y);\n        }\n      }\n\n      this.notifyPointerdown(evt, x, y);\n      this.paper.delegateDragEvents(this, evt.data);\n    } else {\n      CellView.prototype.onevent.apply(this, arguments);\n    }\n  },\n  onlabel: function (evt, x, y) {\n    this.notifyPointerdown(evt, x, y);\n    this.dragLabelStart(evt, x, y);\n    var stopPropagation = this.eventData(evt).stopPropagation;\n    if (stopPropagation) evt.stopPropagation();\n  },\n  // Drag Start Handlers\n  dragConnectionStart: function (evt, x, y) {\n    if (!this.can('vertexAdd')) return; // Store the index at which the new vertex has just been placed.\n    // We'll be update the very same vertex position in `pointermove()`.\n\n    var vertexIdx = this.addVertex({\n      x: x,\n      y: y\n    }, {\n      ui: true\n    });\n    this.eventData(evt, {\n      action: 'vertex-move',\n      vertexIdx: vertexIdx\n    });\n  },\n  dragLabelStart: function (evt, _x, _y) {\n    if (this.can('labelMove')) {\n      var labelNode = evt.currentTarget;\n      var labelIdx = parseInt(labelNode.getAttribute('label-idx'), 10);\n\n      var positionAngle = this._getLabelPositionAngle(labelIdx);\n\n      var labelPositionArgs = this._getLabelPositionArgs(labelIdx);\n\n      var defaultLabelPositionArgs = this._getDefaultLabelPositionArgs();\n\n      var positionArgs = this._mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);\n\n      this.eventData(evt, {\n        action: 'label-move',\n        labelIdx: labelIdx,\n        positionAngle: positionAngle,\n        positionArgs: positionArgs,\n        stopPropagation: true\n      });\n    } else {\n      // Backwards compatibility:\n      // If labels can't be dragged no default action is triggered.\n      this.eventData(evt, {\n        stopPropagation: true\n      });\n    }\n\n    this.paper.delegateDragEvents(this, evt.data);\n  },\n  dragVertexStart: function (evt, x, y) {\n    if (!this.can('vertexMove')) return;\n    var vertexNode = evt.target;\n    var vertexIdx = parseInt(vertexNode.getAttribute('idx'), 10);\n    this.eventData(evt, {\n      action: 'vertex-move',\n      vertexIdx: vertexIdx\n    });\n  },\n  dragVertexRemoveStart: function (evt, x, y) {\n    if (!this.can('vertexRemove')) return;\n    var removeNode = evt.target;\n    var vertexIdx = parseInt(removeNode.getAttribute('idx'), 10);\n    this.model.removeVertex(vertexIdx);\n  },\n  dragArrowheadStart: function (evt, x, y) {\n    if (!this.can('arrowheadMove')) return;\n    var arrowheadNode = evt.target;\n    var arrowheadType = arrowheadNode.getAttribute('end');\n    var data = this.startArrowheadMove(arrowheadType, {\n      ignoreBackwardsCompatibility: true\n    });\n    this.eventData(evt, data);\n  },\n  dragStart: function (evt, x, y) {\n    if (!this.can('linkMove')) return;\n    this.eventData(evt, {\n      action: 'move',\n      dx: x,\n      dy: y\n    });\n  },\n  // Drag Handlers\n  dragLabel: function (evt, x, y) {\n    var data = this.eventData(evt);\n    var label = {\n      position: this.getLabelPosition(x, y, data.positionAngle, data.positionArgs)\n    };\n    if (this.paper.options.snapLabels) delete label.position.offset;\n    this.model.label(data.labelIdx, label);\n  },\n  dragVertex: function (evt, x, y) {\n    var data = this.eventData(evt);\n    this.model.vertex(data.vertexIdx, {\n      x: x,\n      y: y\n    }, {\n      ui: true\n    });\n  },\n  dragArrowhead: function (evt, x, y) {\n    if (this.paper.options.snapLinks) {\n      this._snapArrowhead(evt, x, y);\n    } else {\n      this._connectArrowhead(this.getEventTarget(evt), x, y, this.eventData(evt));\n    }\n  },\n  drag: function (evt, x, y) {\n    var data = this.eventData(evt);\n    this.model.translate(x - data.dx, y - data.dy, {\n      ui: true\n    });\n    this.eventData(evt, {\n      dx: x,\n      dy: y\n    });\n  },\n  // Drag End Handlers\n  dragLabelEnd: function () {// noop\n  },\n  dragVertexEnd: function () {// noop\n  },\n  dragArrowheadEnd: function (evt, x, y) {\n    var data = this.eventData(evt);\n    var paper = this.paper;\n\n    if (paper.options.snapLinks) {\n      this._snapArrowheadEnd(data);\n    } else {\n      this._connectArrowheadEnd(data, x, y);\n    }\n\n    if (!paper.linkAllowed(this)) {\n      // If the changed link is not allowed, revert to its previous state.\n      this._disallow(data);\n    } else {\n      this._finishEmbedding(data);\n\n      this._notifyConnectEvent(data, evt);\n    }\n\n    this._afterArrowheadMove(data);\n  },\n  dragEnd: function () {// noop\n  },\n  _disallow: function (data) {\n    switch (data.whenNotAllowed) {\n      case 'remove':\n        this.model.remove({\n          ui: true\n        });\n        break;\n\n      case 'revert':\n      default:\n        this.model.set(data.arrowhead, data.initialEnd, {\n          ui: true\n        });\n        break;\n    }\n  },\n  _finishEmbedding: function (data) {\n    // Reparent the link if embedding is enabled\n    if (this.paper.options.embeddingMode && this.model.reparent()) {\n      // Make sure we don't reverse to the original 'z' index (see afterArrowheadMove()).\n      data.z = null;\n    }\n  },\n  _notifyConnectEvent: function (data, evt) {\n    var arrowhead = data.arrowhead;\n    var initialEnd = data.initialEnd;\n    var currentEnd = this.model.prop(arrowhead);\n    var endChanged = currentEnd && !Link.endsEqual(initialEnd, currentEnd);\n\n    if (endChanged) {\n      var paper = this.paper;\n\n      if (initialEnd.id) {\n        this.notify('link:disconnect', evt, paper.findViewByModel(initialEnd.id), data.initialMagnet, arrowhead);\n      }\n\n      if (currentEnd.id) {\n        this.notify('link:connect', evt, paper.findViewByModel(currentEnd.id), data.magnetUnderPointer, arrowhead);\n      }\n    }\n  },\n  _snapArrowhead: function (evt, x, y) {\n    const {\n      paper\n    } = this;\n    const {\n      snapLinks,\n      connectionStrategy\n    } = paper.options;\n    const data = this.eventData(evt); // checking view in close area of the pointer\n\n    var r = snapLinks.radius || 50;\n    var viewsInArea = paper.findViewsInArea({\n      x: x - r,\n      y: y - r,\n      width: 2 * r,\n      height: 2 * r\n    });\n    var prevClosestView = data.closestView || null;\n    var prevClosestMagnet = data.closestMagnet || null;\n    var prevMagnetProxy = data.magnetProxy || null;\n    data.closestView = data.closestMagnet = data.magnetProxy = null;\n    var minDistance = Number.MAX_VALUE;\n    var pointer = new Point(x, y);\n    viewsInArea.forEach(function (view) {\n      const candidates = []; // skip connecting to the element in case '.': { magnet: false } attribute present\n\n      if (view.el.getAttribute('magnet') !== 'false') {\n        candidates.push({\n          bbox: view.model.getBBox(),\n          magnet: view.el\n        });\n      }\n\n      view.$('[magnet]').toArray().forEach(magnet => {\n        candidates.push({\n          bbox: view.getNodeBBox(magnet),\n          magnet\n        });\n      });\n      candidates.forEach(candidate => {\n        const {\n          magnet,\n          bbox\n        } = candidate; // find distance from the center of the model to pointer coordinates\n\n        const distance = bbox.center().squaredDistance(pointer); // the connection is looked up in a circle area by `distance < r`\n\n        if (distance < minDistance) {\n          const isAlreadyValidated = prevClosestMagnet === magnet;\n\n          if (isAlreadyValidated || paper.options.validateConnection.apply(paper, data.validateConnectionArgs(view, view.el === magnet ? null : magnet))) {\n            minDistance = distance;\n            data.closestView = view;\n            data.closestMagnet = magnet;\n          }\n        }\n      });\n    }, this);\n    var end;\n    var magnetProxy = null;\n    var closestView = data.closestView;\n    var closestMagnet = data.closestMagnet;\n\n    if (closestMagnet) {\n      magnetProxy = data.magnetProxy = closestView.findProxyNode(closestMagnet, 'highlighter');\n    }\n\n    var endType = data.arrowhead;\n    var newClosestMagnet = prevClosestMagnet !== closestMagnet;\n\n    if (prevClosestView && newClosestMagnet) {\n      prevClosestView.unhighlight(prevMagnetProxy, {\n        connecting: true,\n        snapping: true\n      });\n    }\n\n    if (closestView) {\n      const {\n        prevEnd,\n        prevX,\n        prevY\n      } = data;\n      data.prevX = x;\n      data.prevY = y;\n\n      if (!newClosestMagnet) {\n        if (typeof connectionStrategy !== 'function' || prevX === x && prevY === y) {\n          // the magnet has not changed and the link's end does not depend on the x and y\n          return;\n        }\n      }\n\n      end = closestView.getLinkEnd(closestMagnet, x, y, this.model, endType);\n\n      if (!newClosestMagnet && isEqual(prevEnd, end)) {\n        // the source/target json has not changed\n        return;\n      }\n\n      data.prevEnd = end;\n\n      if (newClosestMagnet) {\n        closestView.highlight(magnetProxy, {\n          connecting: true,\n          snapping: true\n        });\n      }\n    } else {\n      end = {\n        x: x,\n        y: y\n      };\n    }\n\n    this.model.set(endType, end || {\n      x: x,\n      y: y\n    }, {\n      ui: true\n    });\n\n    if (prevClosestView) {\n      this.notify('link:snap:disconnect', evt, prevClosestView, prevClosestMagnet, endType);\n    }\n\n    if (closestView) {\n      this.notify('link:snap:connect', evt, closestView, closestMagnet, endType);\n    }\n  },\n  _snapArrowheadEnd: function (data) {\n    // Finish off link snapping.\n    // Everything except view unhighlighting was already done on pointermove.\n    var closestView = data.closestView;\n    var closestMagnet = data.closestMagnet;\n\n    if (closestView && closestMagnet) {\n      closestView.unhighlight(data.magnetProxy, {\n        connecting: true,\n        snapping: true\n      });\n      data.magnetUnderPointer = closestView.findMagnet(closestMagnet);\n    }\n\n    data.closestView = data.closestMagnet = null;\n  },\n  _connectArrowhead: function (target, x, y, data) {\n    // checking views right under the pointer\n    const {\n      paper,\n      model\n    } = this;\n\n    if (data.eventTarget !== target) {\n      // Unhighlight the previous view under pointer if there was one.\n      if (data.magnetProxy) {\n        data.viewUnderPointer.unhighlight(data.magnetProxy, {\n          connecting: true\n        });\n      }\n\n      const viewUnderPointer = data.viewUnderPointer = paper.findView(target);\n\n      if (viewUnderPointer) {\n        // If we found a view that is under the pointer, we need to find the closest\n        // magnet based on the real target element of the event.\n        const magnetUnderPointer = data.magnetUnderPointer = viewUnderPointer.findMagnet(target);\n        const magnetProxy = data.magnetProxy = viewUnderPointer.findProxyNode(magnetUnderPointer, 'highlighter');\n\n        if (magnetUnderPointer && this.paper.options.validateConnection.apply(paper, data.validateConnectionArgs(viewUnderPointer, magnetUnderPointer))) {\n          // If there was no magnet found, do not highlight anything and assume there\n          // is no view under pointer we're interested in reconnecting to.\n          // This can only happen if the overall element has the attribute `'.': { magnet: false }`.\n          if (magnetProxy) {\n            viewUnderPointer.highlight(magnetProxy, {\n              connecting: true\n            });\n          }\n        } else {\n          // This type of connection is not valid. Disregard this magnet.\n          data.magnetUnderPointer = null;\n          data.magnetProxy = null;\n        }\n      } else {\n        // Make sure we'll unset previous magnet.\n        data.magnetUnderPointer = null;\n        data.magnetProxy = null;\n      }\n    }\n\n    data.eventTarget = target;\n    model.set(data.arrowhead, {\n      x: x,\n      y: y\n    }, {\n      ui: true\n    });\n  },\n  _connectArrowheadEnd: function (data = {}, x, y) {\n    const {\n      model\n    } = this;\n    const {\n      viewUnderPointer,\n      magnetUnderPointer,\n      magnetProxy,\n      arrowhead\n    } = data;\n    if (!magnetUnderPointer || !magnetProxy || !viewUnderPointer) return;\n    viewUnderPointer.unhighlight(magnetProxy, {\n      connecting: true\n    }); // The link end is taken from the magnet under the pointer, not the proxy.\n\n    const end = viewUnderPointer.getLinkEnd(magnetUnderPointer, x, y, model, arrowhead);\n    model.set(arrowhead, end, {\n      ui: true\n    });\n  },\n  _beforeArrowheadMove: function (data) {\n    data.z = this.model.get('z');\n    this.model.toFront(); // Let the pointer propagate through the link view elements so that\n    // the `evt.target` is another element under the pointer, not the link itself.\n\n    var style = this.el.style;\n    data.pointerEvents = style.pointerEvents;\n    style.pointerEvents = 'none';\n\n    if (this.paper.options.markAvailable) {\n      this._markAvailableMagnets(data);\n    }\n  },\n  _afterArrowheadMove: function (data) {\n    if (data.z !== null) {\n      this.model.set('z', data.z, {\n        ui: true\n      });\n      data.z = null;\n    } // Put `pointer-events` back to its original value. See `_beforeArrowheadMove()` for explanation.\n\n\n    this.el.style.pointerEvents = data.pointerEvents;\n\n    if (this.paper.options.markAvailable) {\n      this._unmarkAvailableMagnets(data);\n    }\n  },\n  _createValidateConnectionArgs: function (arrowhead) {\n    // It makes sure the arguments for validateConnection have the following form:\n    // (source view, source magnet, target view, target magnet and link view)\n    var args = [];\n    args[4] = arrowhead;\n    args[5] = this;\n    var oppositeArrowhead;\n    var i = 0;\n    var j = 0;\n\n    if (arrowhead === 'source') {\n      i = 2;\n      oppositeArrowhead = 'target';\n    } else {\n      j = 2;\n      oppositeArrowhead = 'source';\n    }\n\n    var end = this.model.get(oppositeArrowhead);\n\n    if (end.id) {\n      var view = args[i] = this.paper.findViewByModel(end.id);\n      var magnet = view.getMagnetFromLinkEnd(end);\n      if (magnet === view.el) magnet = undefined;\n      args[i + 1] = magnet;\n    }\n\n    function validateConnectionArgs(cellView, magnet) {\n      args[j] = cellView;\n      args[j + 1] = cellView.el === magnet ? undefined : magnet;\n      return args;\n    }\n\n    return validateConnectionArgs;\n  },\n  _markAvailableMagnets: function (data) {\n    function isMagnetAvailable(view, magnet) {\n      var paper = view.paper;\n      var validate = paper.options.validateConnection;\n      return validate.apply(paper, this.validateConnectionArgs(view, magnet));\n    }\n\n    var paper = this.paper;\n    var elements = paper.model.getCells();\n    data.marked = {};\n\n    for (var i = 0, n = elements.length; i < n; i++) {\n      var view = elements[i].findView(paper);\n\n      if (!view) {\n        continue;\n      }\n\n      var magnets = Array.prototype.slice.call(view.el.querySelectorAll('[magnet]'));\n\n      if (view.el.getAttribute('magnet') !== 'false') {\n        // Element wrapping group is also a magnet\n        magnets.push(view.el);\n      }\n\n      var availableMagnets = magnets.filter(isMagnetAvailable.bind(data, view));\n\n      if (availableMagnets.length > 0) {\n        // highlight all available magnets\n        for (var j = 0, m = availableMagnets.length; j < m; j++) {\n          view.highlight(availableMagnets[j], {\n            magnetAvailability: true\n          });\n        } // highlight the entire view\n\n\n        view.highlight(null, {\n          elementAvailability: true\n        });\n        data.marked[view.model.id] = availableMagnets;\n      }\n    }\n  },\n  _unmarkAvailableMagnets: function (data) {\n    var markedKeys = Object.keys(data.marked);\n    var id;\n    var markedMagnets;\n\n    for (var i = 0, n = markedKeys.length; i < n; i++) {\n      id = markedKeys[i];\n      markedMagnets = data.marked[id];\n      var view = this.paper.findViewByModel(id);\n\n      if (view) {\n        for (var j = 0, m = markedMagnets.length; j < m; j++) {\n          view.unhighlight(markedMagnets[j], {\n            magnetAvailability: true\n          });\n        }\n\n        view.unhighlight(null, {\n          elementAvailability: true\n        });\n      }\n    }\n\n    data.marked = null;\n  },\n  startArrowheadMove: function (end, opt) {\n    opt || (opt = {}); // Allow to delegate events from an another view to this linkView in order to trigger arrowhead\n    // move without need to click on the actual arrowhead dom element.\n\n    var data = {\n      action: 'arrowhead-move',\n      arrowhead: end,\n      whenNotAllowed: opt.whenNotAllowed || 'revert',\n      initialMagnet: this[end + 'Magnet'] || (this[end + 'View'] ? this[end + 'View'].el : null),\n      initialEnd: clone(this.model.get(end)),\n      validateConnectionArgs: this._createValidateConnectionArgs(end)\n    };\n\n    this._beforeArrowheadMove(data);\n\n    if (opt.ignoreBackwardsCompatibility !== true) {\n      this._dragData = data;\n    }\n\n    return data;\n  },\n  onRemove: function () {\n    CellView.prototype.onRemove.apply(this, arguments);\n    this.unmountLabels();\n  }\n}, {\n  Flags: Flags\n});\nObject.defineProperty(LinkView.prototype, 'sourceBBox', {\n  enumerable: true,\n  get: function () {\n    var sourceView = this.sourceView;\n\n    if (!sourceView) {\n      var sourceDef = this.model.source();\n      return new Rect(sourceDef.x, sourceDef.y);\n    }\n\n    var sourceMagnet = this.sourceMagnet;\n\n    if (sourceView.isNodeConnection(sourceMagnet)) {\n      return new Rect(this.sourceAnchor);\n    }\n\n    return sourceView.getNodeBBox(sourceMagnet || sourceView.el);\n  }\n});\nObject.defineProperty(LinkView.prototype, 'targetBBox', {\n  enumerable: true,\n  get: function () {\n    var targetView = this.targetView;\n\n    if (!targetView) {\n      var targetDef = this.model.target();\n      return new Rect(targetDef.x, targetDef.y);\n    }\n\n    var targetMagnet = this.targetMagnet;\n\n    if (targetView.isNodeConnection(targetMagnet)) {\n      return new Rect(this.targetAnchor);\n    }\n\n    return targetView.getNodeBBox(targetMagnet || targetView.el);\n  }\n});","map":{"version":3,"names":["CellView","Link","V","addClassNamePrefix","removeClassNamePrefix","merge","template","assign","toArray","isObject","isFunction","clone","isPercentage","result","isEqual","Point","Line","Path","normalizeAngle","Rect","Polyline","routers","connectors","$","Flags","RENDER","UPDATE","TOOLS","LEGACY_TOOLS","LABELS","VERTICES","SOURCE","TARGET","CONNECTOR","LinkView","extend","className","classNames","prototype","apply","split","push","join","options","shortLinkLength","doubleLinkTools","longLinkLength","linkToolsOffset","doubleLinkToolsOffset","sampleInterval","_labelCache","_labelSelectors","_markerCache","_V","_dragData","metrics","decimalsRounding","initialize","arguments","cleanNodesCache","presentationAttributes","markup","attrs","router","connector","smooth","manhattan","toolMarkup","labels","labelMarkup","vertices","vertexMarkup","source","target","initFlag","UPDATE_PRIORITY","confirmUpdate","flags","opt","hasFlag","updateEndProperties","removeFlag","paper","sourceView","targetView","isViewMounted","render","updateHighlighters","updateTools","renderVertexMarkers","model","attributes","updateLabels","updateLegacyTools","onLabelsChange","renderTools","updateAll","updateConnector","updatePath","updateDOM","translateBy","isRelationshipEmbeddedIn","translate","tx","ty","update","updateLabelPositions","updateToolsPosition","requestConnectionUpdate","requestUpdate","getFlag","isLabelsRenderRequired","previousLabels","previous","pathArray","propertyPathArray","pathLength","length","labelExists","Object","propertyValue","_link","_labels","renderLabels","vel","empty","unmountLabels","renderMarkup","link","get","Error","Array","isArray","renderJSONMarkup","renderStringMarkup","doc","parseDOMJSON","el","selectors","append","fragment","children","cache","i","n","child","attr","camelCase","renderArrowheadMarkers","_getLabelMarkup","undefined","_getLabelStringMarkup","document","createDocumentFragment","appendChild","node","currentChild","_normalizeLabelMarkup","DocumentFragment","hasChildNodes","vNode","childNodes","nodeName","toUpperCase","addClass","vLabels","labelCache","labelSelectors","labelsCount","remove","labelsLayer","id","label","labelNode","builtinDefaultLabel","_builtins","defaultLabel","builtinDefaultLabelMarkup","_getDefaultLabel","defaultLabelMarkup","defaultMarkup","setAttribute","rootSelector","selector","parent","mountLabels","hasLabels","getLayerView","insertSortedNode","parentNode","onMount","unmount","findLabelNode","labelIndex","labelRoot","findBySelector","_mergeLabelAttrs","hasCustomMarkup","labelAttrs","defaultLabelAttrs","builtinDefaultLabelAttrs","canLabelMove","can","updateDOMSubtreeAttributes","rootBBox","size","linkTools","$tools","toolTemplate","tool","_toolCache","tool2","doubleToolMarkup","_tool2Cache","markerVertices","$markerVertices","markupTemplate","forEach","vertex","idx","markerArrowheads","$markerArrowheads","arrowheadMarkup","sourceArrowhead","end","targetArrowhead","removeRedundantLinearVertices","SIMPLIFY_THRESHOLD","routePoints","sourceAnchor","targetAnchor","numRoutePoints","polyline","simplify","threshold","polylinePoints","points","map","point","toJSON","numPolylinePoints","slice","updateDefaultConnectionPath","connection","getSerializedConnection","connectionWrap","markerSource","markerTarget","_translateAndAutoOrientArrows","getEndView","type","getEndAnchor","getEndConnectionPoint","sourcePoint","targetPoint","getEndMagnet","sourceMagnet","targetMagnet","updateRoute","route","path","_translateConnectionPoints","updateArrowheadMarkers","perpendicular","anchors","findAnchors","findRoute","connectionPoints","findConnectionPoints","markerPoints","findMarkerPoints","findPath","firstWaypoint","lastWaypoint","sourceMarkerPoint","targetMarkerPoint","sourceBBox","getBBox","move","width","scale","sx","round","targetBBox","findAnchorsOrdered","firstEndType","firstRef","secondEndType","secondRef","firstAnchor","secondAnchor","firstAnchorRef","secondAnchorRef","firstDef","secondDef","firstView","secondView","firstMagnet","secondMagnet","getAnchor","anchor","res","firstVertex","lastVertex","priority","sourceDef","targetDef","paperOptions","isNodeConnection","sourceConnectionPointDef","connectionPoint","defaultConnectionPoint","sourcePointRef","sourceLine","getConnectionPoint","targetConnectionPointDef","targetPointRef","targetLine","anchorDef","cellView","magnet","ref","endType","isConnection","defaultLinkAnchor","perpendicularLinks","name","defaultAnchor","anchorFn","anchorName","anchorNamespace","call","args","connectionPointDef","view","line","linkConnectionPoint","linkConnectionMagnet","start","connectionPointFn","connectionPointName","connectionPointNamespace","offset","_normalizeLabelPosition","labelPosition","distance","angle","builtinDefaultLabelPosition","position","defaultLabelPosition","defaultPosition","transformationMatrix","_getLabelTransformationMatrix","matrixToTransformString","_cleanLabelMatrices","index","magnetMatrix","connectionLength","getConnectionLength","Number","isNaN","toolPosition","getPointAtLength","x","y","css","endViewProperty","endDef","endId","updateEndMagnet","endModel","getModelById","endView","findView","endMagnetProperty","connectedMagnet","getMagnetFromLinkEnd","sourceArrow","targetArrow","translateAndAutoOrient","cells","_getLabelPositionAngle","_getLabelPositionArgs","_getDefaultLabelPositionArgs","_mergeLabelPositionArgs","labelPositionArgs","defaultLabelPositionArgs","addLabel","p1","p2","p3","p4","localX","localY","localAngle","localOpt","positionArgs","getLabelPosition","insertLabel","addVertex","isPointProvided","getVertexIndex","insertVertex","sendToken","token","callback","onAnimationEnd","vToken","duration","isReversed","direction","animationAttributes","dur","repeatCount","calcMode","fill","keyPoints","keyTimes","querySelector","SVGPathElement","appendTo","animateAlongPath","setTimeout","namespace","routerNamespace","defaultRouter","routerFn","connectorNamespace","defaultConnector","connectorFn","raw","normalizePathData","getConnection","hasOwnProperty","data","serialize","getConnectionSubdivisions","segmentSubdivisions","subdivisions","getSegmentSubdivisions","pointAtLength","getPointAtRatio","ratio","parseFloat","pointAt","getTangentAtLength","tangentAtLength","getTangentAtRatio","tangentAt","getClosestPoint","closestPoint","getClosestPointLength","closestPointLength","getClosestPointRatio","closestPointNormalizedLength","isDistanceRelative","absoluteDistance","isDistanceAbsoluteReverse","reverseDistance","isOffsetAbsolute","absoluteOffset","pathOpt","labelPoint","t","closestPointT","labelDistance","lengthAtT","tangent","tangentAtT","labelOffset","pointOffset","pointAtT","labelOffsetDiff","difference","labelAngle","labelOffsetCoordinates","positionOffset","isKeepGradient","keepGradient","isEnsureLegibility","ensureLegibility","translation","normal","rotate","setLength","createSVGMatrix","getLabelCoordinates","e","f","vertexLength","currentVertex","currentVertexLength","notifyPointerdown","evt","pointerdown","notify","notifyPointermove","pointermove","notifyPointerup","pointerup","pointerdblclick","pointerclick","contextmenu","getAttribute","dragVertexStart","dragVertexRemoveStart","dragArrowheadStart","dragConnectionStart","dragStart","dragData","eventData","action","dragVertex","dragLabel","dragArrowhead","drag","dragVertexEnd","dragLabelEnd","dragArrowheadEnd","dragEnd","checkMouseleave","mouseover","mouseout","mouseenter","mouseleave","mousewheel","delta","onevent","eventName","linkTool","findParentByClass","stopPropagation","ui","delegateDragEvents","onlabel","dragLabelStart","vertexIdx","_x","_y","currentTarget","labelIdx","parseInt","positionAngle","vertexNode","removeNode","removeVertex","arrowheadNode","arrowheadType","startArrowheadMove","ignoreBackwardsCompatibility","dx","dy","snapLabels","snapLinks","_snapArrowhead","_connectArrowhead","getEventTarget","_snapArrowheadEnd","_connectArrowheadEnd","linkAllowed","_disallow","_finishEmbedding","_notifyConnectEvent","_afterArrowheadMove","whenNotAllowed","set","arrowhead","initialEnd","embeddingMode","reparent","z","currentEnd","prop","endChanged","endsEqual","findViewByModel","initialMagnet","magnetUnderPointer","connectionStrategy","r","radius","viewsInArea","findViewsInArea","height","prevClosestView","closestView","prevClosestMagnet","closestMagnet","prevMagnetProxy","magnetProxy","minDistance","MAX_VALUE","pointer","candidates","bbox","getNodeBBox","candidate","center","squaredDistance","isAlreadyValidated","validateConnection","validateConnectionArgs","findProxyNode","newClosestMagnet","unhighlight","connecting","snapping","prevEnd","prevX","prevY","getLinkEnd","highlight","findMagnet","eventTarget","viewUnderPointer","_beforeArrowheadMove","toFront","style","pointerEvents","markAvailable","_markAvailableMagnets","_unmarkAvailableMagnets","_createValidateConnectionArgs","oppositeArrowhead","j","isMagnetAvailable","validate","elements","getCells","marked","magnets","querySelectorAll","availableMagnets","filter","bind","m","magnetAvailability","elementAvailability","markedKeys","keys","markedMagnets","onRemove","defineProperty","enumerable"],"sources":["C:/Users/Admin/dataflow-test/node_modules/jointjs/src/dia/LinkView.mjs"],"sourcesContent":["import { CellView } from './CellView.mjs';\nimport { Link } from './Link.mjs';\nimport V from '../V/index.mjs';\nimport { addClassNamePrefix, removeClassNamePrefix, merge, template, assign, toArray, isObject, isFunction, clone, isPercentage, result, isEqual } from '../util/index.mjs';\nimport { Point, Line, Path, normalizeAngle, Rect, Polyline } from '../g/index.mjs';\nimport * as routers from '../routers/index.mjs';\nimport * as connectors from '../connectors/index.mjs';\nimport $ from 'jquery';\n\nconst Flags = {\n    RENDER: 'RENDER',\n    UPDATE: 'UPDATE',\n    TOOLS: 'TOOLS',\n    LEGACY_TOOLS: 'LEGACY_TOOLS',\n    LABELS: 'LABELS',\n    VERTICES: 'VERTICES',\n    SOURCE: 'SOURCE',\n    TARGET: 'TARGET',\n    CONNECTOR: 'CONNECTOR'\n};\n\n// Link base view and controller.\n// ----------------------------------------\n\nexport const LinkView = CellView.extend({\n\n    className: function() {\n\n        var classNames = CellView.prototype.className.apply(this).split(' ');\n\n        classNames.push('link');\n\n        return classNames.join(' ');\n    },\n\n    options: {\n\n        shortLinkLength: 105,\n        doubleLinkTools: false,\n        longLinkLength: 155,\n        linkToolsOffset: 40,\n        doubleLinkToolsOffset: 65,\n        sampleInterval: 50,\n    },\n\n    _labelCache: null,\n    _labelSelectors: null,\n    _markerCache: null,\n    _V: null,\n    _dragData: null, // deprecated\n\n    metrics: null,\n    decimalsRounding: 2,\n\n    initialize: function() {\n\n        CellView.prototype.initialize.apply(this, arguments);\n\n        // `_.labelCache` is a mapping of indexes of labels in the `this.get('labels')` array to\n        // `<g class=\"label\">` nodes wrapped by Vectorizer. This allows for quick access to the\n        // nodes in `updateLabelPosition()` in order to update the label positions.\n        this._labelCache = {};\n\n        // a cache of label selectors\n        this._labelSelectors = {};\n\n        // keeps markers bboxes and positions again for quicker access\n        this._markerCache = {};\n\n        // cache of default markup nodes\n        this._V = {};\n\n        // connection path metrics\n        this.cleanNodesCache();\n    },\n\n    presentationAttributes: {\n        markup: [Flags.RENDER],\n        attrs: [Flags.UPDATE],\n        router: [Flags.UPDATE],\n        connector: [Flags.CONNECTOR],\n        smooth: [Flags.UPDATE],\n        manhattan: [Flags.UPDATE],\n        toolMarkup: [Flags.LEGACY_TOOLS],\n        labels: [Flags.LABELS],\n        labelMarkup: [Flags.LABELS],\n        vertices: [Flags.VERTICES, Flags.UPDATE],\n        vertexMarkup: [Flags.VERTICES],\n        source: [Flags.SOURCE, Flags.UPDATE],\n        target: [Flags.TARGET, Flags.UPDATE]\n    },\n\n    initFlag: [Flags.RENDER, Flags.SOURCE, Flags.TARGET, Flags.TOOLS],\n\n    UPDATE_PRIORITY: 1,\n\n    confirmUpdate: function(flags, opt) {\n\n        opt || (opt = {});\n\n        if (this.hasFlag(flags, Flags.SOURCE)) {\n            if (!this.updateEndProperties('source')) return flags;\n            flags = this.removeFlag(flags, Flags.SOURCE);\n        }\n\n        if (this.hasFlag(flags, Flags.TARGET)) {\n            if (!this.updateEndProperties('target')) return flags;\n            flags = this.removeFlag(flags, Flags.TARGET);\n        }\n\n        const { paper, sourceView, targetView } = this;\n        if (paper && ((sourceView && !paper.isViewMounted(sourceView)) || (targetView && !paper.isViewMounted(targetView)))) {\n            // Wait for the sourceView and targetView to be rendered\n            return flags;\n        }\n\n        if (this.hasFlag(flags, Flags.RENDER)) {\n            this.render();\n            this.updateHighlighters(true);\n            this.updateTools(opt);\n            flags = this.removeFlag(flags, [Flags.RENDER, Flags.UPDATE, Flags.VERTICES, Flags.LABELS, Flags.TOOLS, Flags.LEGACY_TOOLS, Flags.CONNECTOR]);\n            return flags;\n        }\n\n        let updateHighlighters = false;\n\n        if (this.hasFlag(flags, Flags.VERTICES)) {\n            this.renderVertexMarkers();\n            flags = this.removeFlag(flags, Flags.VERTICES);\n        }\n\n        const { model } = this;\n        const { attributes } = model;\n        let updateLabels = this.hasFlag(flags, Flags.LABELS);\n        let updateLegacyTools = this.hasFlag(flags, Flags.LEGACY_TOOLS);\n\n        if (updateLabels) {\n            this.onLabelsChange(model, attributes.labels, opt);\n            flags = this.removeFlag(flags, Flags.LABELS);\n            updateHighlighters = true;\n        }\n\n        if (updateLegacyTools) {\n            this.renderTools();\n            flags = this.removeFlag(flags, Flags.LEGACY_TOOLS);\n        }\n\n        const updateAll = this.hasFlag(flags, Flags.UPDATE);\n        const updateConnector = this.hasFlag(flags, Flags.CONNECTOR);\n        if (updateAll || updateConnector) {\n            if (!updateAll) {\n                // Keep the current route and update the geometry\n                this.updatePath();\n                this.updateDOM();\n            } else if (opt.translateBy && model.isRelationshipEmbeddedIn(opt.translateBy)) {\n                // The link is being translated by an ancestor that will\n                // shift source point, target point and all vertices\n                // by an equal distance.\n                this.translate(opt.tx, opt.ty);\n            } else {\n                this.update();\n            }\n            this.updateTools(opt);\n            flags = this.removeFlag(flags, [Flags.UPDATE, Flags.TOOLS, Flags.CONNECTOR]);\n            updateLabels = false;\n            updateLegacyTools = false;\n            updateHighlighters = true;\n        }\n\n        if (updateLabels) {\n            this.updateLabelPositions();\n        }\n\n        if (updateLegacyTools) {\n            this.updateToolsPosition();\n        }\n\n        if (updateHighlighters) {\n            this.updateHighlighters();\n        }\n\n        if (this.hasFlag(flags, Flags.TOOLS)) {\n            this.updateTools(opt);\n            flags = this.removeFlag(flags, Flags.TOOLS);\n        }\n\n        return flags;\n    },\n\n    requestConnectionUpdate: function(opt) {\n        this.requestUpdate(this.getFlag(Flags.UPDATE), opt);\n    },\n\n    isLabelsRenderRequired: function(opt = {}) {\n\n        const previousLabels = this.model.previous('labels');\n        if (!previousLabels) return true;\n\n        // Here is an optimization for cases when we know, that change does\n        // not require re-rendering of all labels.\n        if (('propertyPathArray' in opt) && ('propertyValue' in opt)) {\n            // The label is setting by `prop()` method\n            var pathArray = opt.propertyPathArray || [];\n            var pathLength = pathArray.length;\n            if (pathLength > 1) {\n                // We are changing a single label here e.g. 'labels/0/position'\n                var labelExists = !!previousLabels[pathArray[1]];\n                if (labelExists) {\n                    if (pathLength === 2) {\n                        // We are changing the entire label. Need to check if the\n                        // markup is also being changed.\n                        return ('markup' in Object(opt.propertyValue));\n                    } else if (pathArray[2] !== 'markup') {\n                        // We are changing a label property but not the markup\n                        return false;\n                    }\n                }\n            }\n        }\n\n        return true;\n    },\n\n    onLabelsChange: function(_link, _labels, opt) {\n\n        // Note: this optimization works in async=false mode only\n        if (this.isLabelsRenderRequired(opt)) {\n            this.renderLabels();\n        } else {\n            this.updateLabels();\n        }\n    },\n\n    // Rendering.\n    // ----------\n\n    render: function() {\n\n        this.vel.empty();\n        this.unmountLabels();\n        this._V = {};\n        this.renderMarkup();\n        // rendering labels has to be run after the link is appended to DOM tree. (otherwise <Text> bbox\n        // returns zero values)\n        this.renderLabels();\n        this.update();\n\n        return this;\n    },\n\n    renderMarkup: function() {\n\n        var link = this.model;\n        var markup = link.get('markup') || link.markup;\n        if (!markup) throw new Error('dia.LinkView: markup required');\n        if (Array.isArray(markup)) return this.renderJSONMarkup(markup);\n        if (typeof markup === 'string') return this.renderStringMarkup(markup);\n        throw new Error('dia.LinkView: invalid markup');\n    },\n\n    renderJSONMarkup: function(markup) {\n\n        var doc = this.parseDOMJSON(markup, this.el);\n        // Selectors\n        this.selectors = doc.selectors;\n        // Fragment\n        this.vel.append(doc.fragment);\n    },\n\n    renderStringMarkup: function(markup) {\n\n        // A special markup can be given in the `properties.markup` property. This might be handy\n        // if e.g. arrowhead markers should be `<image>` elements or any other element than `<path>`s.\n        // `.connection`, `.connection-wrap`, `.marker-source` and `.marker-target` selectors\n        // of elements with special meaning though. Therefore, those classes should be preserved in any\n        // special markup passed in `properties.markup`.\n        var children = V(markup);\n        // custom markup may contain only one children\n        if (!Array.isArray(children)) children = [children];\n        // Cache all children elements for quicker access.\n        var cache = this._V; // vectorized markup;\n        for (var i = 0, n = children.length; i < n; i++) {\n            var child = children[i];\n            var className = child.attr('class');\n            if (className) {\n                // Strip the joint class name prefix, if there is one.\n                className = removeClassNamePrefix(className);\n                cache[$.camelCase(className)] = child;\n            }\n        }\n        // partial rendering\n        this.renderTools();\n        this.renderVertexMarkers();\n        this.renderArrowheadMarkers();\n        this.vel.append(children);\n    },\n\n    _getLabelMarkup: function(labelMarkup) {\n\n        if (!labelMarkup) return undefined;\n\n        if (Array.isArray(labelMarkup)) return this.parseDOMJSON(labelMarkup, null);\n        if (typeof labelMarkup === 'string') return this._getLabelStringMarkup(labelMarkup);\n        throw new Error('dia.linkView: invalid label markup');\n    },\n\n    _getLabelStringMarkup: function(labelMarkup) {\n\n        var children = V(labelMarkup);\n        var fragment = document.createDocumentFragment();\n\n        if (!Array.isArray(children)) {\n            fragment.appendChild(children.node);\n\n        } else {\n            for (var i = 0, n = children.length; i < n; i++) {\n                var currentChild = children[i].node;\n                fragment.appendChild(currentChild);\n            }\n        }\n\n        return { fragment: fragment, selectors: {}}; // no selectors\n    },\n\n    // Label markup fragment may come wrapped in <g class=\"label\" />, or not.\n    // If it doesn't, add the <g /> container here.\n    _normalizeLabelMarkup: function(markup) {\n\n        if (!markup) return undefined;\n\n        var fragment = markup.fragment;\n        if (!(markup.fragment instanceof DocumentFragment) || !markup.fragment.hasChildNodes()) throw new Error('dia.LinkView: invalid label markup.');\n\n        var vNode;\n        var childNodes = fragment.childNodes;\n\n        if ((childNodes.length > 1) || childNodes[0].nodeName.toUpperCase() !== 'G') {\n            // default markup fragment is not wrapped in <g />\n            // add a <g /> container\n            vNode = V('g').append(fragment);\n        } else {\n            vNode = V(childNodes[0]);\n        }\n\n        vNode.addClass('label');\n\n        return { node: vNode.node, selectors: markup.selectors };\n    },\n\n    renderLabels: function() {\n\n        var cache = this._V;\n        var vLabels = cache.labels;\n        var labelCache = this._labelCache = {};\n        var labelSelectors = this._labelSelectors = {};\n        var model = this.model;\n        var labels = model.attributes.labels || [];\n        var labelsCount = labels.length;\n\n        if (labelsCount === 0) {\n            if (vLabels) vLabels.remove();\n            return this;\n        }\n\n        if (vLabels) {\n            vLabels.empty();\n        }  else {\n            // there is no label container in the markup but some labels are defined\n            // add a <g class=\"labels\" /> container\n            vLabels = cache.labels = V('g').addClass('labels');\n            if (this.options.labelsLayer) {\n                vLabels.addClass(addClassNamePrefix(result(this, 'className')));\n                vLabels.attr('model-id', model.id);\n            }\n        }\n\n        for (var i = 0; i < labelsCount; i++) {\n\n            var label = labels[i];\n            var labelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(label.markup));\n            var labelNode;\n            var selectors;\n            if (labelMarkup) {\n\n                labelNode = labelMarkup.node;\n                selectors = labelMarkup.selectors;\n\n            } else {\n\n                var builtinDefaultLabel =  model._builtins.defaultLabel;\n                var builtinDefaultLabelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(builtinDefaultLabel.markup));\n                var defaultLabel = model._getDefaultLabel();\n                var defaultLabelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(defaultLabel.markup));\n                var defaultMarkup = defaultLabelMarkup || builtinDefaultLabelMarkup;\n\n                labelNode = defaultMarkup.node;\n                selectors = defaultMarkup.selectors;\n            }\n\n            labelNode.setAttribute('label-idx', i); // assign label-idx\n            vLabels.append(labelNode);\n            labelCache[i] = labelNode; // cache node for `updateLabels()` so it can just update label node positions\n\n            var rootSelector = this.selector;\n            if (selectors[rootSelector]) throw new Error('dia.LinkView: ambiguous label root selector.');\n            selectors[rootSelector] = labelNode;\n\n            labelSelectors[i] = selectors; // cache label selectors for `updateLabels()`\n        }\n        if (!vLabels.parent()) {\n            this.mountLabels();\n        }\n\n        this.updateLabels();\n\n        return this;\n    },\n\n    mountLabels: function() {\n        const { el, paper, model, _V, options } = this;\n        const { labels: vLabels } = _V;\n        if (!vLabels || !model.hasLabels()) return;\n        const { node } = vLabels;\n        if (options.labelsLayer) {\n            paper.getLayerView(options.labelsLayer).insertSortedNode(node, model.get('z'));\n        } else {\n            if (node.parentNode !== el) {\n                el.appendChild(node);\n            }\n        }\n    },\n\n    unmountLabels: function() {\n        const { options, _V } = this;\n        if (!_V) return;\n        const { labels: vLabels } = _V;\n        if (vLabels && options.labelsLayer) {\n            vLabels.remove();\n        }\n    },\n\n    onMount: function() {\n        this.mountLabels();\n    },\n\n    unmount: function() {\n        CellView.prototype.unmount.apply(this, arguments);\n        this.unmountLabels();\n    },\n\n    findLabelNode: function(labelIndex, selector) {\n        const labelRoot = this._labelCache[labelIndex];\n        if (!labelRoot) return null;\n        const labelSelectors = this._labelSelectors[labelIndex];\n        const [node = null] = this.findBySelector(selector, labelRoot, labelSelectors);\n        return node;\n    },\n\n\n    // merge default label attrs into label attrs\n    // keep `undefined` or `null` because `{}` means something else\n    _mergeLabelAttrs: function(hasCustomMarkup, labelAttrs, defaultLabelAttrs, builtinDefaultLabelAttrs) {\n\n        if (labelAttrs === null) return null;\n        if (labelAttrs === undefined) {\n\n            if (defaultLabelAttrs === null) return null;\n            if (defaultLabelAttrs === undefined) {\n\n                if (hasCustomMarkup) return undefined;\n                return builtinDefaultLabelAttrs;\n            }\n\n            if (hasCustomMarkup) return defaultLabelAttrs;\n            return merge({}, builtinDefaultLabelAttrs, defaultLabelAttrs);\n        }\n\n        if (hasCustomMarkup) return merge({}, defaultLabelAttrs, labelAttrs);\n        return merge({}, builtinDefaultLabelAttrs, defaultLabelAttrs, labelAttrs);\n    },\n\n    updateLabels: function() {\n\n        if (!this._V.labels) return this;\n\n        var model = this.model;\n        var labels = model.get('labels') || [];\n        var canLabelMove = this.can('labelMove');\n\n        var builtinDefaultLabel = model._builtins.defaultLabel;\n        var builtinDefaultLabelAttrs = builtinDefaultLabel.attrs;\n\n        var defaultLabel = model._getDefaultLabel();\n        var defaultLabelMarkup = defaultLabel.markup;\n        var defaultLabelAttrs = defaultLabel.attrs;\n\n        for (var i = 0, n = labels.length; i < n; i++) {\n\n            var labelNode = this._labelCache[i];\n            labelNode.setAttribute('cursor', (canLabelMove ? 'move' : 'default'));\n\n            var selectors = this._labelSelectors[i];\n\n            var label = labels[i];\n            var labelMarkup = label.markup;\n            var labelAttrs = label.attrs;\n\n            var attrs = this._mergeLabelAttrs(\n                (labelMarkup || defaultLabelMarkup),\n                labelAttrs,\n                defaultLabelAttrs,\n                builtinDefaultLabelAttrs\n            );\n\n            this.updateDOMSubtreeAttributes(labelNode, attrs, {\n                rootBBox: new Rect(label.size),\n                selectors: selectors\n            });\n        }\n\n        return this;\n    },\n\n    renderTools: function() {\n\n        if (!this._V.linkTools) return this;\n\n        // Tools are a group of clickable elements that manipulate the whole link.\n        // A good example of this is the remove tool that removes the whole link.\n        // Tools appear after hovering the link close to the `source` element/point of the link\n        // but are offset a bit so that they don't cover the `marker-arrowhead`.\n\n        var $tools = $(this._V.linkTools.node).empty();\n        var toolTemplate = template(this.model.get('toolMarkup') || this.model.toolMarkup);\n        var tool = V(toolTemplate());\n\n        $tools.append(tool.node);\n\n        // Cache the tool node so that the `updateToolsPosition()` can update the tool position quickly.\n        this._toolCache = tool;\n\n        // If `doubleLinkTools` is enabled, we render copy of the tools on the other side of the\n        // link as well but only if the link is longer than `longLinkLength`.\n        if (this.options.doubleLinkTools) {\n\n            var tool2;\n            if (this.model.get('doubleToolMarkup') || this.model.doubleToolMarkup) {\n                toolTemplate = template(this.model.get('doubleToolMarkup') || this.model.doubleToolMarkup);\n                tool2 = V(toolTemplate());\n            } else {\n                tool2 = tool.clone();\n            }\n\n            $tools.append(tool2.node);\n            this._tool2Cache = tool2;\n        }\n\n        return this;\n    },\n\n    renderVertexMarkers: function() {\n\n        if (!this._V.markerVertices) return this;\n\n        var $markerVertices = $(this._V.markerVertices.node).empty();\n\n        // A special markup can be given in the `properties.vertexMarkup` property. This might be handy\n        // if default styling (elements) are not desired. This makes it possible to use any\n        // SVG elements for .marker-vertex and .marker-vertex-remove tools.\n        var markupTemplate = template(this.model.get('vertexMarkup') || this.model.vertexMarkup);\n\n        this.model.vertices().forEach(function(vertex, idx) {\n            $markerVertices.append(V(markupTemplate(assign({ idx: idx }, vertex))).node);\n        });\n\n        return this;\n    },\n\n    renderArrowheadMarkers: function() {\n\n        // Custom markups might not have arrowhead markers. Therefore, jump of this function immediately if that's the case.\n        if (!this._V.markerArrowheads) return this;\n\n        var $markerArrowheads = $(this._V.markerArrowheads.node);\n\n        $markerArrowheads.empty();\n\n        // A special markup can be given in the `properties.vertexMarkup` property. This might be handy\n        // if default styling (elements) are not desired. This makes it possible to use any\n        // SVG elements for .marker-vertex and .marker-vertex-remove tools.\n        var markupTemplate = template(this.model.get('arrowheadMarkup') || this.model.arrowheadMarkup);\n\n        this._V.sourceArrowhead = V(markupTemplate({ end: 'source' }));\n        this._V.targetArrowhead = V(markupTemplate({ end: 'target' }));\n\n        $markerArrowheads.append(this._V.sourceArrowhead.node, this._V.targetArrowhead.node);\n\n        return this;\n    },\n\n    // remove vertices that lie on (or nearly on) straight lines within the link\n    // return the number of removed points\n    removeRedundantLinearVertices: function(opt) {\n\n        const SIMPLIFY_THRESHOLD = 0.001;\n\n        const link = this.model;\n        const vertices = link.vertices();\n        const routePoints = [this.sourceAnchor, ...vertices, this.targetAnchor];\n        const numRoutePoints = routePoints.length;\n\n        // put routePoints into a polyline and try to simplify\n        const polyline = new Polyline(routePoints);\n        polyline.simplify({ threshold: SIMPLIFY_THRESHOLD });\n        const polylinePoints = polyline.points.map((point) => (point.toJSON())); // JSON of points after simplification\n        const numPolylinePoints = polylinePoints.length; // number of points after simplification\n\n        // shortcut if simplification did not remove any redundant vertices:\n        if (numRoutePoints === numPolylinePoints) return 0;\n\n        // else: set simplified polyline points as link vertices\n        // remove first and last polyline points again (= source/target anchors)\n        link.vertices(polylinePoints.slice(1, numPolylinePoints - 1), opt);\n        return (numRoutePoints - numPolylinePoints);\n    },\n\n    updateDefaultConnectionPath: function() {\n\n        var cache = this._V;\n\n        if (cache.connection) {\n            cache.connection.attr('d', this.getSerializedConnection());\n        }\n\n        if (cache.connectionWrap) {\n            cache.connectionWrap.attr('d', this.getSerializedConnection());\n        }\n\n        if (cache.markerSource && cache.markerTarget) {\n            this._translateAndAutoOrientArrows(cache.markerSource, cache.markerTarget);\n        }\n    },\n\n    getEndView: function(type) {\n        switch (type) {\n            case 'source':\n                return this.sourceView || null;\n            case 'target':\n                return this.targetView || null;\n            default:\n                throw new Error('dia.LinkView: type parameter required.');\n        }\n    },\n\n    getEndAnchor: function(type) {\n        switch (type) {\n            case 'source':\n                return new Point(this.sourceAnchor);\n            case 'target':\n                return new Point(this.targetAnchor);\n            default:\n                throw new Error('dia.LinkView: type parameter required.');\n        }\n    },\n\n    getEndConnectionPoint: function(type) {\n        switch (type) {\n            case 'source':\n                return new Point(this.sourcePoint);\n            case 'target':\n                return new Point(this.targetPoint);\n            default:\n                throw new Error('dia.LinkView: type parameter required.');\n        }\n    },\n\n    getEndMagnet: function(type) {\n        switch (type) {\n            case 'source':\n                var sourceView = this.sourceView;\n                if (!sourceView) break;\n                return this.sourceMagnet || sourceView.el;\n            case 'target':\n                var targetView = this.targetView;\n                if (!targetView) break;\n                return this.targetMagnet || targetView.el;\n            default:\n                throw new Error('dia.LinkView: type parameter required.');\n        }\n        return null;\n    },\n\n\n    // Updating.\n    // ---------\n\n    update: function() {\n        this.updateRoute();\n        this.updatePath();\n        this.updateDOM();\n        return this;\n    },\n\n    translate: function(tx = 0, ty = 0) {\n        const { route, path } = this;\n        if (!route || !path) return;\n        // translate the route\n        const polyline = new Polyline(route);\n        polyline.translate(tx, ty);\n        this.route = polyline.points;\n        // translate source and target connection and marker points.\n        this._translateConnectionPoints(tx, ty);\n        // translate the geometry path\n        path.translate(tx, ty);\n        this.updateDOM();\n    },\n\n    updateDOM() {\n        const { el, model, selectors } = this;\n        this.cleanNodesCache();\n        // update SVG attributes defined by 'attrs/'.\n        this.updateDOMSubtreeAttributes(el, model.attr(), { selectors });\n        // legacy link path update\n        this.updateDefaultConnectionPath();\n        // update the label position etc.\n        this.updateLabelPositions();\n        this.updateToolsPosition();\n        this.updateArrowheadMarkers();\n        // *Deprecated*\n        // Local perpendicular flag (as opposed to one defined on paper).\n        // Could be enabled inside a connector/router. It's valid only\n        // during the update execution.\n        this.options.perpendicular = null;\n    },\n\n    updateRoute: function() {\n        const { model } = this;\n        const vertices = model.vertices();\n        // 1. Find Anchors\n        const anchors = this.findAnchors(vertices);\n        const sourceAnchor = this.sourceAnchor = anchors.source;\n        const targetAnchor = this.targetAnchor = anchors.target;\n        // 2. Find Route\n        const route = this.findRoute(vertices);\n        this.route = route;\n        // 3. Find Connection Points\n        var connectionPoints = this.findConnectionPoints(route, sourceAnchor, targetAnchor);\n        this.sourcePoint = connectionPoints.source;\n        this.targetPoint = connectionPoints.target;\n    },\n\n    updatePath: function() {\n        const { route, sourcePoint, targetPoint } = this;\n        // 3b. Find Marker Connection Point - Backwards Compatibility\n        const markerPoints = this.findMarkerPoints(route, sourcePoint, targetPoint);\n        // 4. Find Connection\n        const path = this.findPath(route, markerPoints.source || sourcePoint, markerPoints.target || targetPoint);\n        this.path = path;\n    },\n\n    findMarkerPoints: function(route, sourcePoint, targetPoint) {\n\n        var firstWaypoint = route[0];\n        var lastWaypoint = route[route.length - 1];\n\n        // Move the source point by the width of the marker taking into account\n        // its scale around x-axis. Note that scale is the only transform that\n        // makes sense to be set in `.marker-source` attributes object\n        // as all other transforms (translate/rotate) will be replaced\n        // by the `translateAndAutoOrient()` function.\n        var cache = this._markerCache;\n        // cache source and target points\n        var sourceMarkerPoint, targetMarkerPoint;\n\n        if (this._V.markerSource) {\n\n            cache.sourceBBox = cache.sourceBBox || this._V.markerSource.getBBox();\n            sourceMarkerPoint = Point(sourcePoint).move(\n                firstWaypoint || targetPoint,\n                cache.sourceBBox.width * this._V.markerSource.scale().sx * -1\n            ).round();\n        }\n\n        if (this._V.markerTarget) {\n\n            cache.targetBBox = cache.targetBBox || this._V.markerTarget.getBBox();\n            targetMarkerPoint = Point(targetPoint).move(\n                lastWaypoint || sourcePoint,\n                cache.targetBBox.width * this._V.markerTarget.scale().sx * -1\n            ).round();\n        }\n\n        // if there was no markup for the marker, use the connection point.\n        cache.sourcePoint = sourceMarkerPoint || sourcePoint.clone();\n        cache.targetPoint = targetMarkerPoint || targetPoint.clone();\n\n        return {\n            source: sourceMarkerPoint,\n            target: targetMarkerPoint\n        };\n    },\n\n    findAnchorsOrdered: function(firstEndType, firstRef, secondEndType, secondRef) {\n\n        var firstAnchor, secondAnchor;\n        var firstAnchorRef, secondAnchorRef;\n        var model = this.model;\n        var firstDef = model.get(firstEndType);\n        var secondDef = model.get(secondEndType);\n        var firstView = this.getEndView(firstEndType);\n        var secondView = this.getEndView(secondEndType);\n        var firstMagnet = this.getEndMagnet(firstEndType);\n        var secondMagnet = this.getEndMagnet(secondEndType);\n\n        // Anchor first\n        if (firstView) {\n            if (firstRef) {\n                firstAnchorRef = new Point(firstRef);\n            } else if (secondView) {\n                firstAnchorRef = secondMagnet;\n            } else {\n                firstAnchorRef = new Point(secondDef);\n            }\n            firstAnchor = this.getAnchor(firstDef.anchor, firstView, firstMagnet, firstAnchorRef, firstEndType);\n        } else {\n            firstAnchor = new Point(firstDef);\n        }\n\n        // Anchor second\n        if (secondView) {\n            secondAnchorRef = new Point(secondRef || firstAnchor);\n            secondAnchor = this.getAnchor(secondDef.anchor, secondView, secondMagnet, secondAnchorRef, secondEndType);\n        } else {\n            secondAnchor = new Point(secondDef);\n        }\n\n        var res = {};\n        res[firstEndType] = firstAnchor;\n        res[secondEndType] = secondAnchor;\n        return res;\n    },\n\n    findAnchors: function(vertices) {\n\n        var model = this.model;\n        var firstVertex = vertices[0];\n        var lastVertex = vertices[vertices.length - 1];\n\n        if (model.target().priority && !model.source().priority) {\n            // Reversed order\n            return this.findAnchorsOrdered('target', lastVertex, 'source', firstVertex);\n        }\n\n        // Usual order\n        return this.findAnchorsOrdered('source', firstVertex, 'target', lastVertex);\n    },\n\n    findConnectionPoints: function(route, sourceAnchor, targetAnchor) {\n\n        var firstWaypoint = route[0];\n        var lastWaypoint = route[route.length - 1];\n        var model = this.model;\n        var sourceDef = model.get('source');\n        var targetDef = model.get('target');\n        var sourceView = this.sourceView;\n        var targetView = this.targetView;\n        var paperOptions = this.paper.options;\n        var sourceMagnet, targetMagnet;\n\n        // Connection Point Source\n        var sourcePoint;\n        if (sourceView && !sourceView.isNodeConnection(this.sourceMagnet)) {\n            sourceMagnet = (this.sourceMagnet || sourceView.el);\n            var sourceConnectionPointDef = sourceDef.connectionPoint || paperOptions.defaultConnectionPoint;\n            var sourcePointRef = firstWaypoint || targetAnchor;\n            var sourceLine = new Line(sourcePointRef, sourceAnchor);\n            sourcePoint = this.getConnectionPoint(\n                sourceConnectionPointDef,\n                sourceView,\n                sourceMagnet,\n                sourceLine,\n                'source'\n            );\n        } else {\n            sourcePoint = sourceAnchor;\n        }\n        // Connection Point Target\n        var targetPoint;\n        if (targetView && !targetView.isNodeConnection(this.targetMagnet)) {\n            targetMagnet = (this.targetMagnet || targetView.el);\n            var targetConnectionPointDef = targetDef.connectionPoint || paperOptions.defaultConnectionPoint;\n            var targetPointRef = lastWaypoint || sourceAnchor;\n            var targetLine = new Line(targetPointRef, targetAnchor);\n            targetPoint = this.getConnectionPoint(\n                targetConnectionPointDef,\n                targetView,\n                targetMagnet,\n                targetLine,\n                'target'\n            );\n        } else {\n            targetPoint = targetAnchor;\n        }\n\n        return {\n            source: sourcePoint,\n            target: targetPoint\n        };\n    },\n\n    getAnchor: function(anchorDef, cellView, magnet, ref, endType) {\n\n        var isConnection = cellView.isNodeConnection(magnet);\n        var paperOptions = this.paper.options;\n        if (!anchorDef) {\n            if (isConnection) {\n                anchorDef = paperOptions.defaultLinkAnchor;\n            } else {\n                if (paperOptions.perpendicularLinks || this.options.perpendicular) {\n                    // Backwards compatibility\n                    // If `perpendicularLinks` flag is set on the paper and there are vertices\n                    // on the link, then try to find a connection point that makes the link perpendicular\n                    // even though the link won't point to the center of the targeted object.\n                    anchorDef = { name: 'perpendicular' };\n                } else {\n                    anchorDef = paperOptions.defaultAnchor;\n                }\n            }\n        }\n\n        if (!anchorDef) throw new Error('Anchor required.');\n        var anchorFn;\n        if (typeof anchorDef === 'function') {\n            anchorFn = anchorDef;\n        } else {\n            var anchorName = anchorDef.name;\n            var anchorNamespace = isConnection ? 'linkAnchorNamespace' : 'anchorNamespace';\n            anchorFn = paperOptions[anchorNamespace][anchorName];\n            if (typeof anchorFn !== 'function') throw new Error('Unknown anchor: ' + anchorName);\n        }\n        var anchor = anchorFn.call(\n            this,\n            cellView,\n            magnet,\n            ref,\n            anchorDef.args || {},\n            endType,\n            this\n        );\n        if (!anchor) return new Point();\n        return anchor.round(this.decimalsRounding);\n    },\n\n\n    getConnectionPoint: function(connectionPointDef, view, magnet, line, endType) {\n\n        var connectionPoint;\n        var anchor = line.end;\n        var paperOptions = this.paper.options;\n\n        // Backwards compatibility\n        if (typeof paperOptions.linkConnectionPoint === 'function') {\n            var linkConnectionMagnet = (magnet === view.el) ? undefined : magnet;\n            connectionPoint = paperOptions.linkConnectionPoint(this, view, linkConnectionMagnet, line.start, endType);\n            if (connectionPoint) return connectionPoint;\n        }\n\n        if (!connectionPointDef) return anchor;\n        var connectionPointFn;\n        if (typeof connectionPointDef === 'function') {\n            connectionPointFn = connectionPointDef;\n        } else {\n            var connectionPointName = connectionPointDef.name;\n            connectionPointFn = paperOptions.connectionPointNamespace[connectionPointName];\n            if (typeof connectionPointFn !== 'function') throw new Error('Unknown connection point: ' + connectionPointName);\n        }\n        connectionPoint = connectionPointFn.call(this, line, view, magnet, connectionPointDef.args || {}, endType, this);\n        if (!connectionPoint) return anchor;\n        return connectionPoint.round(this.decimalsRounding);\n    },\n\n    _translateConnectionPoints: function(tx, ty) {\n\n        var cache = this._markerCache;\n\n        cache.sourcePoint.offset(tx, ty);\n        cache.targetPoint.offset(tx, ty);\n        this.sourcePoint.offset(tx, ty);\n        this.targetPoint.offset(tx, ty);\n        this.sourceAnchor.offset(tx, ty);\n        this.targetAnchor.offset(tx, ty);\n    },\n\n    // if label position is a number, normalize it to a position object\n    // this makes sure that label positions can be merged properly\n    _normalizeLabelPosition: function(labelPosition) {\n\n        if (typeof labelPosition === 'number') return { distance: labelPosition, offset: null, angle: 0, args: null };\n        return labelPosition;\n    },\n\n    updateLabelPositions: function() {\n\n        if (!this._V.labels) return this;\n\n        var path = this.path;\n        if (!path) return this;\n\n        // This method assumes all the label nodes are stored in the `this._labelCache` hash table\n        // by their indices in the `this.get('labels')` array. This is done in the `renderLabels()` method.\n\n        var model = this.model;\n        var labels = model.get('labels') || [];\n        if (!labels.length) return this;\n\n        var builtinDefaultLabel = model._builtins.defaultLabel;\n        var builtinDefaultLabelPosition = builtinDefaultLabel.position;\n\n        var defaultLabel = model._getDefaultLabel();\n        var defaultLabelPosition = this._normalizeLabelPosition(defaultLabel.position);\n\n        var defaultPosition = merge({}, builtinDefaultLabelPosition, defaultLabelPosition);\n\n        for (var idx = 0, n = labels.length; idx < n; idx++) {\n            var labelNode = this._labelCache[idx];\n            if (!labelNode) continue;\n            var label = labels[idx];\n            var labelPosition = this._normalizeLabelPosition(label.position);\n            var position = merge({}, defaultPosition, labelPosition);\n            var transformationMatrix = this._getLabelTransformationMatrix(position);\n            labelNode.setAttribute('transform', V.matrixToTransformString(transformationMatrix));\n            this._cleanLabelMatrices(idx);\n        }\n\n        return this;\n    },\n\n    _cleanLabelMatrices: function(index) {\n        // Clean magnetMatrix for all nodes of the label.\n        // Cached BoundingRect does not need to updated when the position changes\n        // TODO: this doesn't work for labels with XML String markups.\n        const { metrics, _labelSelectors } = this;\n        const selectors = _labelSelectors[index];\n        if (!selectors) return;\n        for (let selector in selectors) {\n            const { id } = selectors[selector];\n            if (id && (id in metrics)) delete metrics[id].magnetMatrix;\n        }\n    },\n\n    updateToolsPosition: function() {\n\n        if (!this._V.linkTools) return this;\n\n        // Move the tools a bit to the target position but don't cover the `sourceArrowhead` marker.\n        // Note that the offset is hardcoded here. The offset should be always\n        // more than the `this.$('.marker-arrowhead[end=\"source\"]')[0].bbox().width` but looking\n        // this up all the time would be slow.\n\n        var scale = '';\n        var offset = this.options.linkToolsOffset;\n        var connectionLength = this.getConnectionLength();\n\n        // Firefox returns connectionLength=NaN in odd cases (for bezier curves).\n        // In that case we won't update tools position at all.\n        if (!Number.isNaN(connectionLength)) {\n\n            // If the link is too short, make the tools half the size and the offset twice as low.\n            if (connectionLength < this.options.shortLinkLength) {\n                scale = 'scale(.5)';\n                offset /= 2;\n            }\n\n            var toolPosition = this.getPointAtLength(offset);\n\n            this._toolCache.attr('transform', 'translate(' + toolPosition.x + ', ' + toolPosition.y + ') ' + scale);\n\n            if (this.options.doubleLinkTools && connectionLength >= this.options.longLinkLength) {\n\n                var doubleLinkToolsOffset = this.options.doubleLinkToolsOffset || offset;\n\n                toolPosition = this.getPointAtLength(connectionLength - doubleLinkToolsOffset);\n                this._tool2Cache.attr('transform', 'translate(' + toolPosition.x + ', ' + toolPosition.y + ') ' + scale);\n                this._tool2Cache.attr('visibility', 'visible');\n\n            } else if (this.options.doubleLinkTools) {\n\n                this._tool2Cache.attr('visibility', 'hidden');\n            }\n        }\n\n        return this;\n    },\n\n    updateArrowheadMarkers: function() {\n\n        if (!this._V.markerArrowheads) return this;\n\n        // getting bbox of an element with `display=\"none\"` in IE9 ends up with access violation\n        if ($.css(this._V.markerArrowheads.node, 'display') === 'none') return this;\n\n        var sx = this.getConnectionLength() < this.options.shortLinkLength ? .5 : 1;\n        this._V.sourceArrowhead.scale(sx);\n        this._V.targetArrowhead.scale(sx);\n\n        this._translateAndAutoOrientArrows(this._V.sourceArrowhead, this._V.targetArrowhead);\n\n        return this;\n    },\n\n    updateEndProperties: function(endType) {\n\n        const { model, paper } = this;\n        const endViewProperty = `${endType}View`;\n        const endDef = model.get(endType);\n        const endId = endDef && endDef.id;\n\n        if (!endId) {\n            // the link end is a point ~ rect 0x0\n            this[endViewProperty] = null;\n            this.updateEndMagnet(endType);\n            return true;\n        }\n\n        const endModel = paper.getModelById(endId);\n        if (!endModel) throw new Error('LinkView: invalid ' + endType + ' cell.');\n\n        const endView = endModel.findView(paper);\n        if (!endView) {\n            // A view for a model should always exist\n            return false;\n        }\n\n        this[endViewProperty] = endView;\n        this.updateEndMagnet(endType);\n        return true;\n    },\n\n    updateEndMagnet: function(endType) {\n\n        const endMagnetProperty = `${endType}Magnet`;\n        const endView = this.getEndView(endType);\n        if (endView) {\n            let connectedMagnet = endView.getMagnetFromLinkEnd(this.model.get(endType));\n            if (connectedMagnet === endView.el) connectedMagnet = null;\n            this[endMagnetProperty] = connectedMagnet;\n        } else {\n            this[endMagnetProperty] = null;\n        }\n    },\n\n    _translateAndAutoOrientArrows: function(sourceArrow, targetArrow) {\n\n        // Make the markers \"point\" to their sticky points being auto-oriented towards\n        // `targetPosition`/`sourcePosition`. And do so only if there is a markup for them.\n        var route = toArray(this.route);\n        if (sourceArrow) {\n            sourceArrow.translateAndAutoOrient(\n                this.sourcePoint,\n                route[0] || this.targetPoint,\n                this.paper.cells\n            );\n        }\n\n        if (targetArrow) {\n            targetArrow.translateAndAutoOrient(\n                this.targetPoint,\n                route[route.length - 1] || this.sourcePoint,\n                this.paper.cells\n            );\n        }\n    },\n\n    _getLabelPositionAngle: function(idx) {\n\n        var labelPosition = this.model.label(idx).position || {};\n        return (labelPosition.angle || 0);\n    },\n\n    _getLabelPositionArgs: function(idx) {\n\n        var labelPosition = this.model.label(idx).position || {};\n        return labelPosition.args;\n    },\n\n    _getDefaultLabelPositionArgs: function() {\n\n        var defaultLabel = this.model._getDefaultLabel();\n        var defaultLabelPosition = defaultLabel.position || {};\n        return defaultLabelPosition.args;\n    },\n\n    // merge default label position args into label position args\n    // keep `undefined` or `null` because `{}` means something else\n    _mergeLabelPositionArgs: function(labelPositionArgs, defaultLabelPositionArgs) {\n\n        if (labelPositionArgs === null) return null;\n        if (labelPositionArgs === undefined) {\n\n            if (defaultLabelPositionArgs === null) return null;\n            return defaultLabelPositionArgs;\n        }\n\n        return merge({}, defaultLabelPositionArgs, labelPositionArgs);\n    },\n\n    // Add default label at given position at end of `labels` array.\n    // Four signatures:\n    // - obj, obj = point, opt\n    // - obj, num, obj = point, angle, opt\n    // - num, num, obj = x, y, opt\n    // - num, num, num, obj = x, y, angle, opt\n    // Assigns relative coordinates by default:\n    // `opt.absoluteDistance` forces absolute coordinates.\n    // `opt.reverseDistance` forces reverse absolute coordinates (if absoluteDistance = true).\n    // `opt.absoluteOffset` forces absolute coordinates for offset.\n    // Additional args:\n    // `opt.keepGradient` auto-adjusts the angle of the label to match path gradient at position.\n    // `opt.ensureLegibility` rotates labels so they are never upside-down.\n    addLabel: function(p1, p2, p3, p4) {\n\n        // normalize data from the four possible signatures\n        var localX;\n        var localY;\n        var localAngle = 0;\n        var localOpt;\n        if (typeof p1 !== 'number') {\n            // {x, y} object provided as first parameter\n            localX = p1.x;\n            localY = p1.y;\n            if (typeof p2 === 'number') {\n                // angle and opt provided as second and third parameters\n                localAngle = p2;\n                localOpt = p3;\n            } else {\n                // opt provided as second parameter\n                localOpt = p2;\n            }\n        } else {\n            // x and y provided as first and second parameters\n            localX = p1;\n            localY = p2;\n            if (typeof p3 === 'number') {\n                // angle and opt provided as third and fourth parameters\n                localAngle = p3;\n                localOpt = p4;\n            } else {\n                // opt provided as third parameter\n                localOpt = p3;\n            }\n        }\n\n        // merge label position arguments\n        var defaultLabelPositionArgs = this._getDefaultLabelPositionArgs();\n        var labelPositionArgs = localOpt;\n        var positionArgs = this._mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);\n\n        // append label to labels array\n        var label = { position: this.getLabelPosition(localX, localY, localAngle, positionArgs) };\n        var idx = -1;\n        this.model.insertLabel(idx, label, localOpt);\n        return idx;\n    },\n\n    // Add a new vertex at calculated index to the `vertices` array.\n    addVertex: function(x, y, opt) {\n\n        // accept input in form `{ x, y }, opt` or `x, y, opt`\n        var isPointProvided = (typeof x !== 'number');\n        var localX = isPointProvided ? x.x : x;\n        var localY = isPointProvided ? x.y : y;\n        var localOpt = isPointProvided ? y : opt;\n\n        var vertex = { x: localX, y: localY };\n        var idx = this.getVertexIndex(localX, localY);\n        this.model.insertVertex(idx, vertex, localOpt);\n        return idx;\n    },\n\n    // Send a token (an SVG element, usually a circle) along the connection path.\n    // Example: `link.findView(paper).sendToken(V('circle', { r: 7, fill: 'green' }).node)`\n    // `opt.duration` is optional and is a time in milliseconds that the token travels from the source to the target of the link. Default is `1000`.\n    // `opt.directon` is optional and it determines whether the token goes from source to target or other way round (`reverse`)\n    // `opt.connection` is an optional selector to the connection path.\n    // `callback` is optional and is a function to be called once the token reaches the target.\n    sendToken: function(token, opt, callback) {\n\n        function onAnimationEnd(vToken, callback) {\n            return function() {\n                vToken.remove();\n                if (typeof callback === 'function') {\n                    callback();\n                }\n            };\n        }\n\n        var duration, isReversed, selector;\n        if (isObject(opt)) {\n            duration = opt.duration;\n            isReversed = (opt.direction === 'reverse');\n            selector = opt.connection;\n        } else {\n            // Backwards compatibility\n            duration = opt;\n            isReversed = false;\n            selector = null;\n        }\n\n        duration = duration || 1000;\n\n        var animationAttributes = {\n            dur: duration + 'ms',\n            repeatCount: 1,\n            calcMode: 'linear',\n            fill: 'freeze'\n        };\n\n        if (isReversed) {\n            animationAttributes.keyPoints = '1;0';\n            animationAttributes.keyTimes = '0;1';\n        }\n\n        var vToken = V(token);\n        var connection;\n        if (typeof selector === 'string') {\n            // Use custom connection path.\n            connection = this.findBySelector(selector, this.el, this.selectors)[0];\n        } else {\n            // Select connection path automatically.\n            var cache = this._V;\n            connection = (cache.connection) ? cache.connection.node : this.el.querySelector('path');\n        }\n\n        if (!(connection instanceof SVGPathElement)) {\n            throw new Error('dia.LinkView: token animation requires a valid connection path.');\n        }\n\n        vToken\n            .appendTo(this.paper.cells)\n            .animateAlongPath(animationAttributes, connection);\n\n        setTimeout(onAnimationEnd(vToken, callback), duration);\n    },\n\n    findRoute: function(vertices) {\n\n        vertices || (vertices = []);\n\n        var namespace = this.paper.options.routerNamespace || routers;\n        var router = this.model.router();\n        var defaultRouter = this.paper.options.defaultRouter;\n\n        if (!router) {\n            if (defaultRouter) router = defaultRouter;\n            else return vertices.map(Point); // no router specified\n        }\n\n        var routerFn = isFunction(router) ? router : namespace[router.name];\n        if (!isFunction(routerFn)) {\n            throw new Error('dia.LinkView: unknown router: \"' + router.name + '\".');\n        }\n\n        var args = router.args || {};\n\n        var route = routerFn.call(\n            this, // context\n            vertices, // vertices\n            args, // options\n            this // linkView\n        );\n\n        if (!route) return vertices.map(Point);\n        return route;\n    },\n\n    // Return the `d` attribute value of the `<path>` element representing the link\n    // between `source` and `target`.\n    findPath: function(route, sourcePoint, targetPoint) {\n\n        var namespace = this.paper.options.connectorNamespace || connectors;\n        var connector = this.model.connector();\n        var defaultConnector = this.paper.options.defaultConnector;\n\n        if (!connector) {\n            connector = defaultConnector || {};\n        }\n\n        var connectorFn = isFunction(connector) ? connector : namespace[connector.name];\n        if (!isFunction(connectorFn)) {\n            throw new Error('dia.LinkView: unknown connector: \"' + connector.name + '\".');\n        }\n\n        var args = clone(connector.args || {});\n        args.raw = true; // Request raw g.Path as the result.\n\n        var path = connectorFn.call(\n            this, // context\n            sourcePoint, // start point\n            targetPoint, // end point\n            route, // vertices\n            args, // options\n            this // linkView\n        );\n\n        if (typeof path === 'string') {\n            // Backwards compatibility for connectors not supporting `raw` option.\n            path = new Path(V.normalizePathData(path));\n        }\n\n        return path;\n    },\n\n    // Public API.\n    // -----------\n\n    getConnection: function() {\n\n        var path = this.path;\n        if (!path) return null;\n\n        return path.clone();\n    },\n\n    getSerializedConnection: function() {\n\n        var path = this.path;\n        if (!path) return null;\n\n        var metrics = this.metrics;\n        if (metrics.hasOwnProperty('data')) return metrics.data;\n        var data = path.serialize();\n        metrics.data = data;\n        return data;\n    },\n\n    getConnectionSubdivisions: function() {\n\n        var path = this.path;\n        if (!path) return null;\n\n        var metrics = this.metrics;\n        if (metrics.hasOwnProperty('segmentSubdivisions')) return metrics.segmentSubdivisions;\n        var subdivisions = path.getSegmentSubdivisions();\n        metrics.segmentSubdivisions = subdivisions;\n        return subdivisions;\n    },\n\n    getConnectionLength: function() {\n\n        var path = this.path;\n        if (!path) return 0;\n\n        var metrics = this.metrics;\n        if (metrics.hasOwnProperty('length')) return metrics.length;\n        var length = path.length({ segmentSubdivisions: this.getConnectionSubdivisions() });\n        metrics.length = length;\n        return length;\n    },\n\n    getPointAtLength: function(length) {\n\n        var path = this.path;\n        if (!path) return null;\n\n        return path.pointAtLength(length, { segmentSubdivisions: this.getConnectionSubdivisions() });\n    },\n\n    getPointAtRatio: function(ratio) {\n\n        var path = this.path;\n        if (!path) return null;\n        if (isPercentage(ratio)) ratio = parseFloat(ratio) / 100;\n        return path.pointAt(ratio, { segmentSubdivisions: this.getConnectionSubdivisions() });\n    },\n\n    getTangentAtLength: function(length) {\n\n        var path = this.path;\n        if (!path) return null;\n\n        return path.tangentAtLength(length, { segmentSubdivisions: this.getConnectionSubdivisions() });\n    },\n\n    getTangentAtRatio: function(ratio) {\n\n        var path = this.path;\n        if (!path) return null;\n\n        return path.tangentAt(ratio, { segmentSubdivisions: this.getConnectionSubdivisions() });\n    },\n\n    getClosestPoint: function(point) {\n\n        var path = this.path;\n        if (!path) return null;\n\n        return path.closestPoint(point, { segmentSubdivisions: this.getConnectionSubdivisions() });\n    },\n\n    getClosestPointLength: function(point) {\n\n        var path = this.path;\n        if (!path) return null;\n\n        return path.closestPointLength(point, { segmentSubdivisions: this.getConnectionSubdivisions() });\n    },\n\n    getClosestPointRatio: function(point) {\n\n        var path = this.path;\n        if (!path) return null;\n\n        return path.closestPointNormalizedLength(point, { segmentSubdivisions: this.getConnectionSubdivisions() });\n    },\n\n    // Get label position object based on two provided coordinates, x and y.\n    // (Used behind the scenes when user moves labels around.)\n    // Two signatures:\n    // - num, num, obj = x, y, options\n    // - num, num, num, obj = x, y, angle, options\n    // Accepts distance/offset options = `absoluteDistance: boolean`, `reverseDistance: boolean`, `absoluteOffset: boolean`\n    // - `absoluteOffset` is necessary in order to move beyond connection endpoints\n    // Additional options = `keepGradient: boolean`, `ensureLegibility: boolean`\n    getLabelPosition: function(x, y, p3, p4) {\n\n        var position = {};\n\n        // normalize data from the two possible signatures\n        var localAngle = 0;\n        var localOpt;\n        if (typeof p3 === 'number') {\n            // angle and opt provided as third and fourth argument\n            localAngle = p3;\n            localOpt = p4;\n        } else {\n            // opt provided as third argument\n            localOpt = p3;\n        }\n\n        // save localOpt as `args` of the position object that is passed along\n        if (localOpt) position.args = localOpt;\n\n        // identify distance/offset settings\n        var isDistanceRelative = !(localOpt && localOpt.absoluteDistance); // relative by default\n        var isDistanceAbsoluteReverse = (localOpt && localOpt.absoluteDistance && localOpt.reverseDistance); // non-reverse by default\n        var isOffsetAbsolute = localOpt && localOpt.absoluteOffset; // offset is non-absolute by default\n\n        // find closest point t\n        var path = this.path;\n        var pathOpt = { segmentSubdivisions: this.getConnectionSubdivisions() };\n        var labelPoint = new Point(x, y);\n        var t = path.closestPointT(labelPoint, pathOpt);\n\n        // DISTANCE:\n        var labelDistance = path.lengthAtT(t, pathOpt);\n        if (isDistanceRelative) labelDistance = (labelDistance / this.getConnectionLength()) || 0; // fix to prevent NaN for 0 length\n        if (isDistanceAbsoluteReverse) labelDistance = (-1 * (this.getConnectionLength() - labelDistance)) || 1; // fix for end point (-0 => 1)\n        position.distance = labelDistance;\n\n        // OFFSET:\n        // use absolute offset if:\n        // - opt.absoluteOffset is true,\n        // - opt.absoluteOffset is not true but there is no tangent\n        var tangent;\n        if (!isOffsetAbsolute) tangent = path.tangentAtT(t);\n        var labelOffset;\n        if (tangent) {\n            labelOffset = tangent.pointOffset(labelPoint);\n        } else {\n            var closestPoint = path.pointAtT(t);\n            var labelOffsetDiff = labelPoint.difference(closestPoint);\n            labelOffset = { x: labelOffsetDiff.x, y: labelOffsetDiff.y };\n        }\n        position.offset = labelOffset;\n\n        // ANGLE:\n        position.angle = localAngle;\n\n        return position;\n    },\n\n    _getLabelTransformationMatrix: function(labelPosition) {\n\n        var labelDistance;\n        var labelAngle = 0;\n        var args = {};\n        if (typeof labelPosition === 'number') {\n            labelDistance = labelPosition;\n        } else if (typeof labelPosition.distance === 'number') {\n            args = labelPosition.args || {};\n            labelDistance = labelPosition.distance;\n            labelAngle = labelPosition.angle || 0;\n        } else {\n            throw new Error('dia.LinkView: invalid label position distance.');\n        }\n\n        var isDistanceRelative = ((labelDistance > 0) && (labelDistance <= 1));\n\n        var labelOffset = 0;\n        var labelOffsetCoordinates = { x: 0, y: 0 };\n        if (labelPosition.offset) {\n            var positionOffset = labelPosition.offset;\n            if (typeof positionOffset === 'number') labelOffset = positionOffset;\n            if (positionOffset.x) labelOffsetCoordinates.x = positionOffset.x;\n            if (positionOffset.y) labelOffsetCoordinates.y = positionOffset.y;\n        }\n\n        var isOffsetAbsolute = ((labelOffsetCoordinates.x !== 0) || (labelOffsetCoordinates.y !== 0) || labelOffset === 0);\n\n        var isKeepGradient = args.keepGradient;\n        var isEnsureLegibility = args.ensureLegibility;\n\n        var path = this.path;\n        var pathOpt = { segmentSubdivisions: this.getConnectionSubdivisions() };\n\n        var distance = isDistanceRelative ? (labelDistance * this.getConnectionLength()) : labelDistance;\n        var tangent = path.tangentAtLength(distance, pathOpt);\n\n        var translation;\n        var angle = labelAngle;\n        if (tangent) {\n            if (isOffsetAbsolute) {\n                translation = tangent.start;\n                translation.offset(labelOffsetCoordinates);\n            } else {\n                var normal = tangent.clone();\n                normal.rotate(tangent.start, -90);\n                normal.setLength(labelOffset);\n                translation = normal.end;\n            }\n            if (isKeepGradient) {\n                angle = (tangent.angle() + labelAngle);\n                if (isEnsureLegibility) {\n                    angle = normalizeAngle(((angle + 90) % 180) - 90);\n                }\n            }\n        } else {\n            // fallback - the connection has zero length\n            translation = path.start;\n            if (isOffsetAbsolute) translation.offset(labelOffsetCoordinates);\n        }\n\n        return V.createSVGMatrix()\n            .translate(translation.x, translation.y)\n            .rotate(angle);\n    },\n\n    getLabelCoordinates: function(labelPosition) {\n\n        var transformationMatrix = this._getLabelTransformationMatrix(labelPosition);\n        return new Point(transformationMatrix.e, transformationMatrix.f);\n    },\n\n    getVertexIndex: function(x, y) {\n\n        var model = this.model;\n        var vertices = model.vertices();\n\n        var vertexLength = this.getClosestPointLength(new Point(x, y));\n\n        var idx = 0;\n        for (var n = vertices.length; idx < n; idx++) {\n            var currentVertex = vertices[idx];\n            var currentVertexLength = this.getClosestPointLength(currentVertex);\n            if (vertexLength < currentVertexLength) break;\n        }\n\n        return idx;\n    },\n\n    // Interaction. The controller part.\n    // ---------------------------------\n\n    notifyPointerdown(evt, x, y) {\n        CellView.prototype.pointerdown.call(this, evt, x, y);\n        this.notify('link:pointerdown', evt, x, y);\n    },\n\n    notifyPointermove(evt, x, y) {\n        CellView.prototype.pointermove.call(this, evt, x, y);\n        this.notify('link:pointermove', evt, x, y);\n    },\n\n    notifyPointerup(evt, x, y) {\n        this.notify('link:pointerup', evt, x, y);\n        CellView.prototype.pointerup.call(this, evt, x, y);\n    },\n\n    pointerdblclick: function(evt, x, y) {\n\n        CellView.prototype.pointerdblclick.apply(this, arguments);\n        this.notify('link:pointerdblclick', evt, x, y);\n    },\n\n    pointerclick: function(evt, x, y) {\n\n        CellView.prototype.pointerclick.apply(this, arguments);\n        this.notify('link:pointerclick', evt, x, y);\n    },\n\n    contextmenu: function(evt, x, y) {\n\n        CellView.prototype.contextmenu.apply(this, arguments);\n        this.notify('link:contextmenu', evt, x, y);\n    },\n\n    pointerdown: function(evt, x, y) {\n\n        this.notifyPointerdown(evt, x, y);\n\n        // Backwards compatibility for the default markup\n        var className = evt.target.getAttribute('class');\n        switch (className) {\n\n            case 'marker-vertex':\n                this.dragVertexStart(evt, x, y);\n                return;\n\n            case 'marker-vertex-remove':\n            case 'marker-vertex-remove-area':\n                this.dragVertexRemoveStart(evt, x, y);\n                return;\n\n            case 'marker-arrowhead':\n                this.dragArrowheadStart(evt, x, y);\n                return;\n\n            case 'connection':\n            case 'connection-wrap':\n                this.dragConnectionStart(evt, x, y);\n                return;\n\n            case 'marker-source':\n            case 'marker-target':\n                return;\n        }\n\n        this.dragStart(evt, x, y);\n    },\n\n    pointermove: function(evt, x, y) {\n\n        // Backwards compatibility\n        var dragData = this._dragData;\n        if (dragData) this.eventData(evt, dragData);\n\n        var data = this.eventData(evt);\n        switch (data.action) {\n\n            case 'vertex-move':\n                this.dragVertex(evt, x, y);\n                break;\n\n            case 'label-move':\n                this.dragLabel(evt, x, y);\n                break;\n\n            case 'arrowhead-move':\n                this.dragArrowhead(evt, x, y);\n                break;\n\n            case 'move':\n                this.drag(evt, x, y);\n                break;\n        }\n\n        // Backwards compatibility\n        if (dragData) assign(dragData, this.eventData(evt));\n\n        this.notifyPointermove(evt, x, y);\n    },\n\n    pointerup: function(evt, x, y) {\n\n        // Backwards compatibility\n        var dragData = this._dragData;\n        if (dragData) {\n            this.eventData(evt, dragData);\n            this._dragData = null;\n        }\n\n        var data = this.eventData(evt);\n        switch (data.action) {\n\n            case 'vertex-move':\n                this.dragVertexEnd(evt, x, y);\n                break;\n\n            case 'label-move':\n                this.dragLabelEnd(evt, x, y);\n                break;\n\n            case 'arrowhead-move':\n                this.dragArrowheadEnd(evt, x, y);\n                break;\n\n            case 'move':\n                this.dragEnd(evt, x, y);\n        }\n\n        this.notifyPointerup(evt, x, y);\n        this.checkMouseleave(evt);\n    },\n\n    mouseover: function(evt) {\n\n        CellView.prototype.mouseover.apply(this, arguments);\n        this.notify('link:mouseover', evt);\n    },\n\n    mouseout: function(evt) {\n\n        CellView.prototype.mouseout.apply(this, arguments);\n        this.notify('link:mouseout', evt);\n    },\n\n    mouseenter: function(evt) {\n\n        CellView.prototype.mouseenter.apply(this, arguments);\n        this.notify('link:mouseenter', evt);\n    },\n\n    mouseleave: function(evt) {\n\n        CellView.prototype.mouseleave.apply(this, arguments);\n        this.notify('link:mouseleave', evt);\n    },\n\n    mousewheel: function(evt, x, y, delta) {\n\n        CellView.prototype.mousewheel.apply(this, arguments);\n        this.notify('link:mousewheel', evt, x, y, delta);\n    },\n\n    onevent: function(evt, eventName, x, y) {\n\n        // Backwards compatibility\n        var linkTool = V(evt.target).findParentByClass('link-tool', this.el);\n        if (linkTool) {\n            // No further action to be executed\n            evt.stopPropagation();\n\n            // Allow `interactive.useLinkTools=false`\n            if (this.can('useLinkTools')) {\n                if (eventName === 'remove') {\n                    // Built-in remove event\n                    this.model.remove({ ui: true });\n                    // Do not trigger link pointerdown\n                    return;\n\n                } else {\n                    // link:options and other custom events inside the link tools\n                    this.notify(eventName, evt, x, y);\n                }\n            }\n\n            this.notifyPointerdown(evt, x, y);\n            this.paper.delegateDragEvents(this, evt.data);\n\n        } else {\n            CellView.prototype.onevent.apply(this, arguments);\n        }\n    },\n\n    onlabel: function(evt, x, y) {\n\n        this.notifyPointerdown(evt, x, y);\n\n        this.dragLabelStart(evt, x, y);\n\n        var stopPropagation = this.eventData(evt).stopPropagation;\n        if (stopPropagation) evt.stopPropagation();\n    },\n\n    // Drag Start Handlers\n\n    dragConnectionStart: function(evt, x, y) {\n\n        if (!this.can('vertexAdd')) return;\n\n        // Store the index at which the new vertex has just been placed.\n        // We'll be update the very same vertex position in `pointermove()`.\n        var vertexIdx = this.addVertex({ x: x, y: y }, { ui: true });\n        this.eventData(evt, {\n            action: 'vertex-move',\n            vertexIdx: vertexIdx\n        });\n    },\n\n    dragLabelStart: function(evt, _x, _y) {\n\n        if (this.can('labelMove')) {\n\n            var labelNode = evt.currentTarget;\n            var labelIdx = parseInt(labelNode.getAttribute('label-idx'), 10);\n\n            var positionAngle = this._getLabelPositionAngle(labelIdx);\n            var labelPositionArgs = this._getLabelPositionArgs(labelIdx);\n            var defaultLabelPositionArgs = this._getDefaultLabelPositionArgs();\n            var positionArgs = this._mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);\n\n            this.eventData(evt, {\n                action: 'label-move',\n                labelIdx: labelIdx,\n                positionAngle: positionAngle,\n                positionArgs: positionArgs,\n                stopPropagation: true\n            });\n\n        } else {\n\n            // Backwards compatibility:\n            // If labels can't be dragged no default action is triggered.\n            this.eventData(evt, { stopPropagation: true });\n        }\n\n        this.paper.delegateDragEvents(this, evt.data);\n    },\n\n    dragVertexStart: function(evt, x, y) {\n\n        if (!this.can('vertexMove')) return;\n\n        var vertexNode = evt.target;\n        var vertexIdx = parseInt(vertexNode.getAttribute('idx'), 10);\n        this.eventData(evt, {\n            action: 'vertex-move',\n            vertexIdx: vertexIdx\n        });\n    },\n\n    dragVertexRemoveStart: function(evt, x, y) {\n\n        if (!this.can('vertexRemove')) return;\n\n        var removeNode = evt.target;\n        var vertexIdx = parseInt(removeNode.getAttribute('idx'), 10);\n        this.model.removeVertex(vertexIdx);\n    },\n\n    dragArrowheadStart: function(evt, x, y) {\n\n        if (!this.can('arrowheadMove')) return;\n\n        var arrowheadNode = evt.target;\n        var arrowheadType = arrowheadNode.getAttribute('end');\n        var data = this.startArrowheadMove(arrowheadType, { ignoreBackwardsCompatibility: true });\n\n        this.eventData(evt, data);\n    },\n\n    dragStart: function(evt, x, y) {\n\n        if (!this.can('linkMove')) return;\n\n        this.eventData(evt, {\n            action: 'move',\n            dx: x,\n            dy: y\n        });\n    },\n\n    // Drag Handlers\n    dragLabel: function(evt, x, y) {\n\n        var data = this.eventData(evt);\n        var label = { position: this.getLabelPosition(x, y, data.positionAngle, data.positionArgs) };\n        if (this.paper.options.snapLabels) delete label.position.offset;\n        this.model.label(data.labelIdx, label);\n    },\n\n    dragVertex: function(evt, x, y) {\n\n        var data = this.eventData(evt);\n        this.model.vertex(data.vertexIdx, { x: x, y: y }, { ui: true });\n    },\n\n    dragArrowhead: function(evt, x, y) {\n\n        if (this.paper.options.snapLinks) {\n\n            this._snapArrowhead(evt, x, y);\n\n        } else {\n\n            this._connectArrowhead(this.getEventTarget(evt), x, y, this.eventData(evt));\n        }\n    },\n\n    drag: function(evt, x, y) {\n\n        var data = this.eventData(evt);\n        this.model.translate(x - data.dx, y - data.dy, { ui: true });\n        this.eventData(evt, {\n            dx: x,\n            dy: y\n        });\n    },\n\n    // Drag End Handlers\n\n    dragLabelEnd: function() {\n        // noop\n    },\n\n    dragVertexEnd: function() {\n        // noop\n    },\n\n    dragArrowheadEnd: function(evt, x, y) {\n\n        var data = this.eventData(evt);\n        var paper = this.paper;\n\n        if (paper.options.snapLinks) {\n            this._snapArrowheadEnd(data);\n        } else {\n            this._connectArrowheadEnd(data, x, y);\n        }\n\n        if (!paper.linkAllowed(this)) {\n            // If the changed link is not allowed, revert to its previous state.\n            this._disallow(data);\n        } else {\n            this._finishEmbedding(data);\n            this._notifyConnectEvent(data, evt);\n        }\n\n        this._afterArrowheadMove(data);\n    },\n\n    dragEnd: function() {\n        // noop\n    },\n\n    _disallow: function(data) {\n\n        switch (data.whenNotAllowed) {\n\n            case 'remove':\n                this.model.remove({ ui: true });\n                break;\n\n            case 'revert':\n            default:\n                this.model.set(data.arrowhead, data.initialEnd, { ui: true });\n                break;\n        }\n    },\n\n    _finishEmbedding: function(data) {\n\n        // Reparent the link if embedding is enabled\n        if (this.paper.options.embeddingMode && this.model.reparent()) {\n            // Make sure we don't reverse to the original 'z' index (see afterArrowheadMove()).\n            data.z = null;\n        }\n    },\n\n    _notifyConnectEvent: function(data, evt) {\n\n        var arrowhead = data.arrowhead;\n        var initialEnd = data.initialEnd;\n        var currentEnd = this.model.prop(arrowhead);\n        var endChanged = currentEnd && !Link.endsEqual(initialEnd, currentEnd);\n        if (endChanged) {\n            var paper = this.paper;\n            if (initialEnd.id) {\n                this.notify('link:disconnect', evt, paper.findViewByModel(initialEnd.id), data.initialMagnet, arrowhead);\n            }\n            if (currentEnd.id) {\n                this.notify('link:connect', evt, paper.findViewByModel(currentEnd.id), data.magnetUnderPointer, arrowhead);\n            }\n        }\n    },\n\n    _snapArrowhead: function(evt, x, y) {\n\n        const { paper } = this;\n        const { snapLinks, connectionStrategy } = paper.options;\n        const data = this.eventData(evt);\n        // checking view in close area of the pointer\n\n        var r = snapLinks.radius || 50;\n        var viewsInArea = paper.findViewsInArea({ x: x - r, y: y - r, width: 2 * r, height: 2 * r });\n\n        var prevClosestView = data.closestView || null;\n        var prevClosestMagnet = data.closestMagnet || null;\n        var prevMagnetProxy = data.magnetProxy || null;\n\n        data.closestView = data.closestMagnet = data.magnetProxy = null;\n\n        var minDistance = Number.MAX_VALUE;\n        var pointer = new Point(x, y);\n\n        viewsInArea.forEach(function(view) {\n            const candidates = [];\n            // skip connecting to the element in case '.': { magnet: false } attribute present\n            if (view.el.getAttribute('magnet') !== 'false') {\n                candidates.push({\n                    bbox: view.model.getBBox(),\n                    magnet: view.el\n                });\n            }\n\n            view.$('[magnet]').toArray().forEach(magnet => {\n                candidates.push({\n                    bbox: view.getNodeBBox(magnet),\n                    magnet\n                });\n            });\n\n            candidates.forEach(candidate => {\n                const { magnet, bbox } = candidate;\n                // find distance from the center of the model to pointer coordinates\n                const distance = bbox.center().squaredDistance(pointer);\n                // the connection is looked up in a circle area by `distance < r`\n                if (distance < minDistance) {\n                    const isAlreadyValidated = prevClosestMagnet === magnet;\n                    if (isAlreadyValidated || paper.options.validateConnection.apply(\n                        paper, data.validateConnectionArgs(view, (view.el === magnet) ? null : magnet)\n                    )) {\n                        minDistance = distance;\n                        data.closestView = view;\n                        data.closestMagnet = magnet;\n                    }\n                }\n            });\n\n        }, this);\n\n        var end;\n        var magnetProxy = null;\n        var closestView = data.closestView;\n        var closestMagnet = data.closestMagnet;\n        if (closestMagnet) {\n            magnetProxy = data.magnetProxy = closestView.findProxyNode(closestMagnet, 'highlighter');\n        }\n        var endType = data.arrowhead;\n        var newClosestMagnet = (prevClosestMagnet !== closestMagnet);\n        if (prevClosestView && newClosestMagnet) {\n            prevClosestView.unhighlight(prevMagnetProxy, {\n                connecting: true,\n                snapping: true\n            });\n        }\n\n        if (closestView) {\n            const { prevEnd, prevX, prevY } = data;\n            data.prevX = x;\n            data.prevY = y;\n\n            if (!newClosestMagnet)  {\n                if (typeof connectionStrategy !== 'function' || (prevX === x && prevY === y)) {\n                    // the magnet has not changed and the link's end does not depend on the x and y\n                    return;\n                }\n            }\n\n            end = closestView.getLinkEnd(closestMagnet, x, y, this.model, endType);\n            if (!newClosestMagnet && isEqual(prevEnd, end)) {\n                // the source/target json has not changed\n                return;\n            }\n\n            data.prevEnd = end;\n\n            if (newClosestMagnet) {\n                closestView.highlight(magnetProxy, {\n                    connecting: true,\n                    snapping: true\n                });\n            }\n\n        } else {\n\n            end = { x: x, y: y };\n        }\n\n        this.model.set(endType, end || { x: x, y: y }, { ui: true });\n\n        if (prevClosestView) {\n            this.notify('link:snap:disconnect', evt, prevClosestView, prevClosestMagnet, endType);\n        }\n        if (closestView) {\n            this.notify('link:snap:connect', evt, closestView, closestMagnet, endType);\n        }\n    },\n\n    _snapArrowheadEnd: function(data) {\n\n        // Finish off link snapping.\n        // Everything except view unhighlighting was already done on pointermove.\n        var closestView = data.closestView;\n        var closestMagnet = data.closestMagnet;\n        if (closestView && closestMagnet) {\n\n            closestView.unhighlight(data.magnetProxy, { connecting: true, snapping: true });\n            data.magnetUnderPointer = closestView.findMagnet(closestMagnet);\n        }\n\n        data.closestView = data.closestMagnet = null;\n    },\n\n    _connectArrowhead: function(target, x, y, data) {\n\n        // checking views right under the pointer\n        const { paper, model } = this;\n\n        if (data.eventTarget !== target) {\n            // Unhighlight the previous view under pointer if there was one.\n            if (data.magnetProxy) {\n                data.viewUnderPointer.unhighlight(data.magnetProxy, {\n                    connecting: true\n                });\n            }\n\n            const viewUnderPointer = data.viewUnderPointer = paper.findView(target);\n            if (viewUnderPointer) {\n                // If we found a view that is under the pointer, we need to find the closest\n                // magnet based on the real target element of the event.\n                const magnetUnderPointer = data.magnetUnderPointer = viewUnderPointer.findMagnet(target);\n                const magnetProxy = data.magnetProxy = viewUnderPointer.findProxyNode(magnetUnderPointer, 'highlighter');\n\n                if (magnetUnderPointer && this.paper.options.validateConnection.apply(\n                    paper,\n                    data.validateConnectionArgs(viewUnderPointer, magnetUnderPointer)\n                )) {\n                    // If there was no magnet found, do not highlight anything and assume there\n                    // is no view under pointer we're interested in reconnecting to.\n                    // This can only happen if the overall element has the attribute `'.': { magnet: false }`.\n                    if (magnetProxy) {\n                        viewUnderPointer.highlight(magnetProxy, {\n                            connecting: true\n                        });\n                    }\n                } else {\n                    // This type of connection is not valid. Disregard this magnet.\n                    data.magnetUnderPointer = null;\n                    data.magnetProxy = null;\n                }\n            } else {\n                // Make sure we'll unset previous magnet.\n                data.magnetUnderPointer = null;\n                data.magnetProxy = null;\n            }\n        }\n\n        data.eventTarget = target;\n\n        model.set(data.arrowhead, { x: x, y: y }, { ui: true });\n    },\n\n    _connectArrowheadEnd: function(data = {}, x, y) {\n\n        const { model } = this;\n        const { viewUnderPointer, magnetUnderPointer, magnetProxy, arrowhead } = data;\n\n        if (!magnetUnderPointer || !magnetProxy || !viewUnderPointer) return;\n\n        viewUnderPointer.unhighlight(magnetProxy, { connecting: true });\n\n        // The link end is taken from the magnet under the pointer, not the proxy.\n        const end = viewUnderPointer.getLinkEnd(magnetUnderPointer, x, y, model, arrowhead);\n        model.set(arrowhead, end, { ui: true });\n    },\n\n    _beforeArrowheadMove: function(data) {\n\n        data.z = this.model.get('z');\n        this.model.toFront();\n\n        // Let the pointer propagate through the link view elements so that\n        // the `evt.target` is another element under the pointer, not the link itself.\n        var style = this.el.style;\n        data.pointerEvents = style.pointerEvents;\n        style.pointerEvents = 'none';\n\n        if (this.paper.options.markAvailable) {\n            this._markAvailableMagnets(data);\n        }\n    },\n\n    _afterArrowheadMove: function(data) {\n\n        if (data.z !== null) {\n            this.model.set('z', data.z, { ui: true });\n            data.z = null;\n        }\n\n        // Put `pointer-events` back to its original value. See `_beforeArrowheadMove()` for explanation.\n        this.el.style.pointerEvents = data.pointerEvents;\n\n        if (this.paper.options.markAvailable) {\n            this._unmarkAvailableMagnets(data);\n        }\n    },\n\n    _createValidateConnectionArgs: function(arrowhead) {\n        // It makes sure the arguments for validateConnection have the following form:\n        // (source view, source magnet, target view, target magnet and link view)\n        var args = [];\n\n        args[4] = arrowhead;\n        args[5] = this;\n\n        var oppositeArrowhead;\n        var i = 0;\n        var j = 0;\n\n        if (arrowhead === 'source') {\n            i = 2;\n            oppositeArrowhead = 'target';\n        } else {\n            j = 2;\n            oppositeArrowhead = 'source';\n        }\n\n        var end = this.model.get(oppositeArrowhead);\n\n        if (end.id) {\n            var view = args[i] = this.paper.findViewByModel(end.id);\n            var magnet = view.getMagnetFromLinkEnd(end);\n            if (magnet === view.el) magnet = undefined;\n            args[i + 1] = magnet;\n        }\n\n        function validateConnectionArgs(cellView, magnet) {\n            args[j] = cellView;\n            args[j + 1] = cellView.el === magnet ? undefined : magnet;\n            return args;\n        }\n\n        return validateConnectionArgs;\n    },\n\n    _markAvailableMagnets: function(data) {\n\n        function isMagnetAvailable(view, magnet) {\n            var paper = view.paper;\n            var validate = paper.options.validateConnection;\n            return validate.apply(paper, this.validateConnectionArgs(view, magnet));\n        }\n\n        var paper = this.paper;\n        var elements = paper.model.getCells();\n        data.marked = {};\n\n        for (var i = 0, n = elements.length; i < n; i++) {\n            var view = elements[i].findView(paper);\n\n            if (!view) {\n                continue;\n            }\n\n            var magnets = Array.prototype.slice.call(view.el.querySelectorAll('[magnet]'));\n            if (view.el.getAttribute('magnet') !== 'false') {\n                // Element wrapping group is also a magnet\n                magnets.push(view.el);\n            }\n\n            var availableMagnets = magnets.filter(isMagnetAvailable.bind(data, view));\n\n            if (availableMagnets.length > 0) {\n                // highlight all available magnets\n                for (var j = 0, m = availableMagnets.length; j < m; j++) {\n                    view.highlight(availableMagnets[j], { magnetAvailability: true });\n                }\n                // highlight the entire view\n                view.highlight(null, { elementAvailability: true });\n\n                data.marked[view.model.id] = availableMagnets;\n            }\n        }\n    },\n\n    _unmarkAvailableMagnets: function(data) {\n\n        var markedKeys = Object.keys(data.marked);\n        var id;\n        var markedMagnets;\n\n        for (var i = 0, n = markedKeys.length; i < n; i++) {\n            id = markedKeys[i];\n            markedMagnets = data.marked[id];\n\n            var view = this.paper.findViewByModel(id);\n            if (view) {\n                for (var j = 0, m = markedMagnets.length; j < m; j++) {\n                    view.unhighlight(markedMagnets[j], { magnetAvailability: true });\n                }\n                view.unhighlight(null, { elementAvailability: true });\n            }\n        }\n\n        data.marked = null;\n    },\n\n    startArrowheadMove: function(end, opt) {\n\n        opt || (opt = {});\n\n        // Allow to delegate events from an another view to this linkView in order to trigger arrowhead\n        // move without need to click on the actual arrowhead dom element.\n        var data = {\n            action: 'arrowhead-move',\n            arrowhead: end,\n            whenNotAllowed: opt.whenNotAllowed || 'revert',\n            initialMagnet: this[end + 'Magnet'] || (this[end + 'View'] ? this[end + 'View'].el : null),\n            initialEnd: clone(this.model.get(end)),\n            validateConnectionArgs: this._createValidateConnectionArgs(end)\n        };\n\n        this._beforeArrowheadMove(data);\n\n        if (opt.ignoreBackwardsCompatibility !== true) {\n            this._dragData = data;\n        }\n\n        return data;\n    },\n\n    onRemove: function() {\n        CellView.prototype.onRemove.apply(this, arguments);\n        this.unmountLabels();\n    }\n\n}, {\n\n    Flags: Flags,\n});\n\nObject.defineProperty(LinkView.prototype, 'sourceBBox', {\n\n    enumerable: true,\n\n    get: function() {\n        var sourceView = this.sourceView;\n        if (!sourceView) {\n            var sourceDef = this.model.source();\n            return new Rect(sourceDef.x, sourceDef.y);\n        }\n        var sourceMagnet = this.sourceMagnet;\n        if (sourceView.isNodeConnection(sourceMagnet)) {\n            return new Rect(this.sourceAnchor);\n        }\n        return sourceView.getNodeBBox(sourceMagnet || sourceView.el);\n    }\n\n});\n\nObject.defineProperty(LinkView.prototype, 'targetBBox', {\n\n    enumerable: true,\n\n    get: function() {\n        var targetView = this.targetView;\n        if (!targetView) {\n            var targetDef = this.model.target();\n            return new Rect(targetDef.x, targetDef.y);\n        }\n        var targetMagnet = this.targetMagnet;\n        if (targetView.isNodeConnection(targetMagnet)) {\n            return new Rect(this.targetAnchor);\n        }\n        return targetView.getNodeBBox(targetMagnet || targetView.el);\n    }\n});\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}