{"ast":null,"code":"import { uniq, toArray, isEmpty } from './util.mjs'; // Clone `cells` returning an object that maps the original cell ID to the clone. The number\n// of clones is exactly the same as the `cells.length`.\n// This function simply clones all the `cells`. However, it also reconstructs\n// all the `source/target` and `parent/embed` references within the `cells`.\n// This is the main difference from the `cell.clone()` method. The\n// `cell.clone()` method works on one single cell only.\n// For example, for a graph: `A --- L ---> B`, `cloneCells([A, L, B])`\n// returns `[A2, L2, B2]` resulting to a graph: `A2 --- L2 ---> B2`, i.e.\n// the source and target of the link `L2` is changed to point to `A2` and `B2`.\n\nexport function cloneCells(cells) {\n  cells = uniq(cells); // A map of the form [original cell ID] -> [clone] helping\n  // us to reconstruct references for source/target and parent/embeds.\n  // This is also the returned value.\n\n  const cloneMap = toArray(cells).reduce(function (map, cell) {\n    map[cell.id] = cell.clone();\n    return map;\n  }, {});\n  toArray(cells).forEach(function (cell) {\n    const clone = cloneMap[cell.id]; // assert(clone exists)\n\n    if (clone.isLink()) {\n      const source = clone.source();\n      const target = clone.target();\n\n      if (source.id && cloneMap[source.id]) {\n        // Source points to an element and the element is among the clones.\n        // => Update the source of the cloned link.\n        clone.prop('source/id', cloneMap[source.id].id);\n      }\n\n      if (target.id && cloneMap[target.id]) {\n        // Target points to an element and the element is among the clones.\n        // => Update the target of the cloned link.\n        clone.prop('target/id', cloneMap[target.id].id);\n      }\n    } // Find the parent of the original cell\n\n\n    const parent = cell.get('parent');\n\n    if (parent && cloneMap[parent]) {\n      clone.set('parent', cloneMap[parent].id);\n    } // Find the embeds of the original cell\n\n\n    const embeds = toArray(cell.get('embeds')).reduce(function (newEmbeds, embed) {\n      // Embedded cells that are not being cloned can not be carried\n      // over with other embedded cells.\n      if (cloneMap[embed]) {\n        newEmbeds.push(cloneMap[embed].id);\n      }\n\n      return newEmbeds;\n    }, []);\n\n    if (!isEmpty(embeds)) {\n      clone.set('embeds', embeds);\n    }\n  });\n  return cloneMap;\n}","map":{"version":3,"names":["uniq","toArray","isEmpty","cloneCells","cells","cloneMap","reduce","map","cell","id","clone","forEach","isLink","source","target","prop","parent","get","set","embeds","newEmbeds","embed","push"],"sources":["C:/Users/Admin/dataflow-test/node_modules/jointjs/src/util/cloneCells.mjs"],"sourcesContent":["import { uniq, toArray, isEmpty } from './util.mjs';\n\n// Clone `cells` returning an object that maps the original cell ID to the clone. The number\n// of clones is exactly the same as the `cells.length`.\n// This function simply clones all the `cells`. However, it also reconstructs\n// all the `source/target` and `parent/embed` references within the `cells`.\n// This is the main difference from the `cell.clone()` method. The\n// `cell.clone()` method works on one single cell only.\n// For example, for a graph: `A --- L ---> B`, `cloneCells([A, L, B])`\n// returns `[A2, L2, B2]` resulting to a graph: `A2 --- L2 ---> B2`, i.e.\n// the source and target of the link `L2` is changed to point to `A2` and `B2`.\nexport function cloneCells(cells) {\n\n    cells = uniq(cells);\n\n    // A map of the form [original cell ID] -> [clone] helping\n    // us to reconstruct references for source/target and parent/embeds.\n    // This is also the returned value.\n    const cloneMap = toArray(cells).reduce(function(map, cell) {\n        map[cell.id] = cell.clone();\n        return map;\n    }, {});\n\n    toArray(cells).forEach(function(cell) {\n\n        const clone = cloneMap[cell.id];\n        // assert(clone exists)\n\n        if (clone.isLink()) {\n            const source = clone.source();\n            const target = clone.target();\n            if (source.id && cloneMap[source.id]) {\n                // Source points to an element and the element is among the clones.\n                // => Update the source of the cloned link.\n                clone.prop('source/id', cloneMap[source.id].id);\n            }\n            if (target.id && cloneMap[target.id]) {\n                // Target points to an element and the element is among the clones.\n                // => Update the target of the cloned link.\n                clone.prop('target/id', cloneMap[target.id].id);\n            }\n        }\n\n        // Find the parent of the original cell\n        const parent = cell.get('parent');\n        if (parent && cloneMap[parent]) {\n            clone.set('parent', cloneMap[parent].id);\n        }\n\n        // Find the embeds of the original cell\n        const embeds = toArray(cell.get('embeds')).reduce(function(newEmbeds, embed) {\n            // Embedded cells that are not being cloned can not be carried\n            // over with other embedded cells.\n            if (cloneMap[embed]) {\n                newEmbeds.push(cloneMap[embed].id);\n            }\n            return newEmbeds;\n        }, []);\n\n        if (!isEmpty(embeds)) {\n            clone.set('embeds', embeds);\n        }\n    });\n\n    return cloneMap;\n}\n\n"],"mappings":"AAAA,SAASA,IAAT,EAAeC,OAAf,EAAwBC,OAAxB,QAAuC,YAAvC,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,UAAT,CAAoBC,KAApB,EAA2B;EAE9BA,KAAK,GAAGJ,IAAI,CAACI,KAAD,CAAZ,CAF8B,CAI9B;EACA;EACA;;EACA,MAAMC,QAAQ,GAAGJ,OAAO,CAACG,KAAD,CAAP,CAAeE,MAAf,CAAsB,UAASC,GAAT,EAAcC,IAAd,EAAoB;IACvDD,GAAG,CAACC,IAAI,CAACC,EAAN,CAAH,GAAeD,IAAI,CAACE,KAAL,EAAf;IACA,OAAOH,GAAP;EACH,CAHgB,EAGd,EAHc,CAAjB;EAKAN,OAAO,CAACG,KAAD,CAAP,CAAeO,OAAf,CAAuB,UAASH,IAAT,EAAe;IAElC,MAAME,KAAK,GAAGL,QAAQ,CAACG,IAAI,CAACC,EAAN,CAAtB,CAFkC,CAGlC;;IAEA,IAAIC,KAAK,CAACE,MAAN,EAAJ,EAAoB;MAChB,MAAMC,MAAM,GAAGH,KAAK,CAACG,MAAN,EAAf;MACA,MAAMC,MAAM,GAAGJ,KAAK,CAACI,MAAN,EAAf;;MACA,IAAID,MAAM,CAACJ,EAAP,IAAaJ,QAAQ,CAACQ,MAAM,CAACJ,EAAR,CAAzB,EAAsC;QAClC;QACA;QACAC,KAAK,CAACK,IAAN,CAAW,WAAX,EAAwBV,QAAQ,CAACQ,MAAM,CAACJ,EAAR,CAAR,CAAoBA,EAA5C;MACH;;MACD,IAAIK,MAAM,CAACL,EAAP,IAAaJ,QAAQ,CAACS,MAAM,CAACL,EAAR,CAAzB,EAAsC;QAClC;QACA;QACAC,KAAK,CAACK,IAAN,CAAW,WAAX,EAAwBV,QAAQ,CAACS,MAAM,CAACL,EAAR,CAAR,CAAoBA,EAA5C;MACH;IACJ,CAlBiC,CAoBlC;;;IACA,MAAMO,MAAM,GAAGR,IAAI,CAACS,GAAL,CAAS,QAAT,CAAf;;IACA,IAAID,MAAM,IAAIX,QAAQ,CAACW,MAAD,CAAtB,EAAgC;MAC5BN,KAAK,CAACQ,GAAN,CAAU,QAAV,EAAoBb,QAAQ,CAACW,MAAD,CAAR,CAAiBP,EAArC;IACH,CAxBiC,CA0BlC;;;IACA,MAAMU,MAAM,GAAGlB,OAAO,CAACO,IAAI,CAACS,GAAL,CAAS,QAAT,CAAD,CAAP,CAA4BX,MAA5B,CAAmC,UAASc,SAAT,EAAoBC,KAApB,EAA2B;MACzE;MACA;MACA,IAAIhB,QAAQ,CAACgB,KAAD,CAAZ,EAAqB;QACjBD,SAAS,CAACE,IAAV,CAAejB,QAAQ,CAACgB,KAAD,CAAR,CAAgBZ,EAA/B;MACH;;MACD,OAAOW,SAAP;IACH,CAPc,EAOZ,EAPY,CAAf;;IASA,IAAI,CAAClB,OAAO,CAACiB,MAAD,CAAZ,EAAsB;MAClBT,KAAK,CAACQ,GAAN,CAAU,QAAV,EAAoBC,MAApB;IACH;EACJ,CAvCD;EAyCA,OAAOd,QAAP;AACH"},"metadata":{},"sourceType":"module"}