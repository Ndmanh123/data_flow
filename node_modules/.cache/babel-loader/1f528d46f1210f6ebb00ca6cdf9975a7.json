{"ast":null,"code":"import { Line, Point } from '../g/index.mjs';\nimport { isPercentage } from '../util/index.mjs';\n\nfunction connectionRatio(view, _magnet, _refPoint, opt) {\n  var ratio = 'ratio' in opt ? opt.ratio : 0.5;\n  return view.getPointAtRatio(ratio);\n}\n\nfunction connectionLength(view, _magnet, _refPoint, opt) {\n  var length = 'length' in opt ? opt.length : 20;\n  return view.getPointAtLength(length);\n}\n\nfunction _connectionPerpendicular(view, _magnet, refPoint, opt) {\n  var OFFSET = 1e6;\n  var path = view.getConnection();\n  var segmentSubdivisions = view.getConnectionSubdivisions();\n  var verticalLine = new Line(refPoint.clone().offset(0, OFFSET), refPoint.clone().offset(0, -OFFSET));\n  var horizontalLine = new Line(refPoint.clone().offset(OFFSET, 0), refPoint.clone().offset(-OFFSET, 0));\n  var verticalIntersections = verticalLine.intersect(path, {\n    segmentSubdivisions: segmentSubdivisions\n  });\n  var horizontalIntersections = horizontalLine.intersect(path, {\n    segmentSubdivisions: segmentSubdivisions\n  });\n  var intersections = [];\n  if (verticalIntersections) Array.prototype.push.apply(intersections, verticalIntersections);\n  if (horizontalIntersections) Array.prototype.push.apply(intersections, horizontalIntersections);\n  if (intersections.length > 0) return refPoint.chooseClosest(intersections);\n\n  if ('fallbackAt' in opt) {\n    return getPointAtLink(view, opt.fallbackAt);\n  }\n\n  return connectionClosest(view, _magnet, refPoint, opt);\n}\n\nfunction _connectionClosest(view, _magnet, refPoint, _opt) {\n  var closestPoint = view.getClosestPoint(refPoint);\n  if (!closestPoint) return new Point();\n  return closestPoint;\n}\n\nexport function resolveRef(fn) {\n  return function (view, magnet, ref, opt) {\n    if (ref instanceof Element) {\n      var refView = this.paper.findView(ref);\n      var refPoint;\n\n      if (refView) {\n        if (refView.isNodeConnection(ref)) {\n          var distance = 'fixedAt' in opt ? opt.fixedAt : '50%';\n          refPoint = getPointAtLink(refView, distance);\n        } else {\n          refPoint = refView.getNodeBBox(ref).center();\n        }\n      } else {\n        // Something went wrong\n        refPoint = new Point();\n      }\n\n      return fn.call(this, view, magnet, refPoint, opt);\n    }\n\n    return fn.apply(this, arguments);\n  };\n}\n\nfunction getPointAtLink(view, value) {\n  var parsedValue = parseFloat(value);\n\n  if (isPercentage(value)) {\n    return view.getPointAtRatio(parsedValue / 100);\n  } else {\n    return view.getPointAtLength(parsedValue);\n  }\n} // joint.linkAnchors\n\n\nexport { connectionRatio, connectionLength };\nexport const connectionPerpendicular = resolveRef(_connectionPerpendicular);\nexport const connectionClosest = resolveRef(_connectionClosest);","map":{"version":3,"names":["Line","Point","isPercentage","connectionRatio","view","_magnet","_refPoint","opt","ratio","getPointAtRatio","connectionLength","length","getPointAtLength","_connectionPerpendicular","refPoint","OFFSET","path","getConnection","segmentSubdivisions","getConnectionSubdivisions","verticalLine","clone","offset","horizontalLine","verticalIntersections","intersect","horizontalIntersections","intersections","Array","prototype","push","apply","chooseClosest","getPointAtLink","fallbackAt","connectionClosest","_connectionClosest","_opt","closestPoint","getClosestPoint","resolveRef","fn","magnet","ref","Element","refView","paper","findView","isNodeConnection","distance","fixedAt","getNodeBBox","center","call","arguments","value","parsedValue","parseFloat","connectionPerpendicular"],"sources":["C:/Users/Admin/dataflow-test/node_modules/jointjs/src/linkAnchors/index.mjs"],"sourcesContent":["import { Line, Point } from '../g/index.mjs';\nimport { isPercentage } from '../util/index.mjs';\n\nfunction connectionRatio(view, _magnet, _refPoint, opt) {\n\n    var ratio = ('ratio' in opt) ? opt.ratio : 0.5;\n    return view.getPointAtRatio(ratio);\n}\n\nfunction connectionLength(view, _magnet, _refPoint, opt) {\n\n    var length = ('length' in opt) ? opt.length : 20;\n    return view.getPointAtLength(length);\n}\n\nfunction _connectionPerpendicular(view, _magnet, refPoint, opt) {\n\n    var OFFSET = 1e6;\n    var path = view.getConnection();\n    var segmentSubdivisions = view.getConnectionSubdivisions();\n    var verticalLine = new Line(refPoint.clone().offset(0, OFFSET), refPoint.clone().offset(0, -OFFSET));\n    var horizontalLine = new Line(refPoint.clone().offset(OFFSET, 0), refPoint.clone().offset(-OFFSET, 0));\n    var verticalIntersections = verticalLine.intersect(path, { segmentSubdivisions: segmentSubdivisions });\n    var horizontalIntersections = horizontalLine.intersect(path, { segmentSubdivisions: segmentSubdivisions });\n    var intersections = [];\n    if (verticalIntersections) Array.prototype.push.apply(intersections, verticalIntersections);\n    if (horizontalIntersections) Array.prototype.push.apply(intersections, horizontalIntersections);\n    if (intersections.length > 0) return refPoint.chooseClosest(intersections);\n    if ('fallbackAt' in opt) {\n        return getPointAtLink(view, opt.fallbackAt);\n    }\n    return connectionClosest(view, _magnet, refPoint, opt);\n}\n\nfunction _connectionClosest(view, _magnet, refPoint, _opt) {\n\n    var closestPoint = view.getClosestPoint(refPoint);\n    if (!closestPoint) return new Point();\n    return closestPoint;\n}\n\nexport function resolveRef(fn) {\n    return function(view, magnet, ref, opt) {\n        if (ref instanceof Element) {\n            var refView = this.paper.findView(ref);\n            var refPoint;\n            if (refView) {\n                if (refView.isNodeConnection(ref)) {\n                    var distance = ('fixedAt' in opt) ? opt.fixedAt : '50%';\n                    refPoint = getPointAtLink(refView, distance);\n                } else {\n                    refPoint = refView.getNodeBBox(ref).center();\n                }\n            } else {\n                // Something went wrong\n                refPoint = new Point();\n            }\n            return fn.call(this, view, magnet, refPoint, opt);\n        }\n        return fn.apply(this, arguments);\n    };\n}\n\nfunction getPointAtLink(view, value) {\n    var parsedValue = parseFloat(value);\n    if (isPercentage(value)) {\n        return view.getPointAtRatio(parsedValue / 100);\n    } else {\n        return view.getPointAtLength(parsedValue);\n    }\n}\n\n// joint.linkAnchors\nexport { connectionRatio, connectionLength };\nexport const connectionPerpendicular = resolveRef(_connectionPerpendicular);\nexport const connectionClosest = resolveRef(_connectionClosest);\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}