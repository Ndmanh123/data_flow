{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport Backbone from 'backbone';\nimport { uniqueId, union, result, merge, forIn, isObject, isEqual, isString, cloneDeep, omit, uuid, isEmpty, assign, uniq, toArray, defaults, setByPath, unsetByPath, getByPath, timing, interpolate, nextFrame, without, cancelFrame, defaultsDeep, has } from '../util/util.mjs';\nimport { cloneCells } from '../util/cloneCells.mjs';\nimport { attributes } from './attributes/index.mjs';\nimport * as g from '../g/index.mjs'; // Cell base model.\n// --------------------------\n\nexport const Cell = Backbone.Model.extend({\n  // This is the same as Backbone.Model with the only difference that is uses util.merge\n  // instead of just _.extend. The reason is that we want to mixin attributes set in upper classes.\n  constructor: function (attributes, options) {\n    var defaults;\n    var attrs = attributes || {};\n\n    if (typeof this.preinitialize === 'function') {\n      // Check to support an older version of Backbone (prior v1.4)\n      this.preinitialize.apply(this, arguments);\n    }\n\n    this.cid = uniqueId('c');\n    this.attributes = {};\n    if (options && options.collection) this.collection = options.collection;\n    if (options && options.parse) attrs = this.parse(attrs, options) || {};\n\n    if (defaults = result(this, 'defaults')) {\n      //<custom code>\n      // Replaced the call to _.defaults with util.merge.\n      attrs = merge({}, defaults, attrs); //</custom code>\n    }\n\n    this.set(attrs, options);\n    this.changed = {};\n    this.initialize.apply(this, arguments);\n  },\n  translate: function (dx, dy, opt) {\n    throw new Error('Must define a translate() method.');\n  },\n  toJSON: function () {\n    const defaults = result(this.constructor.prototype, 'defaults');\n    const defaultAttrs = defaults.attrs || {};\n    const attrs = this.attributes.attrs;\n    const finalAttrs = {}; // Loop through all the attributes and\n    // omit the default attributes as they are implicitly reconstructible by the cell 'type'.\n\n    forIn(attrs, function (attr, selector) {\n      const defaultAttr = defaultAttrs[selector];\n      forIn(attr, function (value, name) {\n        // attr is mainly flat though it might have one more level (consider the `style` attribute).\n        // Check if the `value` is object and if yes, go one level deep.\n        if (isObject(value) && !Array.isArray(value)) {\n          forIn(value, function (value2, name2) {\n            if (!defaultAttr || !defaultAttr[name] || !isEqual(defaultAttr[name][name2], value2)) {\n              finalAttrs[selector] = finalAttrs[selector] || {};\n              (finalAttrs[selector][name] || (finalAttrs[selector][name] = {}))[name2] = value2;\n            }\n          });\n        } else if (!defaultAttr || !isEqual(defaultAttr[name], value)) {\n          // `value` is not an object, default attribute for such a selector does not exist\n          // or it is different than the attribute value set on the model.\n          finalAttrs[selector] = finalAttrs[selector] || {};\n          finalAttrs[selector][name] = value;\n        }\n      });\n    });\n    const attributes = cloneDeep(omit(this.attributes, 'attrs'));\n    attributes.attrs = finalAttrs;\n    return attributes;\n  },\n  initialize: function (options) {\n    const idAttribute = this.getIdAttribute();\n\n    if (!options || !(idAttribute in options)) {\n      this.set(idAttribute, this.generateId(), {\n        silent: true\n      });\n    }\n\n    this._transitionIds = {};\n    this._scheduledTransitionIds = {}; // Collect ports defined in `attrs` and keep collecting whenever `attrs` object changes.\n\n    this.processPorts();\n    this.on('change:attrs', this.processPorts, this);\n  },\n  getIdAttribute: function () {\n    return this.idAttribute || 'id';\n  },\n  generateId: function () {\n    return uuid();\n  },\n\n  /**\n   * @deprecated\n   */\n  processPorts: function () {\n    // Whenever `attrs` changes, we extract ports from the `attrs` object and store it\n    // in a more accessible way. Also, if any port got removed and there were links that had `target`/`source`\n    // set to that port, we remove those links as well (to follow the same behaviour as\n    // with a removed element).\n    var previousPorts = this.ports; // Collect ports from the `attrs` object.\n\n    var ports = {};\n    forIn(this.get('attrs'), function (attrs, selector) {\n      if (attrs && attrs.port) {\n        // `port` can either be directly an `id` or an object containing an `id` (and potentially other data).\n        if (attrs.port.id !== undefined) {\n          ports[attrs.port.id] = attrs.port;\n        } else {\n          ports[attrs.port] = {\n            id: attrs.port\n          };\n        }\n      }\n    }); // Collect ports that have been removed (compared to the previous ports) - if any.\n    // Use hash table for quick lookup.\n\n    var removedPorts = {};\n    forIn(previousPorts, function (port, id) {\n      if (!ports[id]) removedPorts[id] = true;\n    }); // Remove all the incoming/outgoing links that have source/target port set to any of the removed ports.\n\n    if (this.graph && !isEmpty(removedPorts)) {\n      var inboundLinks = this.graph.getConnectedLinks(this, {\n        inbound: true\n      });\n      inboundLinks.forEach(function (link) {\n        if (removedPorts[link.get('target').port]) link.remove();\n      });\n      var outboundLinks = this.graph.getConnectedLinks(this, {\n        outbound: true\n      });\n      outboundLinks.forEach(function (link) {\n        if (removedPorts[link.get('source').port]) link.remove();\n      });\n    } // Update the `ports` object.\n\n\n    this.ports = ports;\n  },\n  remove: function (opt = {}) {\n    // Store the graph in a variable because `this.graph` won't be accessible\n    // after `this.trigger('remove', ...)` down below.\n    const {\n      graph,\n      collection\n    } = this;\n\n    if (!graph) {\n      // The collection is a common Backbone collection (not the graph collection).\n      if (collection) collection.remove(this, opt);\n      return this;\n    }\n\n    graph.startBatch('remove'); // First, unembed this cell from its parent cell if there is one.\n\n    const parentCell = this.getParentCell();\n\n    if (parentCell) {\n      parentCell.unembed(this, opt);\n    } // Remove also all the cells, which were embedded into this cell\n\n\n    const embeddedCells = this.getEmbeddedCells();\n\n    for (let i = 0, n = embeddedCells.length; i < n; i++) {\n      const embed = embeddedCells[i];\n\n      if (embed) {\n        embed.remove(opt);\n      }\n    }\n\n    this.trigger('remove', this, graph.attributes.cells, opt);\n    graph.stopBatch('remove');\n    return this;\n  },\n  toFront: function (opt) {\n    var graph = this.graph;\n\n    if (graph) {\n      opt = opt || {};\n      var z = graph.maxZIndex();\n      var cells;\n\n      if (opt.deep) {\n        cells = this.getEmbeddedCells({\n          deep: true,\n          breadthFirst: opt.breadthFirst !== false\n        });\n        cells.unshift(this);\n      } else {\n        cells = [this];\n      }\n\n      z = z - cells.length + 1;\n      var collection = graph.get('cells');\n      var shouldUpdate = collection.indexOf(this) !== collection.length - cells.length;\n\n      if (!shouldUpdate) {\n        shouldUpdate = cells.some(function (cell, index) {\n          return cell.get('z') !== z + index;\n        });\n      }\n\n      if (shouldUpdate) {\n        this.startBatch('to-front');\n        z = z + cells.length;\n        cells.forEach(function (cell, index) {\n          cell.set('z', z + index, opt);\n        });\n        this.stopBatch('to-front');\n      }\n    }\n\n    return this;\n  },\n  toBack: function (opt) {\n    var graph = this.graph;\n\n    if (graph) {\n      opt = opt || {};\n      var z = graph.minZIndex();\n      var cells;\n\n      if (opt.deep) {\n        cells = this.getEmbeddedCells({\n          deep: true,\n          breadthFirst: opt.breadthFirst !== false\n        });\n        cells.unshift(this);\n      } else {\n        cells = [this];\n      }\n\n      var collection = graph.get('cells');\n      var shouldUpdate = collection.indexOf(this) !== 0;\n\n      if (!shouldUpdate) {\n        shouldUpdate = cells.some(function (cell, index) {\n          return cell.get('z') !== z + index;\n        });\n      }\n\n      if (shouldUpdate) {\n        this.startBatch('to-back');\n        z -= cells.length;\n        cells.forEach(function (cell, index) {\n          cell.set('z', z + index, opt);\n        });\n        this.stopBatch('to-back');\n      }\n    }\n\n    return this;\n  },\n  parent: function (parent, opt) {\n    // getter\n    if (parent === undefined) return this.get('parent'); // setter\n\n    return this.set('parent', parent, opt);\n  },\n  embed: function (cell, opt) {\n    const cells = Array.isArray(cell) ? cell : [cell];\n\n    if (!this.canEmbed(cells)) {\n      throw new Error('Recursive embedding not allowed.');\n    }\n\n    this._embedCells(cells, opt);\n\n    return this;\n  },\n  unembed: function (cell, opt) {\n    const cells = Array.isArray(cell) ? cell : [cell];\n\n    this._unembedCells(cells, opt);\n\n    return this;\n  },\n  canEmbed: function (cell) {\n    const cells = Array.isArray(cell) ? cell : [cell];\n    return cells.every(c => this !== c && !this.isEmbeddedIn(c));\n  },\n  _embedCells: function (cells, opt) {\n    const batchName = 'embed';\n    this.startBatch(batchName);\n    const embeds = assign([], this.get('embeds'));\n    cells.forEach(cell => {\n      // We keep all element ids after link ids.\n      embeds[cell.isLink() ? 'unshift' : 'push'](cell.id);\n      cell.parent(this.id, opt);\n    });\n    this.set('embeds', uniq(embeds), opt);\n    this.stopBatch(batchName);\n  },\n  _unembedCells: function (cells, opt) {\n    const batchName = 'unembed';\n    this.startBatch(batchName);\n    cells.forEach(cell => cell.unset('parent', opt));\n    this.set('embeds', without(this.get('embeds'), ...cells.map(cell => cell.id)), opt);\n    this.stopBatch(batchName);\n  },\n  getParentCell: function () {\n    // unlike link.source/target, cell.parent stores id directly as a string\n    var parentId = this.parent();\n    var graph = this.graph;\n    return parentId && graph && graph.getCell(parentId) || null;\n  },\n  // Return an array of ancestor cells.\n  // The array is ordered from the parent of the cell\n  // to the most distant ancestor.\n  getAncestors: function () {\n    var ancestors = [];\n\n    if (!this.graph) {\n      return ancestors;\n    }\n\n    var parentCell = this.getParentCell();\n\n    while (parentCell) {\n      ancestors.push(parentCell);\n      parentCell = parentCell.getParentCell();\n    }\n\n    return ancestors;\n  },\n  getEmbeddedCells: function (opt) {\n    opt = opt || {}; // Cell models can only be retrieved when this element is part of a collection.\n    // There is no way this element knows about other cells otherwise.\n    // This also means that calling e.g. `translate()` on an element with embeds before\n    // adding it to a graph does not translate its embeds.\n\n    if (this.graph) {\n      var cells;\n\n      if (opt.deep) {\n        if (opt.breadthFirst) {\n          // breadthFirst algorithm\n          cells = [];\n          var queue = this.getEmbeddedCells();\n\n          while (queue.length > 0) {\n            var parent = queue.shift();\n            cells.push(parent);\n            queue.push.apply(queue, parent.getEmbeddedCells());\n          }\n        } else {\n          // depthFirst algorithm\n          cells = this.getEmbeddedCells();\n          cells.forEach(function (cell) {\n            cells.push.apply(cells, cell.getEmbeddedCells(opt));\n          });\n        }\n      } else {\n        cells = toArray(this.get('embeds')).map(this.graph.getCell, this.graph);\n      }\n\n      return cells;\n    }\n\n    return [];\n  },\n  isEmbeddedIn: function (cell, opt) {\n    var cellId = isString(cell) ? cell : cell.id;\n    var parentId = this.parent();\n    opt = defaults({\n      deep: true\n    }, opt); // See getEmbeddedCells().\n\n    if (this.graph && opt.deep) {\n      while (parentId) {\n        if (parentId === cellId) {\n          return true;\n        }\n\n        parentId = this.graph.getCell(parentId).parent();\n      }\n\n      return false;\n    } else {\n      // When this cell is not part of a collection check\n      // at least whether it's a direct child of given cell.\n      return parentId === cellId;\n    }\n  },\n  // Whether or not the cell is embedded in any other cell.\n  isEmbedded: function () {\n    return !!this.parent();\n  },\n  // Isolated cloning. Isolated cloning has two versions: shallow and deep (pass `{ deep: true }` in `opt`).\n  // Shallow cloning simply clones the cell and returns a new cell with different ID.\n  // Deep cloning clones the cell and all its embedded cells recursively.\n  clone: function (opt) {\n    opt = opt || {};\n\n    if (!opt.deep) {\n      // Shallow cloning.\n      var clone = Backbone.Model.prototype.clone.apply(this, arguments); // We don't want the clone to have the same ID as the original.\n\n      clone.set(this.getIdAttribute(), this.generateId()); // A shallow cloned element does not carry over the original embeds.\n\n      clone.unset('embeds'); // And can not be embedded in any cell\n      // as the clone is not part of the graph.\n\n      clone.unset('parent');\n      return clone;\n    } else {\n      // Deep cloning.\n      // For a deep clone, simply call `graph.cloneCells()` with the cell and all its embedded cells.\n      return toArray(cloneCells([this].concat(this.getEmbeddedCells({\n        deep: true\n      }))));\n    }\n  },\n  // A convenient way to set nested properties.\n  // This method merges the properties you'd like to set with the ones\n  // stored in the cell and makes sure change events are properly triggered.\n  // You can either set a nested property with one object\n  // or use a property path.\n  // The most simple use case is:\n  // `cell.prop('name/first', 'John')` or\n  // `cell.prop({ name: { first: 'John' } })`.\n  // Nested arrays are supported too:\n  // `cell.prop('series/0/data/0/degree', 50)` or\n  // `cell.prop({ series: [ { data: [ { degree: 50 } ] } ] })`.\n  prop: function (props, value, opt) {\n    var delim = '/';\n\n    var _isString = isString(props);\n\n    if (_isString || Array.isArray(props)) {\n      // Get/set an attribute by a special path syntax that delimits\n      // nested objects by the colon character.\n      if (arguments.length > 1) {\n        var path;\n        var pathArray;\n\n        if (_isString) {\n          path = props;\n          pathArray = path.split('/');\n        } else {\n          path = props.join(delim);\n          pathArray = props.slice();\n        }\n\n        var property = pathArray[0];\n        var pathArrayLength = pathArray.length;\n        opt = opt || {};\n        opt.propertyPath = path;\n        opt.propertyValue = value;\n        opt.propertyPathArray = pathArray;\n\n        if (pathArrayLength === 1) {\n          // Property is not nested. We can simply use `set()`.\n          return this.set(property, value, opt);\n        }\n\n        var update = {}; // Initialize the nested object. Subobjects are either arrays or objects.\n        // An empty array is created if the sub-key is an integer. Otherwise, an empty object is created.\n        // Note that this imposes a limitation on object keys one can use with Inspector.\n        // Pure integer keys will cause issues and are therefore not allowed.\n\n        var initializer = update;\n        var prevProperty = property;\n\n        for (var i = 1; i < pathArrayLength; i++) {\n          var pathItem = pathArray[i];\n          var isArrayIndex = Number.isFinite(_isString ? Number(pathItem) : pathItem);\n          initializer = initializer[prevProperty] = isArrayIndex ? [] : {};\n          prevProperty = pathItem;\n        } // Fill update with the `value` on `path`.\n\n\n        update = setByPath(update, pathArray, value, '/');\n        var baseAttributes = merge({}, this.attributes); // if rewrite mode enabled, we replace value referenced by path with\n        // the new one (we don't merge).\n\n        opt.rewrite && unsetByPath(baseAttributes, path, '/'); // Merge update with the model attributes.\n\n        var attributes = merge(baseAttributes, update); // Finally, set the property to the updated attributes.\n\n        return this.set(property, attributes[property], opt);\n      } else {\n        return getByPath(this.attributes, props, delim);\n      }\n    }\n\n    return this.set(merge({}, this.attributes, props), value);\n  },\n  // A convenient way to unset nested properties\n  removeProp: function (path, opt) {\n    opt = opt || {};\n    var pathArray = Array.isArray(path) ? path : path.split('/'); // Once a property is removed from the `attrs` attribute\n    // the cellView will recognize a `dirty` flag and re-render itself\n    // in order to remove the attribute from SVG element.\n\n    var property = pathArray[0];\n    if (property === 'attrs') opt.dirty = true;\n\n    if (pathArray.length === 1) {\n      // A top level property\n      return this.unset(path, opt);\n    } // A nested property\n\n\n    var nestedPath = pathArray.slice(1);\n    var propertyValue = cloneDeep(this.get(property));\n    unsetByPath(propertyValue, nestedPath, '/');\n    return this.set(property, propertyValue, opt);\n  },\n  // A convenient way to set nested attributes.\n  attr: function (attrs, value, opt) {\n    var args = Array.from(arguments);\n\n    if (args.length === 0) {\n      return this.get('attrs');\n    }\n\n    if (Array.isArray(attrs)) {\n      args[0] = ['attrs'].concat(attrs);\n    } else if (isString(attrs)) {\n      // Get/set an attribute by a special path syntax that delimits\n      // nested objects by the colon character.\n      args[0] = 'attrs/' + attrs;\n    } else {\n      args[0] = {\n        'attrs': attrs\n      };\n    }\n\n    return this.prop.apply(this, args);\n  },\n  // A convenient way to unset nested attributes\n  removeAttr: function (path, opt) {\n    if (Array.isArray(path)) {\n      return this.removeProp(['attrs'].concat(path));\n    }\n\n    return this.removeProp('attrs/' + path, opt);\n  },\n  transition: function (path, value, opt, delim) {\n    delim = delim || '/';\n    var defaults = {\n      duration: 100,\n      delay: 10,\n      timingFunction: timing.linear,\n      valueFunction: interpolate.number\n    };\n    opt = assign(defaults, opt);\n    var firstFrameTime = 0;\n    var interpolatingFunction;\n\n    var setter = function (runtime) {\n      var id, progress, propertyValue;\n      firstFrameTime = firstFrameTime || runtime;\n      runtime -= firstFrameTime;\n      progress = runtime / opt.duration;\n\n      if (progress < 1) {\n        this._transitionIds[path] = id = nextFrame(setter);\n      } else {\n        progress = 1;\n        delete this._transitionIds[path];\n      }\n\n      propertyValue = interpolatingFunction(opt.timingFunction(progress));\n      opt.transitionId = id;\n      this.prop(path, propertyValue, opt);\n      if (!id) this.trigger('transition:end', this, path);\n    }.bind(this);\n\n    const {\n      _scheduledTransitionIds\n    } = this;\n    let initialId;\n\n    var initiator = callback => {\n      if (_scheduledTransitionIds[path]) {\n        _scheduledTransitionIds[path] = without(_scheduledTransitionIds[path], initialId);\n\n        if (_scheduledTransitionIds[path].length === 0) {\n          delete _scheduledTransitionIds[path];\n        }\n      }\n\n      this.stopPendingTransitions(path, delim);\n      interpolatingFunction = opt.valueFunction(getByPath(this.attributes, path, delim), value);\n      this._transitionIds[path] = nextFrame(callback);\n      this.trigger('transition:start', this, path);\n    };\n\n    initialId = setTimeout(initiator, opt.delay, setter);\n    _scheduledTransitionIds[path] || (_scheduledTransitionIds[path] = []);\n\n    _scheduledTransitionIds[path].push(initialId);\n\n    return initialId;\n  },\n  getTransitions: function () {\n    return union(Object.keys(this._transitionIds), Object.keys(this._scheduledTransitionIds));\n  },\n  stopScheduledTransitions: function (path, delim = '/') {\n    const {\n      _scheduledTransitionIds = {}\n    } = this;\n    let transitions = Object.keys(_scheduledTransitionIds);\n\n    if (path) {\n      const pathArray = path.split(delim);\n      transitions = transitions.filter(key => {\n        return isEqual(pathArray, key.split(delim).slice(0, pathArray.length));\n      });\n    }\n\n    transitions.forEach(key => {\n      const transitionIds = _scheduledTransitionIds[key]; // stop the initiator\n\n      transitionIds.forEach(transitionId => clearTimeout(transitionId));\n      delete _scheduledTransitionIds[key]; // Note: we could trigger transition:cancel` event here\n    });\n    return this;\n  },\n\n  stopPendingTransitions(path, delim = '/') {\n    const {\n      _transitionIds = {}\n    } = this;\n    let transitions = Object.keys(_transitionIds);\n\n    if (path) {\n      const pathArray = path.split(delim);\n      transitions = transitions.filter(key => {\n        return isEqual(pathArray, key.split(delim).slice(0, pathArray.length));\n      });\n    }\n\n    transitions.forEach(key => {\n      const transitionId = _transitionIds[key]; // stop the setter\n\n      cancelFrame(transitionId);\n      delete _transitionIds[key];\n      this.trigger('transition:end', this, key);\n    });\n  },\n\n  stopTransitions: function (path, delim = '/') {\n    this.stopScheduledTransitions(path, delim);\n    this.stopPendingTransitions(path, delim);\n    return this;\n  },\n  // A shorcut making it easy to create constructs like the following:\n  // `var el = (new joint.shapes.basic.Rect).addTo(graph)`.\n  addTo: function (graph, opt) {\n    graph.addCell(this, opt);\n    return this;\n  },\n  // A shortcut for an equivalent call: `paper.findViewByModel(cell)`\n  // making it easy to create constructs like the following:\n  // `cell.findView(paper).highlight()`\n  findView: function (paper) {\n    return paper.findViewByModel(this);\n  },\n  isElement: function () {\n    return false;\n  },\n  isLink: function () {\n    return false;\n  },\n  startBatch: function (name, opt) {\n    if (this.graph) {\n      this.graph.startBatch(name, assign({}, opt, {\n        cell: this\n      }));\n    }\n\n    return this;\n  },\n  stopBatch: function (name, opt) {\n    if (this.graph) {\n      this.graph.stopBatch(name, assign({}, opt, {\n        cell: this\n      }));\n    }\n\n    return this;\n  },\n  getChangeFlag: function (attributes) {\n    var flag = 0;\n    if (!attributes) return flag;\n\n    for (var key in attributes) {\n      if (!attributes.hasOwnProperty(key) || !this.hasChanged(key)) continue;\n      flag |= attributes[key];\n    }\n\n    return flag;\n  },\n  angle: function () {\n    // To be overridden.\n    return 0;\n  },\n  position: function () {\n    // To be overridden.\n    return new g.Point(0, 0);\n  },\n  getPointFromConnectedLink: function () {\n    // To be overridden\n    return new g.Point();\n  },\n  getBBox: function () {\n    // To be overridden\n    return new g.Rect(0, 0, 0, 0);\n  },\n\n  getPointRotatedAroundCenter(angle, x, y) {\n    const point = new g.Point(x, y);\n    if (angle) point.rotate(this.getBBox().center(), angle);\n    return point;\n  },\n\n  getAbsolutePointFromRelative(x, y) {\n    // Rotate the position to take the model angle into account\n    return this.getPointRotatedAroundCenter(-this.angle(), // Transform the relative position to absolute\n    this.position().offset(x, y));\n  },\n\n  getRelativePointFromAbsolute(x, y) {\n    return this // Rotate the coordinates to mitigate the element's rotation.\n    .getPointRotatedAroundCenter(this.angle(), x, y) // Transform the absolute position into relative\n    .difference(this.position());\n  }\n\n}, {\n  getAttributeDefinition: function (attrName) {\n    var defNS = this.attributes;\n    var globalDefNS = attributes;\n    return defNS && defNS[attrName] || globalDefNS[attrName];\n  },\n  define: function (type, defaults, protoProps, staticProps) {\n    protoProps = assign({\n      defaults: defaultsDeep({\n        type: type\n      }, defaults, this.prototype.defaults)\n    }, protoProps);\n    var Cell = this.extend(protoProps, staticProps); // es5 backward compatibility\n\n    /* eslint-disable no-undef */\n\n    if (typeof joint !== 'undefined' && has(joint, 'shapes')) {\n      setByPath(joint.shapes, type, Cell, '.');\n    }\n    /* eslint-enable no-undef */\n\n\n    return Cell;\n  }\n});","map":{"version":3,"names":["Backbone","uniqueId","union","result","merge","forIn","isObject","isEqual","isString","cloneDeep","omit","uuid","isEmpty","assign","uniq","toArray","defaults","setByPath","unsetByPath","getByPath","timing","interpolate","nextFrame","without","cancelFrame","defaultsDeep","has","cloneCells","attributes","g","Cell","Model","extend","constructor","options","attrs","preinitialize","apply","arguments","cid","collection","parse","set","changed","initialize","translate","dx","dy","opt","Error","toJSON","prototype","defaultAttrs","finalAttrs","attr","selector","defaultAttr","value","name","Array","isArray","value2","name2","idAttribute","getIdAttribute","generateId","silent","_transitionIds","_scheduledTransitionIds","processPorts","on","previousPorts","ports","get","port","id","undefined","removedPorts","graph","inboundLinks","getConnectedLinks","inbound","forEach","link","remove","outboundLinks","outbound","startBatch","parentCell","getParentCell","unembed","embeddedCells","getEmbeddedCells","i","n","length","embed","trigger","cells","stopBatch","toFront","z","maxZIndex","deep","breadthFirst","unshift","shouldUpdate","indexOf","some","cell","index","toBack","minZIndex","parent","canEmbed","_embedCells","_unembedCells","every","c","isEmbeddedIn","batchName","embeds","isLink","unset","map","parentId","getCell","getAncestors","ancestors","push","queue","shift","cellId","isEmbedded","clone","concat","prop","props","delim","_isString","path","pathArray","split","join","slice","property","pathArrayLength","propertyPath","propertyValue","propertyPathArray","update","initializer","prevProperty","pathItem","isArrayIndex","Number","isFinite","baseAttributes","rewrite","removeProp","dirty","nestedPath","args","from","removeAttr","transition","duration","delay","timingFunction","linear","valueFunction","number","firstFrameTime","interpolatingFunction","setter","runtime","progress","transitionId","bind","initialId","initiator","callback","stopPendingTransitions","setTimeout","getTransitions","Object","keys","stopScheduledTransitions","transitions","filter","key","transitionIds","clearTimeout","stopTransitions","addTo","addCell","findView","paper","findViewByModel","isElement","getChangeFlag","flag","hasOwnProperty","hasChanged","angle","position","Point","getPointFromConnectedLink","getBBox","Rect","getPointRotatedAroundCenter","x","y","point","rotate","center","getAbsolutePointFromRelative","offset","getRelativePointFromAbsolute","difference","getAttributeDefinition","attrName","defNS","globalDefNS","define","type","protoProps","staticProps","joint","shapes"],"sources":["C:/Users/Admin/dataflow-test/node_modules/jointjs/src/dia/Cell.mjs"],"sourcesContent":["import Backbone from 'backbone';\nimport {\n    uniqueId,\n    union,\n    result,\n    merge,\n    forIn,\n    isObject,\n    isEqual,\n    isString,\n    cloneDeep,\n    omit,\n    uuid,\n    isEmpty,\n    assign,\n    uniq,\n    toArray,\n    defaults,\n    setByPath,\n    unsetByPath,\n    getByPath,\n    timing,\n    interpolate,\n    nextFrame,\n    without,\n    cancelFrame,\n    defaultsDeep,\n    has\n} from '../util/util.mjs';\nimport { cloneCells } from '../util/cloneCells.mjs';\nimport { attributes } from './attributes/index.mjs';\nimport * as g from '../g/index.mjs';\n\n\n// Cell base model.\n// --------------------------\n\nexport const Cell = Backbone.Model.extend({\n\n    // This is the same as Backbone.Model with the only difference that is uses util.merge\n    // instead of just _.extend. The reason is that we want to mixin attributes set in upper classes.\n    constructor: function(attributes, options) {\n\n        var defaults;\n        var attrs = attributes || {};\n        if (typeof this.preinitialize === 'function') {\n            // Check to support an older version of Backbone (prior v1.4)\n            this.preinitialize.apply(this, arguments);\n        }\n        this.cid = uniqueId('c');\n        this.attributes = {};\n        if (options && options.collection) this.collection = options.collection;\n        if (options && options.parse) attrs = this.parse(attrs, options) || {};\n        if ((defaults = result(this, 'defaults'))) {\n            //<custom code>\n            // Replaced the call to _.defaults with util.merge.\n            attrs = merge({}, defaults, attrs);\n            //</custom code>\n        }\n        this.set(attrs, options);\n        this.changed = {};\n        this.initialize.apply(this, arguments);\n    },\n\n    translate: function(dx, dy, opt) {\n\n        throw new Error('Must define a translate() method.');\n    },\n\n    toJSON: function() {\n\n        const defaults = result(this.constructor.prototype, 'defaults');\n        const defaultAttrs = defaults.attrs || {};\n        const attrs = this.attributes.attrs;\n        const finalAttrs = {};\n\n        // Loop through all the attributes and\n        // omit the default attributes as they are implicitly reconstructible by the cell 'type'.\n        forIn(attrs, function(attr, selector) {\n\n            const defaultAttr = defaultAttrs[selector];\n\n            forIn(attr, function(value, name) {\n\n                // attr is mainly flat though it might have one more level (consider the `style` attribute).\n                // Check if the `value` is object and if yes, go one level deep.\n                if (isObject(value) && !Array.isArray(value)) {\n\n                    forIn(value, function(value2, name2) {\n\n                        if (!defaultAttr || !defaultAttr[name] || !isEqual(defaultAttr[name][name2], value2)) {\n\n                            finalAttrs[selector] = finalAttrs[selector] || {};\n                            (finalAttrs[selector][name] || (finalAttrs[selector][name] = {}))[name2] = value2;\n                        }\n                    });\n\n                } else if (!defaultAttr || !isEqual(defaultAttr[name], value)) {\n                    // `value` is not an object, default attribute for such a selector does not exist\n                    // or it is different than the attribute value set on the model.\n\n                    finalAttrs[selector] = finalAttrs[selector] || {};\n                    finalAttrs[selector][name] = value;\n                }\n            });\n        });\n\n        const attributes = cloneDeep(omit(this.attributes, 'attrs'));\n        attributes.attrs = finalAttrs;\n\n        return attributes;\n    },\n\n    initialize: function(options) {\n\n        const idAttribute = this.getIdAttribute();\n        if (!options || !(idAttribute in options)) {\n            this.set(idAttribute, this.generateId(), { silent: true });\n        }\n\n        this._transitionIds = {};\n        this._scheduledTransitionIds = {};\n\n        // Collect ports defined in `attrs` and keep collecting whenever `attrs` object changes.\n        this.processPorts();\n        this.on('change:attrs', this.processPorts, this);\n    },\n\n    getIdAttribute: function() {\n        return this.idAttribute || 'id';\n    },\n\n    generateId: function() {\n        return uuid();\n    },\n\n    /**\n     * @deprecated\n     */\n    processPorts: function() {\n\n        // Whenever `attrs` changes, we extract ports from the `attrs` object and store it\n        // in a more accessible way. Also, if any port got removed and there were links that had `target`/`source`\n        // set to that port, we remove those links as well (to follow the same behaviour as\n        // with a removed element).\n\n        var previousPorts = this.ports;\n\n        // Collect ports from the `attrs` object.\n        var ports = {};\n        forIn(this.get('attrs'), function(attrs, selector) {\n\n            if (attrs && attrs.port) {\n\n                // `port` can either be directly an `id` or an object containing an `id` (and potentially other data).\n                if (attrs.port.id !== undefined) {\n                    ports[attrs.port.id] = attrs.port;\n                } else {\n                    ports[attrs.port] = { id: attrs.port };\n                }\n            }\n        });\n\n        // Collect ports that have been removed (compared to the previous ports) - if any.\n        // Use hash table for quick lookup.\n        var removedPorts = {};\n        forIn(previousPorts, function(port, id) {\n\n            if (!ports[id]) removedPorts[id] = true;\n        });\n\n        // Remove all the incoming/outgoing links that have source/target port set to any of the removed ports.\n        if (this.graph && !isEmpty(removedPorts)) {\n\n            var inboundLinks = this.graph.getConnectedLinks(this, { inbound: true });\n            inboundLinks.forEach(function(link) {\n\n                if (removedPorts[link.get('target').port]) link.remove();\n            });\n\n            var outboundLinks = this.graph.getConnectedLinks(this, { outbound: true });\n            outboundLinks.forEach(function(link) {\n\n                if (removedPorts[link.get('source').port]) link.remove();\n            });\n        }\n\n        // Update the `ports` object.\n        this.ports = ports;\n    },\n\n    remove: function(opt = {}) {\n\n        // Store the graph in a variable because `this.graph` won't be accessible\n        // after `this.trigger('remove', ...)` down below.\n        const { graph, collection } = this;\n        if (!graph) {\n            // The collection is a common Backbone collection (not the graph collection).\n            if (collection) collection.remove(this, opt);\n            return this;\n        }\n\n        graph.startBatch('remove');\n\n        // First, unembed this cell from its parent cell if there is one.\n        const parentCell = this.getParentCell();\n        if (parentCell) {\n            parentCell.unembed(this, opt);\n        }\n\n        // Remove also all the cells, which were embedded into this cell\n        const embeddedCells = this.getEmbeddedCells();\n        for (let i = 0, n = embeddedCells.length; i < n; i++) {\n            const embed = embeddedCells[i];\n            if (embed) {\n                embed.remove(opt);\n            }\n        }\n\n        this.trigger('remove', this, graph.attributes.cells, opt);\n\n        graph.stopBatch('remove');\n\n        return this;\n    },\n\n    toFront: function(opt) {\n\n        var graph = this.graph;\n        if (graph) {\n\n            opt = opt || {};\n\n            var z = graph.maxZIndex();\n\n            var cells;\n\n            if (opt.deep) {\n                cells = this.getEmbeddedCells({ deep: true, breadthFirst: opt.breadthFirst !== false });\n                cells.unshift(this);\n            } else {\n                cells = [this];\n            }\n\n            z = z - cells.length + 1;\n\n            var collection = graph.get('cells');\n            var shouldUpdate = (collection.indexOf(this) !== (collection.length - cells.length));\n            if (!shouldUpdate) {\n                shouldUpdate = cells.some(function(cell, index) {\n                    return cell.get('z') !== z + index;\n                });\n            }\n\n            if (shouldUpdate) {\n                this.startBatch('to-front');\n\n                z = z + cells.length;\n\n                cells.forEach(function(cell, index) {\n                    cell.set('z', z + index, opt);\n                });\n\n                this.stopBatch('to-front');\n            }\n        }\n\n        return this;\n    },\n\n    toBack: function(opt) {\n\n        var graph = this.graph;\n        if (graph) {\n\n            opt = opt || {};\n\n            var z = graph.minZIndex();\n\n            var cells;\n\n            if (opt.deep) {\n                cells = this.getEmbeddedCells({ deep: true, breadthFirst: opt.breadthFirst !== false });\n                cells.unshift(this);\n            } else {\n                cells = [this];\n            }\n\n            var collection = graph.get('cells');\n            var shouldUpdate = (collection.indexOf(this) !== 0);\n            if (!shouldUpdate) {\n                shouldUpdate = cells.some(function(cell, index) {\n                    return cell.get('z') !== z + index;\n                });\n            }\n\n            if (shouldUpdate) {\n                this.startBatch('to-back');\n\n                z -= cells.length;\n\n                cells.forEach(function(cell, index) {\n                    cell.set('z', z + index, opt);\n                });\n\n                this.stopBatch('to-back');\n            }\n        }\n\n        return this;\n    },\n\n    parent: function(parent, opt) {\n\n        // getter\n        if (parent === undefined) return this.get('parent');\n        // setter\n        return this.set('parent', parent, opt);\n    },\n\n    embed: function(cell, opt) {\n        const cells = Array.isArray(cell) ? cell : [cell];\n        if (!this.canEmbed(cells)) {\n            throw new Error('Recursive embedding not allowed.');\n        }\n        this._embedCells(cells, opt);\n        return this;\n    },\n\n    unembed: function(cell, opt) {\n        const cells = Array.isArray(cell) ? cell : [cell];\n        this._unembedCells(cells, opt);\n        return this;\n    },\n\n    canEmbed: function(cell) {\n        const cells = Array.isArray(cell) ? cell : [cell];\n        return cells.every(c => this !== c && !this.isEmbeddedIn(c));\n    },\n\n    _embedCells: function(cells, opt) {\n        const batchName = 'embed';\n        this.startBatch(batchName);\n        const embeds = assign([], this.get('embeds'));\n        cells.forEach(cell => {\n            // We keep all element ids after link ids.\n            embeds[cell.isLink() ? 'unshift' : 'push'](cell.id);\n            cell.parent(this.id, opt);\n        });\n        this.set('embeds', uniq(embeds), opt);\n        this.stopBatch(batchName);\n    },\n\n    _unembedCells: function(cells, opt) {\n        const batchName = 'unembed';\n        this.startBatch(batchName);\n        cells.forEach(cell => cell.unset('parent', opt));\n        this.set('embeds', without(this.get('embeds'), ...cells.map(cell => cell.id)), opt);\n        this.stopBatch(batchName);\n    },\n\n    getParentCell: function() {\n\n        // unlike link.source/target, cell.parent stores id directly as a string\n        var parentId = this.parent();\n        var graph = this.graph;\n\n        return (parentId && graph && graph.getCell(parentId)) || null;\n    },\n\n    // Return an array of ancestor cells.\n    // The array is ordered from the parent of the cell\n    // to the most distant ancestor.\n    getAncestors: function() {\n\n        var ancestors = [];\n\n        if (!this.graph) {\n            return ancestors;\n        }\n\n        var parentCell = this.getParentCell();\n        while (parentCell) {\n            ancestors.push(parentCell);\n            parentCell = parentCell.getParentCell();\n        }\n\n        return ancestors;\n    },\n\n    getEmbeddedCells: function(opt) {\n\n        opt = opt || {};\n\n        // Cell models can only be retrieved when this element is part of a collection.\n        // There is no way this element knows about other cells otherwise.\n        // This also means that calling e.g. `translate()` on an element with embeds before\n        // adding it to a graph does not translate its embeds.\n        if (this.graph) {\n\n            var cells;\n\n            if (opt.deep) {\n\n                if (opt.breadthFirst) {\n\n                    // breadthFirst algorithm\n                    cells = [];\n                    var queue = this.getEmbeddedCells();\n\n                    while (queue.length > 0) {\n\n                        var parent = queue.shift();\n                        cells.push(parent);\n                        queue.push.apply(queue, parent.getEmbeddedCells());\n                    }\n\n                } else {\n\n                    // depthFirst algorithm\n                    cells = this.getEmbeddedCells();\n                    cells.forEach(function(cell) {\n                        cells.push.apply(cells, cell.getEmbeddedCells(opt));\n                    });\n                }\n\n            } else {\n\n                cells = toArray(this.get('embeds')).map(this.graph.getCell, this.graph);\n            }\n\n            return cells;\n        }\n        return [];\n    },\n\n    isEmbeddedIn: function(cell, opt) {\n\n        var cellId = isString(cell) ? cell : cell.id;\n        var parentId = this.parent();\n\n        opt = defaults({ deep: true }, opt);\n\n        // See getEmbeddedCells().\n        if (this.graph && opt.deep) {\n\n            while (parentId) {\n                if (parentId === cellId) {\n                    return true;\n                }\n                parentId = this.graph.getCell(parentId).parent();\n            }\n\n            return false;\n\n        } else {\n\n            // When this cell is not part of a collection check\n            // at least whether it's a direct child of given cell.\n            return parentId === cellId;\n        }\n    },\n\n    // Whether or not the cell is embedded in any other cell.\n    isEmbedded: function() {\n\n        return !!this.parent();\n    },\n\n    // Isolated cloning. Isolated cloning has two versions: shallow and deep (pass `{ deep: true }` in `opt`).\n    // Shallow cloning simply clones the cell and returns a new cell with different ID.\n    // Deep cloning clones the cell and all its embedded cells recursively.\n    clone: function(opt) {\n\n        opt = opt || {};\n\n        if (!opt.deep) {\n            // Shallow cloning.\n\n            var clone = Backbone.Model.prototype.clone.apply(this, arguments);\n            // We don't want the clone to have the same ID as the original.\n            clone.set(this.getIdAttribute(), this.generateId());\n            // A shallow cloned element does not carry over the original embeds.\n            clone.unset('embeds');\n            // And can not be embedded in any cell\n            // as the clone is not part of the graph.\n            clone.unset('parent');\n\n            return clone;\n\n        } else {\n            // Deep cloning.\n\n            // For a deep clone, simply call `graph.cloneCells()` with the cell and all its embedded cells.\n            return toArray(cloneCells([this].concat(this.getEmbeddedCells({ deep: true }))));\n        }\n    },\n\n    // A convenient way to set nested properties.\n    // This method merges the properties you'd like to set with the ones\n    // stored in the cell and makes sure change events are properly triggered.\n    // You can either set a nested property with one object\n    // or use a property path.\n    // The most simple use case is:\n    // `cell.prop('name/first', 'John')` or\n    // `cell.prop({ name: { first: 'John' } })`.\n    // Nested arrays are supported too:\n    // `cell.prop('series/0/data/0/degree', 50)` or\n    // `cell.prop({ series: [ { data: [ { degree: 50 } ] } ] })`.\n    prop: function(props, value, opt) {\n\n        var delim = '/';\n        var _isString = isString(props);\n\n        if (_isString || Array.isArray(props)) {\n            // Get/set an attribute by a special path syntax that delimits\n            // nested objects by the colon character.\n\n            if (arguments.length > 1) {\n\n                var path;\n                var pathArray;\n\n                if (_isString) {\n                    path = props;\n                    pathArray = path.split('/');\n                } else {\n                    path = props.join(delim);\n                    pathArray = props.slice();\n                }\n\n                var property = pathArray[0];\n                var pathArrayLength = pathArray.length;\n\n                opt = opt || {};\n                opt.propertyPath = path;\n                opt.propertyValue = value;\n                opt.propertyPathArray = pathArray;\n\n                if (pathArrayLength === 1) {\n                    // Property is not nested. We can simply use `set()`.\n                    return this.set(property, value, opt);\n                }\n\n                var update = {};\n                // Initialize the nested object. Subobjects are either arrays or objects.\n                // An empty array is created if the sub-key is an integer. Otherwise, an empty object is created.\n                // Note that this imposes a limitation on object keys one can use with Inspector.\n                // Pure integer keys will cause issues and are therefore not allowed.\n                var initializer = update;\n                var prevProperty = property;\n\n                for (var i = 1; i < pathArrayLength; i++) {\n                    var pathItem = pathArray[i];\n                    var isArrayIndex = Number.isFinite(_isString ? Number(pathItem) : pathItem);\n                    initializer = initializer[prevProperty] = isArrayIndex ? [] : {};\n                    prevProperty = pathItem;\n                }\n\n                // Fill update with the `value` on `path`.\n                update = setByPath(update, pathArray, value, '/');\n\n                var baseAttributes = merge({}, this.attributes);\n                // if rewrite mode enabled, we replace value referenced by path with\n                // the new one (we don't merge).\n                opt.rewrite && unsetByPath(baseAttributes, path, '/');\n\n                // Merge update with the model attributes.\n                var attributes = merge(baseAttributes, update);\n                // Finally, set the property to the updated attributes.\n                return this.set(property, attributes[property], opt);\n\n            } else {\n\n                return getByPath(this.attributes, props, delim);\n            }\n        }\n\n        return this.set(merge({}, this.attributes, props), value);\n    },\n\n    // A convenient way to unset nested properties\n    removeProp: function(path, opt) {\n\n        opt = opt || {};\n\n        var pathArray = Array.isArray(path) ? path : path.split('/');\n\n        // Once a property is removed from the `attrs` attribute\n        // the cellView will recognize a `dirty` flag and re-render itself\n        // in order to remove the attribute from SVG element.\n        var property = pathArray[0];\n        if (property === 'attrs') opt.dirty = true;\n\n        if (pathArray.length === 1) {\n            // A top level property\n            return this.unset(path, opt);\n        }\n\n        // A nested property\n        var nestedPath = pathArray.slice(1);\n        var propertyValue = cloneDeep(this.get(property));\n\n        unsetByPath(propertyValue, nestedPath, '/');\n\n        return this.set(property, propertyValue, opt);\n    },\n\n    // A convenient way to set nested attributes.\n    attr: function(attrs, value, opt) {\n\n        var args = Array.from(arguments);\n        if (args.length === 0) {\n            return this.get('attrs');\n        }\n\n        if (Array.isArray(attrs)) {\n            args[0] = ['attrs'].concat(attrs);\n        } else if (isString(attrs)) {\n            // Get/set an attribute by a special path syntax that delimits\n            // nested objects by the colon character.\n            args[0] = 'attrs/' + attrs;\n\n        } else {\n\n            args[0] = { 'attrs' : attrs };\n        }\n\n        return this.prop.apply(this, args);\n    },\n\n    // A convenient way to unset nested attributes\n    removeAttr: function(path, opt) {\n\n        if (Array.isArray(path)) {\n\n            return this.removeProp(['attrs'].concat(path));\n        }\n\n        return this.removeProp('attrs/' + path, opt);\n    },\n\n    transition: function(path, value, opt, delim) {\n\n        delim = delim || '/';\n\n        var defaults = {\n            duration: 100,\n            delay: 10,\n            timingFunction: timing.linear,\n            valueFunction: interpolate.number\n        };\n\n        opt = assign(defaults, opt);\n\n        var firstFrameTime = 0;\n        var interpolatingFunction;\n\n        var setter = function(runtime) {\n\n            var id, progress, propertyValue;\n\n            firstFrameTime = firstFrameTime || runtime;\n            runtime -= firstFrameTime;\n            progress = runtime / opt.duration;\n\n            if (progress < 1) {\n                this._transitionIds[path] = id = nextFrame(setter);\n            } else {\n                progress = 1;\n                delete this._transitionIds[path];\n            }\n\n            propertyValue = interpolatingFunction(opt.timingFunction(progress));\n\n            opt.transitionId = id;\n\n            this.prop(path, propertyValue, opt);\n\n            if (!id) this.trigger('transition:end', this, path);\n\n        }.bind(this);\n\n        const { _scheduledTransitionIds } = this;\n        let initialId;\n\n        var initiator = (callback) => {\n\n            if (_scheduledTransitionIds[path]) {\n                _scheduledTransitionIds[path] = without(_scheduledTransitionIds[path], initialId);\n                if (_scheduledTransitionIds[path].length === 0) {\n                    delete _scheduledTransitionIds[path];\n                }\n            }\n\n            this.stopPendingTransitions(path, delim);\n\n            interpolatingFunction = opt.valueFunction(getByPath(this.attributes, path, delim), value);\n\n            this._transitionIds[path] = nextFrame(callback);\n\n            this.trigger('transition:start', this, path);\n\n        };\n\n        initialId = setTimeout(initiator, opt.delay, setter);\n\n        _scheduledTransitionIds[path] || (_scheduledTransitionIds[path] = []);\n        _scheduledTransitionIds[path].push(initialId);\n\n        return initialId;\n    },\n\n    getTransitions: function() {\n        return union(\n            Object.keys(this._transitionIds),\n            Object.keys(this._scheduledTransitionIds)\n        );\n    },\n\n    stopScheduledTransitions: function(path, delim = '/') {\n        const { _scheduledTransitionIds = {}} = this;\n        let transitions = Object.keys(_scheduledTransitionIds);\n        if (path) {\n            const pathArray = path.split(delim);\n            transitions = transitions.filter((key) => {\n                return isEqual(pathArray, key.split(delim).slice(0, pathArray.length));\n            });\n        }\n        transitions.forEach((key) => {\n            const transitionIds = _scheduledTransitionIds[key];\n            // stop the initiator\n            transitionIds.forEach(transitionId => clearTimeout(transitionId));\n            delete _scheduledTransitionIds[key];\n            // Note: we could trigger transition:cancel` event here\n        });\n        return this;\n    },\n\n    stopPendingTransitions(path, delim = '/') {\n        const { _transitionIds = {}} = this;\n        let transitions = Object.keys(_transitionIds);\n        if (path) {\n            const pathArray = path.split(delim);\n            transitions = transitions.filter((key) => {\n                return isEqual(pathArray, key.split(delim).slice(0, pathArray.length));\n            });\n        }\n        transitions.forEach((key) => {\n            const transitionId = _transitionIds[key];\n            // stop the setter\n            cancelFrame(transitionId);\n            delete _transitionIds[key];\n            this.trigger('transition:end', this, key);\n        });\n    },\n\n    stopTransitions: function(path, delim = '/') {\n        this.stopScheduledTransitions(path, delim);\n        this.stopPendingTransitions(path, delim);\n        return this;\n    },\n\n    // A shorcut making it easy to create constructs like the following:\n    // `var el = (new joint.shapes.basic.Rect).addTo(graph)`.\n    addTo: function(graph, opt) {\n\n        graph.addCell(this, opt);\n        return this;\n    },\n\n    // A shortcut for an equivalent call: `paper.findViewByModel(cell)`\n    // making it easy to create constructs like the following:\n    // `cell.findView(paper).highlight()`\n    findView: function(paper) {\n\n        return paper.findViewByModel(this);\n    },\n\n    isElement: function() {\n\n        return false;\n    },\n\n    isLink: function() {\n\n        return false;\n    },\n\n    startBatch: function(name, opt) {\n\n        if (this.graph) { this.graph.startBatch(name, assign({}, opt, { cell: this })); }\n        return this;\n    },\n\n    stopBatch: function(name, opt) {\n\n        if (this.graph) { this.graph.stopBatch(name, assign({}, opt, { cell: this })); }\n        return this;\n    },\n\n    getChangeFlag: function(attributes) {\n\n        var flag = 0;\n        if (!attributes) return flag;\n        for (var key in attributes) {\n            if (!attributes.hasOwnProperty(key) || !this.hasChanged(key)) continue;\n            flag |= attributes[key];\n        }\n        return flag;\n    },\n\n    angle: function() {\n\n        // To be overridden.\n        return 0;\n    },\n\n    position: function() {\n\n        // To be overridden.\n        return new g.Point(0, 0);\n    },\n\n    getPointFromConnectedLink: function() {\n\n        // To be overridden\n        return new g.Point();\n    },\n\n    getBBox: function() {\n\n        // To be overridden\n        return new g.Rect(0, 0, 0, 0);\n    },\n\n    getPointRotatedAroundCenter(angle, x, y) {\n        const point = new g.Point(x, y);\n        if (angle) point.rotate(this.getBBox().center(), angle);\n        return point;\n    },\n\n    getAbsolutePointFromRelative(x, y) {\n        // Rotate the position to take the model angle into account\n        return this.getPointRotatedAroundCenter(\n            -this.angle(),\n            // Transform the relative position to absolute\n            this.position().offset(x, y)\n        );\n    },\n\n    getRelativePointFromAbsolute(x, y) {\n        return this\n            // Rotate the coordinates to mitigate the element's rotation.\n            .getPointRotatedAroundCenter(this.angle(), x, y)\n            // Transform the absolute position into relative\n            .difference(this.position());\n    }\n\n}, {\n\n    getAttributeDefinition: function(attrName) {\n\n        var defNS = this.attributes;\n        var globalDefNS = attributes;\n        return (defNS && defNS[attrName]) || globalDefNS[attrName];\n    },\n\n    define: function(type, defaults, protoProps, staticProps) {\n\n        protoProps = assign({\n            defaults: defaultsDeep({ type: type }, defaults, this.prototype.defaults)\n        }, protoProps);\n\n        var Cell = this.extend(protoProps, staticProps);\n        // es5 backward compatibility\n        /* eslint-disable no-undef */\n        if (typeof joint !== 'undefined' && has(joint, 'shapes')) {\n            setByPath(joint.shapes, type, Cell, '.');\n        }\n        /* eslint-enable no-undef */\n        return Cell;\n    }\n});\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}