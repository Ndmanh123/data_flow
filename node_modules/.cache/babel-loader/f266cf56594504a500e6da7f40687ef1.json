{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport * as g from '../g/index.mjs';\nimport * as util from '../util/index.mjs';\nimport { orthogonal } from './orthogonal.mjs';\nvar config = {\n  // size of the step to find a route (the grid of the manhattan pathfinder)\n  step: 10,\n  // the number of route finding loops that cause the router to abort\n  // returns fallback route instead\n  maximumLoops: 2000,\n  // the number of decimal places to round floating point coordinates\n  precision: 1,\n  // maximum change of direction\n  maxAllowedDirectionChange: 90,\n  // should the router use perpendicular linkView option?\n  // does not connect anchor of element but rather a point close-by that is orthogonal\n  // this looks much better\n  perpendicular: true,\n  // should the source and/or target not be considered as obstacles?\n  excludeEnds: [],\n  // 'source', 'target'\n  // should certain types of elements not be considered as obstacles?\n  excludeTypes: ['basic.Text'],\n  // possible starting directions from an element\n  startDirections: ['top', 'right', 'bottom', 'left'],\n  // possible ending directions to an element\n  endDirections: ['top', 'right', 'bottom', 'left'],\n  // specify the directions used above and what they mean\n  directionMap: {\n    top: {\n      x: 0,\n      y: -1\n    },\n    right: {\n      x: 1,\n      y: 0\n    },\n    bottom: {\n      x: 0,\n      y: 1\n    },\n    left: {\n      x: -1,\n      y: 0\n    }\n  },\n  // cost of an orthogonal step\n  cost: function () {\n    return this.step;\n  },\n  // an array of directions to find next points on the route\n  // different from start/end directions\n  directions: function () {\n    var step = this.step;\n    var cost = this.cost();\n    return [{\n      offsetX: step,\n      offsetY: 0,\n      cost: cost\n    }, {\n      offsetX: -step,\n      offsetY: 0,\n      cost: cost\n    }, {\n      offsetX: 0,\n      offsetY: step,\n      cost: cost\n    }, {\n      offsetX: 0,\n      offsetY: -step,\n      cost: cost\n    }];\n  },\n  // a penalty received for direction change\n  penalties: function () {\n    return {\n      0: 0,\n      45: this.step / 2,\n      90: this.step / 2\n    };\n  },\n  // padding applied on the element bounding boxes\n  paddingBox: function () {\n    var step = this.step;\n    return {\n      x: -step,\n      y: -step,\n      width: 2 * step,\n      height: 2 * step\n    };\n  },\n  // A function that determines whether a given point is an obstacle or not.\n  // If used, the `padding`, `excludeEnds`and `excludeTypes` options are ignored.\n  // (point: dia.Point) => boolean;\n  isPointObstacle: null,\n  // a router to use when the manhattan router fails\n  // (one of the partial routes returns null)\n  fallbackRouter: function (vertices, opt, linkView) {\n    if (!util.isFunction(orthogonal)) {\n      throw new Error('Manhattan requires the orthogonal router as default fallback.');\n    }\n\n    return orthogonal(vertices, util.assign({}, config, opt), linkView);\n  },\n\n  /* Deprecated */\n  // a simple route used in situations when main routing method fails\n  // (exceed max number of loop iterations, inaccessible)\n  fallbackRoute: function (from, to, opt) {\n    return null; // null result will trigger the fallbackRouter\n    // left for reference:\n\n    /*// Find an orthogonal route ignoring obstacles.\n     var point = ((opt.previousDirAngle || 0) % 180 === 0)\n            ? new g.Point(from.x, to.y)\n            : new g.Point(to.x, from.y);\n     return [point];*/\n  },\n  // if a function is provided, it's used to route the link while dragging an end\n  // i.e. function(from, to, opt) { return []; }\n  draggingRoute: null\n}; // HELPER CLASSES //\n// Map of obstacles\n// Helper structure to identify whether a point lies inside an obstacle.\n\nfunction ObstacleMap(opt) {\n  this.map = {};\n  this.options = opt; // tells how to divide the paper when creating the elements map\n\n  this.mapGridSize = 100;\n}\n\nObstacleMap.prototype.build = function (graph, link) {\n  var opt = this.options; // source or target element could be excluded from set of obstacles\n\n  var excludedEnds = util.toArray(opt.excludeEnds).reduce(function (res, item) {\n    var end = link.get(item);\n\n    if (end) {\n      var cell = graph.getCell(end.id);\n\n      if (cell) {\n        res.push(cell);\n      }\n    }\n\n    return res;\n  }, []); // Exclude any embedded elements from the source and the target element.\n\n  var excludedAncestors = [];\n  var source = graph.getCell(link.get('source').id);\n\n  if (source) {\n    excludedAncestors = util.union(excludedAncestors, source.getAncestors().map(function (cell) {\n      return cell.id;\n    }));\n  }\n\n  var target = graph.getCell(link.get('target').id);\n\n  if (target) {\n    excludedAncestors = util.union(excludedAncestors, target.getAncestors().map(function (cell) {\n      return cell.id;\n    }));\n  } // Builds a map of all elements for quicker obstacle queries (i.e. is a point contained\n  // in any obstacle?) (a simplified grid search).\n  // The paper is divided into smaller cells, where each holds information about which\n  // elements belong to it. When we query whether a point lies inside an obstacle we\n  // don't need to go through all obstacles, we check only those in a particular cell.\n\n\n  var mapGridSize = this.mapGridSize;\n  graph.getElements().reduce(function (map, element) {\n    var isExcludedType = util.toArray(opt.excludeTypes).includes(element.get('type'));\n    var isExcludedEnd = excludedEnds.find(function (excluded) {\n      return excluded.id === element.id;\n    });\n    var isExcludedAncestor = excludedAncestors.includes(element.id);\n    var isExcluded = isExcludedType || isExcludedEnd || isExcludedAncestor;\n\n    if (!isExcluded) {\n      var bbox = element.getBBox().moveAndExpand(opt.paddingBox);\n      var origin = bbox.origin().snapToGrid(mapGridSize);\n      var corner = bbox.corner().snapToGrid(mapGridSize);\n\n      for (var x = origin.x; x <= corner.x; x += mapGridSize) {\n        for (var y = origin.y; y <= corner.y; y += mapGridSize) {\n          var gridKey = x + '@' + y;\n          map[gridKey] = map[gridKey] || [];\n          map[gridKey].push(bbox);\n        }\n      }\n    }\n\n    return map;\n  }, this.map);\n  return this;\n};\n\nObstacleMap.prototype.isPointAccessible = function (point) {\n  var mapKey = point.clone().snapToGrid(this.mapGridSize).toString();\n  return util.toArray(this.map[mapKey]).every(function (obstacle) {\n    return !obstacle.containsPoint(point);\n  });\n}; // Sorted Set\n// Set of items sorted by given value.\n\n\nfunction SortedSet() {\n  this.items = [];\n  this.hash = {};\n  this.values = {};\n  this.OPEN = 1;\n  this.CLOSE = 2;\n}\n\nSortedSet.prototype.add = function (item, value) {\n  if (this.hash[item]) {\n    // item removal\n    this.items.splice(this.items.indexOf(item), 1);\n  } else {\n    this.hash[item] = this.OPEN;\n  }\n\n  this.values[item] = value;\n  var index = util.sortedIndex(this.items, item, function (i) {\n    return this.values[i];\n  }.bind(this));\n  this.items.splice(index, 0, item);\n};\n\nSortedSet.prototype.remove = function (item) {\n  this.hash[item] = this.CLOSE;\n};\n\nSortedSet.prototype.isOpen = function (item) {\n  return this.hash[item] === this.OPEN;\n};\n\nSortedSet.prototype.isClose = function (item) {\n  return this.hash[item] === this.CLOSE;\n};\n\nSortedSet.prototype.isEmpty = function () {\n  return this.items.length === 0;\n};\n\nSortedSet.prototype.pop = function () {\n  var item = this.items.shift();\n  this.remove(item);\n  return item;\n}; // HELPERS //\n// return source bbox\n\n\nfunction getSourceBBox(linkView, opt) {\n  // expand by padding box\n  if (opt && opt.paddingBox) return linkView.sourceBBox.clone().moveAndExpand(opt.paddingBox);\n  return linkView.sourceBBox.clone();\n} // return target bbox\n\n\nfunction getTargetBBox(linkView, opt) {\n  // expand by padding box\n  if (opt && opt.paddingBox) return linkView.targetBBox.clone().moveAndExpand(opt.paddingBox);\n  return linkView.targetBBox.clone();\n} // return source anchor\n\n\nfunction getSourceAnchor(linkView, opt) {\n  if (linkView.sourceAnchor) return linkView.sourceAnchor; // fallback: center of bbox\n\n  var sourceBBox = getSourceBBox(linkView, opt);\n  return sourceBBox.center();\n} // return target anchor\n\n\nfunction getTargetAnchor(linkView, opt) {\n  if (linkView.targetAnchor) return linkView.targetAnchor; // fallback: center of bbox\n\n  var targetBBox = getTargetBBox(linkView, opt);\n  return targetBBox.center(); // default\n} // returns a direction index from start point to end point\n// corrects for grid deformation between start and end\n\n\nfunction getDirectionAngle(start, end, numDirections, grid, opt) {\n  var quadrant = 360 / numDirections;\n  var angleTheta = start.theta(fixAngleEnd(start, end, grid, opt));\n  var normalizedAngle = g.normalizeAngle(angleTheta + quadrant / 2);\n  return quadrant * Math.floor(normalizedAngle / quadrant);\n} // helper function for getDirectionAngle()\n// corrects for grid deformation\n// (if a point is one grid steps away from another in both dimensions,\n// it is considered to be 45 degrees away, even if the real angle is different)\n// this causes visible angle discrepancies if `opt.step` is much larger than `paper.gridSize`\n\n\nfunction fixAngleEnd(start, end, grid, opt) {\n  var step = opt.step;\n  var diffX = end.x - start.x;\n  var diffY = end.y - start.y;\n  var gridStepsX = diffX / grid.x;\n  var gridStepsY = diffY / grid.y;\n  var distanceX = gridStepsX * step;\n  var distanceY = gridStepsY * step;\n  return new g.Point(start.x + distanceX, start.y + distanceY);\n} // return the change in direction between two direction angles\n\n\nfunction getDirectionChange(angle1, angle2) {\n  var directionChange = Math.abs(angle1 - angle2);\n  return directionChange > 180 ? 360 - directionChange : directionChange;\n} // fix direction offsets according to current grid\n\n\nfunction getGridOffsets(directions, grid, opt) {\n  var step = opt.step;\n  util.toArray(opt.directions).forEach(function (direction) {\n    direction.gridOffsetX = direction.offsetX / step * grid.x;\n    direction.gridOffsetY = direction.offsetY / step * grid.y;\n  });\n} // get grid size in x and y dimensions, adapted to source and target positions\n\n\nfunction getGrid(step, source, target) {\n  return {\n    source: source.clone(),\n    x: getGridDimension(target.x - source.x, step),\n    y: getGridDimension(target.y - source.y, step)\n  };\n} // helper function for getGrid()\n\n\nfunction getGridDimension(diff, step) {\n  // return step if diff = 0\n  if (!diff) return step;\n  var absDiff = Math.abs(diff);\n  var numSteps = Math.round(absDiff / step); // return absDiff if less than one step apart\n\n  if (!numSteps) return absDiff; // otherwise, return corrected step\n\n  var roundedDiff = numSteps * step;\n  var remainder = absDiff - roundedDiff;\n  var stepCorrection = remainder / numSteps;\n  return step + stepCorrection;\n} // return a clone of point snapped to grid\n\n\nfunction snapToGrid(point, grid) {\n  var source = grid.source;\n  var snappedX = g.snapToGrid(point.x - source.x, grid.x) + source.x;\n  var snappedY = g.snapToGrid(point.y - source.y, grid.y) + source.y;\n  return new g.Point(snappedX, snappedY);\n} // round the point to opt.precision\n\n\nfunction round(point, precision) {\n  return point.round(precision);\n} // snap to grid and then round the point\n\n\nfunction align(point, grid, precision) {\n  return round(snapToGrid(point.clone(), grid), precision);\n} // return a string representing the point\n// string is rounded in both dimensions\n\n\nfunction getKey(point) {\n  return point.clone().toString();\n} // return a normalized vector from given point\n// used to determine the direction of a difference of two points\n\n\nfunction normalizePoint(point) {\n  return new g.Point(point.x === 0 ? 0 : Math.abs(point.x) / point.x, point.y === 0 ? 0 : Math.abs(point.y) / point.y);\n} // PATHFINDING //\n// reconstructs a route by concatenating points with their parents\n\n\nfunction reconstructRoute(parents, points, tailPoint, from, to, grid, opt) {\n  var route = [];\n  var prevDiff = normalizePoint(to.difference(tailPoint)); // tailPoint is assumed to be aligned already\n\n  var currentKey = getKey(tailPoint);\n  var parent = parents[currentKey];\n  var point;\n\n  while (parent) {\n    // point is assumed to be aligned already\n    point = points[currentKey];\n    var diff = normalizePoint(point.difference(parent));\n\n    if (!diff.equals(prevDiff)) {\n      route.unshift(point);\n      prevDiff = diff;\n    } // parent is assumed to be aligned already\n\n\n    currentKey = getKey(parent);\n    parent = parents[currentKey];\n  } // leadPoint is assumed to be aligned already\n\n\n  var leadPoint = points[currentKey];\n  var fromDiff = normalizePoint(leadPoint.difference(from));\n\n  if (!fromDiff.equals(prevDiff)) {\n    route.unshift(leadPoint);\n  }\n\n  return route;\n} // heuristic method to determine the distance between two points\n\n\nfunction estimateCost(from, endPoints) {\n  var min = Infinity;\n\n  for (var i = 0, len = endPoints.length; i < len; i++) {\n    var cost = from.manhattanDistance(endPoints[i]);\n    if (cost < min) min = cost;\n  }\n\n  return min;\n} // find points around the bbox taking given directions into account\n// lines are drawn from anchor in given directions, intersections recorded\n// if anchor is outside bbox, only those directions that intersect get a rect point\n// the anchor itself is returned as rect point (representing some directions)\n// (since those directions are unobstructed by the bbox)\n\n\nfunction getRectPoints(anchor, bbox, directionList, grid, opt) {\n  var precision = opt.precision;\n  var directionMap = opt.directionMap;\n  var anchorCenterVector = anchor.difference(bbox.center());\n  var keys = util.isObject(directionMap) ? Object.keys(directionMap) : [];\n  var dirList = util.toArray(directionList);\n  var rectPoints = keys.reduce(function (res, key) {\n    if (dirList.includes(key)) {\n      var direction = directionMap[key]; // create a line that is guaranteed to intersect the bbox if bbox is in the direction\n      // even if anchor lies outside of bbox\n\n      var endpoint = new g.Point(anchor.x + direction.x * (Math.abs(anchorCenterVector.x) + bbox.width), anchor.y + direction.y * (Math.abs(anchorCenterVector.y) + bbox.height));\n      var intersectionLine = new g.Line(anchor, endpoint); // get the farther intersection, in case there are two\n      // (that happens if anchor lies next to bbox)\n\n      var intersections = intersectionLine.intersect(bbox) || [];\n      var numIntersections = intersections.length;\n      var farthestIntersectionDistance;\n      var farthestIntersection = null;\n\n      for (var i = 0; i < numIntersections; i++) {\n        var currentIntersection = intersections[i];\n        var distance = anchor.squaredDistance(currentIntersection);\n\n        if (farthestIntersectionDistance === undefined || distance > farthestIntersectionDistance) {\n          farthestIntersectionDistance = distance;\n          farthestIntersection = currentIntersection;\n        }\n      } // if an intersection was found in this direction, it is our rectPoint\n\n\n      if (farthestIntersection) {\n        var point = align(farthestIntersection, grid, precision); // if the rectPoint lies inside the bbox, offset it by one more step\n\n        if (bbox.containsPoint(point)) {\n          point = align(point.offset(direction.x * grid.x, direction.y * grid.y), grid, precision);\n        } // then add the point to the result array\n        // aligned\n\n\n        res.push(point);\n      }\n    }\n\n    return res;\n  }, []); // if anchor lies outside of bbox, add it to the array of points\n\n  if (!bbox.containsPoint(anchor)) {\n    // aligned\n    rectPoints.push(align(anchor, grid, precision));\n  }\n\n  return rectPoints;\n} // finds the route between two points/rectangles (`from`, `to`) implementing A* algorithm\n// rectangles get rect points assigned by getRectPoints()\n\n\nfunction findRoute(from, to, isPointObstacle, opt) {\n  var precision = opt.precision; // Get grid for this route.\n\n  var sourceAnchor, targetAnchor;\n\n  if (from instanceof g.Rect) {\n    // `from` is sourceBBox\n    sourceAnchor = round(getSourceAnchor(this, opt).clone(), precision);\n  } else {\n    sourceAnchor = round(from.clone(), precision);\n  }\n\n  if (to instanceof g.Rect) {\n    // `to` is targetBBox\n    targetAnchor = round(getTargetAnchor(this, opt).clone(), precision);\n  } else {\n    targetAnchor = round(to.clone(), precision);\n  }\n\n  var grid = getGrid(opt.step, sourceAnchor, targetAnchor); // Get pathfinding points.\n\n  var start, end; // aligned with grid by definition\n\n  var startPoints, endPoints; // assumed to be aligned with grid already\n  // set of points we start pathfinding from\n\n  if (from instanceof g.Rect) {\n    // `from` is sourceBBox\n    start = sourceAnchor;\n    startPoints = getRectPoints(start, from, opt.startDirections, grid, opt);\n  } else {\n    start = sourceAnchor;\n    startPoints = [start];\n  } // set of points we want the pathfinding to finish at\n\n\n  if (to instanceof g.Rect) {\n    // `to` is targetBBox\n    end = targetAnchor;\n    endPoints = getRectPoints(targetAnchor, to, opt.endDirections, grid, opt);\n  } else {\n    end = targetAnchor;\n    endPoints = [end];\n  } // take into account only accessible rect points (those not under obstacles)\n\n\n  startPoints = startPoints.filter(p => !isPointObstacle(p));\n  endPoints = endPoints.filter(p => !isPointObstacle(p)); // Check that there is an accessible route point on both sides.\n  // Otherwise, use fallbackRoute().\n\n  if (startPoints.length > 0 && endPoints.length > 0) {\n    // The set of tentative points to be evaluated, initially containing the start points.\n    // Rounded to nearest integer for simplicity.\n    var openSet = new SortedSet(); // Keeps reference to actual points for given elements of the open set.\n\n    var points = {}; // Keeps reference to a point that is immediate predecessor of given element.\n\n    var parents = {}; // Cost from start to a point along best known path.\n\n    var costs = {};\n\n    for (var i = 0, n = startPoints.length; i < n; i++) {\n      // startPoint is assumed to be aligned already\n      var startPoint = startPoints[i];\n      var key = getKey(startPoint);\n      openSet.add(key, estimateCost(startPoint, endPoints));\n      points[key] = startPoint;\n      costs[key] = 0;\n    }\n\n    var previousRouteDirectionAngle = opt.previousDirectionAngle; // undefined for first route\n\n    var isPathBeginning = previousRouteDirectionAngle === undefined; // directions\n\n    var direction, directionChange;\n    var directions = opt.directions;\n    getGridOffsets(directions, grid, opt);\n    var numDirections = directions.length;\n    var endPointsKeys = util.toArray(endPoints).reduce(function (res, endPoint) {\n      // endPoint is assumed to be aligned already\n      var key = getKey(endPoint);\n      res.push(key);\n      return res;\n    }, []); // main route finding loop\n\n    var loopsRemaining = opt.maximumLoops;\n\n    while (!openSet.isEmpty() && loopsRemaining > 0) {\n      // remove current from the open list\n      var currentKey = openSet.pop();\n      var currentPoint = points[currentKey];\n      var currentParent = parents[currentKey];\n      var currentCost = costs[currentKey];\n      var isRouteBeginning = currentParent === undefined; // undefined for route starts\n\n      var isStart = currentPoint.equals(start); // (is source anchor or `from` point) = can leave in any direction\n\n      var previousDirectionAngle;\n      if (!isRouteBeginning) previousDirectionAngle = getDirectionAngle(currentParent, currentPoint, numDirections, grid, opt); // a vertex on the route\n      else if (!isPathBeginning) previousDirectionAngle = previousRouteDirectionAngle; // beginning of route on the path\n      else if (!isStart) previousDirectionAngle = getDirectionAngle(start, currentPoint, numDirections, grid, opt); // beginning of path, start rect point\n      else previousDirectionAngle = null; // beginning of path, source anchor or `from` point\n      // check if we reached any endpoint\n\n      var samePoints = startPoints.length === endPoints.length;\n\n      if (samePoints) {\n        for (var j = 0; j < startPoints.length; j++) {\n          if (!startPoints[j].equals(endPoints[j])) {\n            samePoints = false;\n            break;\n          }\n        }\n      }\n\n      var skipEndCheck = isRouteBeginning && samePoints;\n\n      if (!skipEndCheck && endPointsKeys.indexOf(currentKey) >= 0) {\n        opt.previousDirectionAngle = previousDirectionAngle;\n        return reconstructRoute(parents, points, currentPoint, start, end, grid, opt);\n      } // go over all possible directions and find neighbors\n\n\n      for (i = 0; i < numDirections; i++) {\n        direction = directions[i];\n        var directionAngle = direction.angle;\n        directionChange = getDirectionChange(previousDirectionAngle, directionAngle); // if the direction changed rapidly, don't use this point\n        // any direction is allowed for starting points\n\n        if (!(isPathBeginning && isStart) && directionChange > opt.maxAllowedDirectionChange) continue;\n        var neighborPoint = align(currentPoint.clone().offset(direction.gridOffsetX, direction.gridOffsetY), grid, precision);\n        var neighborKey = getKey(neighborPoint); // Closed points from the openSet were already evaluated.\n\n        if (openSet.isClose(neighborKey) || isPointObstacle(neighborPoint)) continue; // We can only enter end points at an acceptable angle.\n\n        if (endPointsKeys.indexOf(neighborKey) >= 0) {\n          // neighbor is an end point\n          var isNeighborEnd = neighborPoint.equals(end); // (is target anchor or `to` point) = can be entered in any direction\n\n          if (!isNeighborEnd) {\n            var endDirectionAngle = getDirectionAngle(neighborPoint, end, numDirections, grid, opt);\n            var endDirectionChange = getDirectionChange(directionAngle, endDirectionAngle);\n            if (endDirectionChange > opt.maxAllowedDirectionChange) continue;\n          }\n        } // The current direction is ok.\n\n\n        var neighborCost = direction.cost;\n        var neighborPenalty = isStart ? 0 : opt.penalties[directionChange]; // no penalties for start point\n\n        var costFromStart = currentCost + neighborCost + neighborPenalty;\n\n        if (!openSet.isOpen(neighborKey) || costFromStart < costs[neighborKey]) {\n          // neighbor point has not been processed yet\n          // or the cost of the path from start is lower than previously calculated\n          points[neighborKey] = neighborPoint;\n          parents[neighborKey] = currentPoint;\n          costs[neighborKey] = costFromStart;\n          openSet.add(neighborKey, costFromStart + estimateCost(neighborPoint, endPoints));\n        }\n      }\n\n      loopsRemaining--;\n    }\n  } // no route found (`to` point either wasn't accessible or finding route took\n  // way too much calculation)\n\n\n  return opt.fallbackRoute.call(this, start, end, opt);\n} // resolve some of the options\n\n\nfunction resolveOptions(opt) {\n  opt.directions = util.result(opt, 'directions');\n  opt.penalties = util.result(opt, 'penalties');\n  opt.paddingBox = util.result(opt, 'paddingBox');\n  opt.padding = util.result(opt, 'padding');\n\n  if (opt.padding) {\n    // if both provided, opt.padding wins over opt.paddingBox\n    var sides = util.normalizeSides(opt.padding);\n    opt.paddingBox = {\n      x: -sides.left,\n      y: -sides.top,\n      width: sides.left + sides.right,\n      height: sides.top + sides.bottom\n    };\n  }\n\n  util.toArray(opt.directions).forEach(function (direction) {\n    var point1 = new g.Point(0, 0);\n    var point2 = new g.Point(direction.offsetX, direction.offsetY);\n    direction.angle = g.normalizeAngle(point1.theta(point2));\n  });\n} // initialization of the route finding\n\n\nfunction router(vertices, opt, linkView) {\n  resolveOptions(opt); // enable/disable linkView perpendicular option\n\n  linkView.options.perpendicular = !!opt.perpendicular;\n  var sourceBBox = getSourceBBox(linkView, opt);\n  var targetBBox = getTargetBBox(linkView, opt);\n  var sourceAnchor = getSourceAnchor(linkView, opt); //var targetAnchor = getTargetAnchor(linkView, opt);\n  // pathfinding\n\n  let isPointObstacle;\n\n  if (typeof opt.isPointObstacle === 'function') {\n    isPointObstacle = opt.isPointObstacle;\n  } else {\n    const map = new ObstacleMap(opt);\n    map.build(linkView.paper.model, linkView.model);\n\n    isPointObstacle = point => !map.isPointAccessible(point);\n  }\n\n  var oldVertices = util.toArray(vertices).map(g.Point);\n  var newVertices = [];\n  var tailPoint = sourceAnchor; // the origin of first route's grid, does not need snapping\n  // find a route by concatenating all partial routes (routes need to pass through vertices)\n  // source -> vertex[1] -> ... -> vertex[n] -> target\n\n  var to, from;\n\n  for (var i = 0, len = oldVertices.length; i <= len; i++) {\n    var partialRoute = null;\n    from = to || sourceBBox;\n    to = oldVertices[i];\n\n    if (!to) {\n      // this is the last iteration\n      // we ran through all vertices in oldVertices\n      // 'to' is not a vertex.\n      to = targetBBox; // If the target is a point (i.e. it's not an element), we\n      // should use dragging route instead of main routing method if it has been provided.\n\n      var isEndingAtPoint = !linkView.model.get('source').id || !linkView.model.get('target').id;\n\n      if (isEndingAtPoint && util.isFunction(opt.draggingRoute)) {\n        // Make sure we are passing points only (not rects).\n        var dragFrom = from === sourceBBox ? sourceAnchor : from;\n        var dragTo = to.origin();\n        partialRoute = opt.draggingRoute.call(linkView, dragFrom, dragTo, opt);\n      }\n    } // if partial route has not been calculated yet use the main routing method to find one\n\n\n    partialRoute = partialRoute || findRoute.call(linkView, from, to, isPointObstacle, opt);\n\n    if (partialRoute === null) {\n      // the partial route cannot be found\n      return opt.fallbackRouter(vertices, opt, linkView);\n    }\n\n    var leadPoint = partialRoute[0]; // remove the first point if the previous partial route had the same point as last\n\n    if (leadPoint && leadPoint.equals(tailPoint)) partialRoute.shift(); // save tailPoint for next iteration\n\n    tailPoint = partialRoute[partialRoute.length - 1] || tailPoint;\n    Array.prototype.push.apply(newVertices, partialRoute);\n  }\n\n  return newVertices;\n} // public function\n\n\nexport const manhattan = function (vertices, opt, linkView) {\n  return router(vertices, util.assign({}, config, opt), linkView);\n};","map":{"version":3,"names":["g","util","orthogonal","config","step","maximumLoops","precision","maxAllowedDirectionChange","perpendicular","excludeEnds","excludeTypes","startDirections","endDirections","directionMap","top","x","y","right","bottom","left","cost","directions","offsetX","offsetY","penalties","paddingBox","width","height","isPointObstacle","fallbackRouter","vertices","opt","linkView","isFunction","Error","assign","fallbackRoute","from","to","draggingRoute","ObstacleMap","map","options","mapGridSize","prototype","build","graph","link","excludedEnds","toArray","reduce","res","item","end","get","cell","getCell","id","push","excludedAncestors","source","union","getAncestors","target","getElements","element","isExcludedType","includes","isExcludedEnd","find","excluded","isExcludedAncestor","isExcluded","bbox","getBBox","moveAndExpand","origin","snapToGrid","corner","gridKey","isPointAccessible","point","mapKey","clone","toString","every","obstacle","containsPoint","SortedSet","items","hash","values","OPEN","CLOSE","add","value","splice","indexOf","index","sortedIndex","i","bind","remove","isOpen","isClose","isEmpty","length","pop","shift","getSourceBBox","sourceBBox","getTargetBBox","targetBBox","getSourceAnchor","sourceAnchor","center","getTargetAnchor","targetAnchor","getDirectionAngle","start","numDirections","grid","quadrant","angleTheta","theta","fixAngleEnd","normalizedAngle","normalizeAngle","Math","floor","diffX","diffY","gridStepsX","gridStepsY","distanceX","distanceY","Point","getDirectionChange","angle1","angle2","directionChange","abs","getGridOffsets","forEach","direction","gridOffsetX","gridOffsetY","getGrid","getGridDimension","diff","absDiff","numSteps","round","roundedDiff","remainder","stepCorrection","snappedX","snappedY","align","getKey","normalizePoint","reconstructRoute","parents","points","tailPoint","route","prevDiff","difference","currentKey","parent","equals","unshift","leadPoint","fromDiff","estimateCost","endPoints","min","Infinity","len","manhattanDistance","getRectPoints","anchor","directionList","anchorCenterVector","keys","isObject","Object","dirList","rectPoints","key","endpoint","intersectionLine","Line","intersections","intersect","numIntersections","farthestIntersectionDistance","farthestIntersection","currentIntersection","distance","squaredDistance","undefined","offset","findRoute","Rect","startPoints","filter","p","openSet","costs","n","startPoint","previousRouteDirectionAngle","previousDirectionAngle","isPathBeginning","endPointsKeys","endPoint","loopsRemaining","currentPoint","currentParent","currentCost","isRouteBeginning","isStart","samePoints","j","skipEndCheck","directionAngle","angle","neighborPoint","neighborKey","isNeighborEnd","endDirectionAngle","endDirectionChange","neighborCost","neighborPenalty","costFromStart","call","resolveOptions","result","padding","sides","normalizeSides","point1","point2","router","paper","model","oldVertices","newVertices","partialRoute","isEndingAtPoint","dragFrom","dragTo","Array","apply","manhattan"],"sources":["C:/Users/Admin/dataflow-test/node_modules/jointjs/src/routers/manhattan.mjs"],"sourcesContent":["import * as g from '../g/index.mjs';\nimport * as util from '../util/index.mjs';\nimport { orthogonal } from './orthogonal.mjs';\n\nvar config = {\n\n    // size of the step to find a route (the grid of the manhattan pathfinder)\n    step: 10,\n\n    // the number of route finding loops that cause the router to abort\n    // returns fallback route instead\n    maximumLoops: 2000,\n\n    // the number of decimal places to round floating point coordinates\n    precision: 1,\n\n    // maximum change of direction\n    maxAllowedDirectionChange: 90,\n\n    // should the router use perpendicular linkView option?\n    // does not connect anchor of element but rather a point close-by that is orthogonal\n    // this looks much better\n    perpendicular: true,\n\n    // should the source and/or target not be considered as obstacles?\n    excludeEnds: [], // 'source', 'target'\n\n    // should certain types of elements not be considered as obstacles?\n    excludeTypes: ['basic.Text'],\n\n    // possible starting directions from an element\n    startDirections: ['top', 'right', 'bottom', 'left'],\n\n    // possible ending directions to an element\n    endDirections: ['top', 'right', 'bottom', 'left'],\n\n    // specify the directions used above and what they mean\n    directionMap: {\n        top: { x: 0, y: -1 },\n        right: { x: 1, y: 0 },\n        bottom: { x: 0, y: 1 },\n        left: { x: -1, y: 0 }\n    },\n\n    // cost of an orthogonal step\n    cost: function() {\n\n        return this.step;\n    },\n\n    // an array of directions to find next points on the route\n    // different from start/end directions\n    directions: function() {\n\n        var step = this.step;\n        var cost = this.cost();\n\n        return [\n            { offsetX: step, offsetY: 0, cost: cost },\n            { offsetX: -step, offsetY: 0, cost: cost },\n            { offsetX: 0, offsetY: step, cost: cost },\n            { offsetX: 0, offsetY: -step, cost: cost }\n        ];\n    },\n\n    // a penalty received for direction change\n    penalties: function() {\n\n        return {\n            0: 0,\n            45: this.step / 2,\n            90: this.step / 2\n        };\n    },\n\n    // padding applied on the element bounding boxes\n    paddingBox: function() {\n\n        var step = this.step;\n\n        return {\n            x: -step,\n            y: -step,\n            width: 2 * step,\n            height: 2 * step\n        };\n    },\n\n    // A function that determines whether a given point is an obstacle or not.\n    // If used, the `padding`, `excludeEnds`and `excludeTypes` options are ignored.\n    // (point: dia.Point) => boolean;\n    isPointObstacle: null,\n\n    // a router to use when the manhattan router fails\n    // (one of the partial routes returns null)\n    fallbackRouter: function(vertices, opt, linkView) {\n\n        if (!util.isFunction(orthogonal)) {\n            throw new Error('Manhattan requires the orthogonal router as default fallback.');\n        }\n\n        return orthogonal(vertices, util.assign({}, config, opt), linkView);\n    },\n\n    /* Deprecated */\n    // a simple route used in situations when main routing method fails\n    // (exceed max number of loop iterations, inaccessible)\n    fallbackRoute: function(from, to, opt) {\n\n        return null; // null result will trigger the fallbackRouter\n\n        // left for reference:\n        /*// Find an orthogonal route ignoring obstacles.\n\n        var point = ((opt.previousDirAngle || 0) % 180 === 0)\n                ? new g.Point(from.x, to.y)\n                : new g.Point(to.x, from.y);\n\n        return [point];*/\n    },\n\n    // if a function is provided, it's used to route the link while dragging an end\n    // i.e. function(from, to, opt) { return []; }\n    draggingRoute: null\n};\n\n// HELPER CLASSES //\n\n// Map of obstacles\n// Helper structure to identify whether a point lies inside an obstacle.\nfunction ObstacleMap(opt) {\n\n    this.map = {};\n    this.options = opt;\n    // tells how to divide the paper when creating the elements map\n    this.mapGridSize = 100;\n}\n\nObstacleMap.prototype.build = function(graph, link) {\n\n    var opt = this.options;\n\n    // source or target element could be excluded from set of obstacles\n    var excludedEnds = util.toArray(opt.excludeEnds).reduce(function(res, item) {\n\n        var end = link.get(item);\n        if (end) {\n            var cell = graph.getCell(end.id);\n            if (cell) {\n                res.push(cell);\n            }\n        }\n\n        return res;\n    }, []);\n\n    // Exclude any embedded elements from the source and the target element.\n    var excludedAncestors = [];\n\n    var source = graph.getCell(link.get('source').id);\n    if (source) {\n        excludedAncestors = util.union(excludedAncestors, source.getAncestors().map(function(cell) {\n            return cell.id;\n        }));\n    }\n\n    var target = graph.getCell(link.get('target').id);\n    if (target) {\n        excludedAncestors = util.union(excludedAncestors, target.getAncestors().map(function(cell) {\n            return cell.id;\n        }));\n    }\n\n    // Builds a map of all elements for quicker obstacle queries (i.e. is a point contained\n    // in any obstacle?) (a simplified grid search).\n    // The paper is divided into smaller cells, where each holds information about which\n    // elements belong to it. When we query whether a point lies inside an obstacle we\n    // don't need to go through all obstacles, we check only those in a particular cell.\n    var mapGridSize = this.mapGridSize;\n\n    graph.getElements().reduce(function(map, element) {\n\n        var isExcludedType = util.toArray(opt.excludeTypes).includes(element.get('type'));\n        var isExcludedEnd = excludedEnds.find(function(excluded) {\n            return excluded.id === element.id;\n        });\n        var isExcludedAncestor = excludedAncestors.includes(element.id);\n\n        var isExcluded = isExcludedType || isExcludedEnd || isExcludedAncestor;\n        if (!isExcluded) {\n            var bbox = element.getBBox().moveAndExpand(opt.paddingBox);\n\n            var origin = bbox.origin().snapToGrid(mapGridSize);\n            var corner = bbox.corner().snapToGrid(mapGridSize);\n\n            for (var x = origin.x; x <= corner.x; x += mapGridSize) {\n                for (var y = origin.y; y <= corner.y; y += mapGridSize) {\n                    var gridKey = x + '@' + y;\n                    map[gridKey] = map[gridKey] || [];\n                    map[gridKey].push(bbox);\n                }\n            }\n        }\n\n        return map;\n    }, this.map);\n\n    return this;\n};\n\nObstacleMap.prototype.isPointAccessible = function(point) {\n\n    var mapKey = point.clone().snapToGrid(this.mapGridSize).toString();\n\n    return util.toArray(this.map[mapKey]).every(function(obstacle) {\n        return !obstacle.containsPoint(point);\n    });\n};\n\n// Sorted Set\n// Set of items sorted by given value.\nfunction SortedSet() {\n    this.items = [];\n    this.hash = {};\n    this.values = {};\n    this.OPEN = 1;\n    this.CLOSE = 2;\n}\n\nSortedSet.prototype.add = function(item, value) {\n\n    if (this.hash[item]) {\n        // item removal\n        this.items.splice(this.items.indexOf(item), 1);\n    } else {\n        this.hash[item] = this.OPEN;\n    }\n\n    this.values[item] = value;\n\n    var index = util.sortedIndex(this.items, item, function(i) {\n        return this.values[i];\n    }.bind(this));\n\n    this.items.splice(index, 0, item);\n};\n\nSortedSet.prototype.remove = function(item) {\n\n    this.hash[item] = this.CLOSE;\n};\n\nSortedSet.prototype.isOpen = function(item) {\n\n    return this.hash[item] === this.OPEN;\n};\n\nSortedSet.prototype.isClose = function(item) {\n\n    return this.hash[item] === this.CLOSE;\n};\n\nSortedSet.prototype.isEmpty = function() {\n\n    return this.items.length === 0;\n};\n\nSortedSet.prototype.pop = function() {\n\n    var item = this.items.shift();\n    this.remove(item);\n    return item;\n};\n\n// HELPERS //\n\n// return source bbox\nfunction getSourceBBox(linkView, opt) {\n\n    // expand by padding box\n    if (opt && opt.paddingBox) return linkView.sourceBBox.clone().moveAndExpand(opt.paddingBox);\n\n    return linkView.sourceBBox.clone();\n}\n\n// return target bbox\nfunction getTargetBBox(linkView, opt) {\n\n    // expand by padding box\n    if (opt && opt.paddingBox) return linkView.targetBBox.clone().moveAndExpand(opt.paddingBox);\n\n    return linkView.targetBBox.clone();\n}\n\n// return source anchor\nfunction getSourceAnchor(linkView, opt) {\n\n    if (linkView.sourceAnchor) return linkView.sourceAnchor;\n\n    // fallback: center of bbox\n    var sourceBBox = getSourceBBox(linkView, opt);\n    return sourceBBox.center();\n}\n\n// return target anchor\nfunction getTargetAnchor(linkView, opt) {\n\n    if (linkView.targetAnchor) return linkView.targetAnchor;\n\n    // fallback: center of bbox\n    var targetBBox = getTargetBBox(linkView, opt);\n    return targetBBox.center(); // default\n}\n\n// returns a direction index from start point to end point\n// corrects for grid deformation between start and end\nfunction getDirectionAngle(start, end, numDirections, grid, opt) {\n\n    var quadrant = 360 / numDirections;\n    var angleTheta = start.theta(fixAngleEnd(start, end, grid, opt));\n    var normalizedAngle = g.normalizeAngle(angleTheta + (quadrant / 2));\n    return quadrant * Math.floor(normalizedAngle / quadrant);\n}\n\n// helper function for getDirectionAngle()\n// corrects for grid deformation\n// (if a point is one grid steps away from another in both dimensions,\n// it is considered to be 45 degrees away, even if the real angle is different)\n// this causes visible angle discrepancies if `opt.step` is much larger than `paper.gridSize`\nfunction fixAngleEnd(start, end, grid, opt) {\n\n    var step = opt.step;\n\n    var diffX = end.x - start.x;\n    var diffY = end.y - start.y;\n\n    var gridStepsX = diffX / grid.x;\n    var gridStepsY = diffY / grid.y;\n\n    var distanceX = gridStepsX * step;\n    var distanceY = gridStepsY * step;\n\n    return new g.Point(start.x + distanceX, start.y + distanceY);\n}\n\n// return the change in direction between two direction angles\nfunction getDirectionChange(angle1, angle2) {\n\n    var directionChange = Math.abs(angle1 - angle2);\n    return (directionChange > 180) ? (360 - directionChange) : directionChange;\n}\n\n// fix direction offsets according to current grid\nfunction getGridOffsets(directions, grid, opt) {\n\n    var step = opt.step;\n\n    util.toArray(opt.directions).forEach(function(direction) {\n\n        direction.gridOffsetX = (direction.offsetX / step) * grid.x;\n        direction.gridOffsetY = (direction.offsetY / step) * grid.y;\n    });\n}\n\n// get grid size in x and y dimensions, adapted to source and target positions\nfunction getGrid(step, source, target) {\n\n    return {\n        source: source.clone(),\n        x: getGridDimension(target.x - source.x, step),\n        y: getGridDimension(target.y - source.y, step)\n    };\n}\n\n// helper function for getGrid()\nfunction getGridDimension(diff, step) {\n\n    // return step if diff = 0\n    if (!diff) return step;\n\n    var absDiff = Math.abs(diff);\n    var numSteps = Math.round(absDiff / step);\n\n    // return absDiff if less than one step apart\n    if (!numSteps) return absDiff;\n\n    // otherwise, return corrected step\n    var roundedDiff = numSteps * step;\n    var remainder = absDiff - roundedDiff;\n    var stepCorrection = remainder / numSteps;\n\n    return step + stepCorrection;\n}\n\n// return a clone of point snapped to grid\nfunction snapToGrid(point, grid) {\n\n    var source = grid.source;\n\n    var snappedX = g.snapToGrid(point.x - source.x, grid.x) + source.x;\n    var snappedY = g.snapToGrid(point.y - source.y, grid.y) + source.y;\n\n    return new g.Point(snappedX, snappedY);\n}\n\n// round the point to opt.precision\nfunction round(point, precision) {\n\n    return point.round(precision);\n}\n\n// snap to grid and then round the point\nfunction align(point, grid, precision) {\n\n    return round(snapToGrid(point.clone(), grid), precision);\n}\n\n// return a string representing the point\n// string is rounded in both dimensions\nfunction getKey(point) {\n\n    return point.clone().toString();\n}\n\n// return a normalized vector from given point\n// used to determine the direction of a difference of two points\nfunction normalizePoint(point) {\n\n    return new g.Point(\n        point.x === 0 ? 0 : Math.abs(point.x) / point.x,\n        point.y === 0 ? 0 : Math.abs(point.y) / point.y\n    );\n}\n\n// PATHFINDING //\n\n// reconstructs a route by concatenating points with their parents\nfunction reconstructRoute(parents, points, tailPoint, from, to, grid, opt) {\n\n    var route = [];\n\n    var prevDiff = normalizePoint(to.difference(tailPoint));\n\n    // tailPoint is assumed to be aligned already\n    var currentKey = getKey(tailPoint);\n    var parent = parents[currentKey];\n\n    var point;\n    while (parent) {\n\n        // point is assumed to be aligned already\n        point = points[currentKey];\n\n        var diff = normalizePoint(point.difference(parent));\n        if (!diff.equals(prevDiff)) {\n            route.unshift(point);\n            prevDiff = diff;\n        }\n\n        // parent is assumed to be aligned already\n        currentKey = getKey(parent);\n        parent = parents[currentKey];\n    }\n\n    // leadPoint is assumed to be aligned already\n    var leadPoint = points[currentKey];\n\n    var fromDiff = normalizePoint(leadPoint.difference(from));\n    if (!fromDiff.equals(prevDiff)) {\n        route.unshift(leadPoint);\n    }\n\n    return route;\n}\n\n// heuristic method to determine the distance between two points\nfunction estimateCost(from, endPoints) {\n\n    var min = Infinity;\n\n    for (var i = 0, len = endPoints.length; i < len; i++) {\n        var cost = from.manhattanDistance(endPoints[i]);\n        if (cost < min) min = cost;\n    }\n\n    return min;\n}\n\n// find points around the bbox taking given directions into account\n// lines are drawn from anchor in given directions, intersections recorded\n// if anchor is outside bbox, only those directions that intersect get a rect point\n// the anchor itself is returned as rect point (representing some directions)\n// (since those directions are unobstructed by the bbox)\nfunction getRectPoints(anchor, bbox, directionList, grid, opt) {\n\n    var precision = opt.precision;\n    var directionMap = opt.directionMap;\n\n    var anchorCenterVector = anchor.difference(bbox.center());\n\n    var keys = util.isObject(directionMap) ? Object.keys(directionMap) : [];\n    var dirList = util.toArray(directionList);\n    var rectPoints = keys.reduce(function(res, key) {\n\n        if (dirList.includes(key)) {\n            var direction = directionMap[key];\n\n            // create a line that is guaranteed to intersect the bbox if bbox is in the direction\n            // even if anchor lies outside of bbox\n            var endpoint = new g.Point(\n                anchor.x + direction.x * (Math.abs(anchorCenterVector.x) + bbox.width),\n                anchor.y + direction.y * (Math.abs(anchorCenterVector.y) + bbox.height)\n            );\n            var intersectionLine = new g.Line(anchor, endpoint);\n\n            // get the farther intersection, in case there are two\n            // (that happens if anchor lies next to bbox)\n            var intersections = intersectionLine.intersect(bbox) || [];\n            var numIntersections = intersections.length;\n            var farthestIntersectionDistance;\n            var farthestIntersection = null;\n            for (var i = 0; i < numIntersections; i++) {\n                var currentIntersection = intersections[i];\n                var distance = anchor.squaredDistance(currentIntersection);\n                if ((farthestIntersectionDistance === undefined) || (distance > farthestIntersectionDistance)) {\n                    farthestIntersectionDistance = distance;\n                    farthestIntersection = currentIntersection;\n                }\n            }\n\n            // if an intersection was found in this direction, it is our rectPoint\n            if (farthestIntersection) {\n                var point = align(farthestIntersection, grid, precision);\n\n                // if the rectPoint lies inside the bbox, offset it by one more step\n                if (bbox.containsPoint(point)) {\n                    point = align(point.offset(direction.x * grid.x, direction.y * grid.y), grid, precision);\n                }\n\n                // then add the point to the result array\n                // aligned\n                res.push(point);\n            }\n        }\n\n        return res;\n    }, []);\n\n    // if anchor lies outside of bbox, add it to the array of points\n    if (!bbox.containsPoint(anchor)) {\n        // aligned\n        rectPoints.push(align(anchor, grid, precision));\n    }\n\n    return rectPoints;\n}\n\n// finds the route between two points/rectangles (`from`, `to`) implementing A* algorithm\n// rectangles get rect points assigned by getRectPoints()\nfunction findRoute(from, to, isPointObstacle, opt) {\n\n    var precision = opt.precision;\n\n    // Get grid for this route.\n\n    var sourceAnchor, targetAnchor;\n\n    if (from instanceof g.Rect) { // `from` is sourceBBox\n        sourceAnchor = round(getSourceAnchor(this, opt).clone(), precision);\n    } else {\n        sourceAnchor = round(from.clone(), precision);\n    }\n\n    if (to instanceof g.Rect) { // `to` is targetBBox\n        targetAnchor = round(getTargetAnchor(this, opt).clone(), precision);\n    } else {\n        targetAnchor = round(to.clone(), precision);\n    }\n\n    var grid = getGrid(opt.step, sourceAnchor, targetAnchor);\n\n    // Get pathfinding points.\n\n    var start, end; // aligned with grid by definition\n    var startPoints, endPoints; // assumed to be aligned with grid already\n\n    // set of points we start pathfinding from\n    if (from instanceof g.Rect) { // `from` is sourceBBox\n        start = sourceAnchor;\n        startPoints = getRectPoints(start, from, opt.startDirections, grid, opt);\n\n    } else {\n        start = sourceAnchor;\n        startPoints = [start];\n    }\n\n    // set of points we want the pathfinding to finish at\n    if (to instanceof g.Rect) { // `to` is targetBBox\n        end = targetAnchor;\n        endPoints = getRectPoints(targetAnchor, to, opt.endDirections, grid, opt);\n\n    } else {\n        end = targetAnchor;\n        endPoints = [end];\n    }\n\n    // take into account only accessible rect points (those not under obstacles)\n    startPoints = startPoints.filter(p => !isPointObstacle(p));\n    endPoints = endPoints.filter(p => !isPointObstacle(p));\n\n    // Check that there is an accessible route point on both sides.\n    // Otherwise, use fallbackRoute().\n    if (startPoints.length > 0 && endPoints.length > 0) {\n\n        // The set of tentative points to be evaluated, initially containing the start points.\n        // Rounded to nearest integer for simplicity.\n        var openSet = new SortedSet();\n        // Keeps reference to actual points for given elements of the open set.\n        var points = {};\n        // Keeps reference to a point that is immediate predecessor of given element.\n        var parents = {};\n        // Cost from start to a point along best known path.\n        var costs = {};\n\n        for (var i = 0, n = startPoints.length; i < n; i++) {\n            // startPoint is assumed to be aligned already\n            var startPoint = startPoints[i];\n\n            var key = getKey(startPoint);\n\n            openSet.add(key, estimateCost(startPoint, endPoints));\n            points[key] = startPoint;\n            costs[key] = 0;\n        }\n\n        var previousRouteDirectionAngle = opt.previousDirectionAngle; // undefined for first route\n        var isPathBeginning = (previousRouteDirectionAngle === undefined);\n\n        // directions\n        var direction, directionChange;\n        var directions = opt.directions;\n        getGridOffsets(directions, grid, opt);\n\n        var numDirections = directions.length;\n\n        var endPointsKeys = util.toArray(endPoints).reduce(function(res, endPoint) {\n            // endPoint is assumed to be aligned already\n\n            var key = getKey(endPoint);\n            res.push(key);\n            return res;\n        }, []);\n\n        // main route finding loop\n        var loopsRemaining = opt.maximumLoops;\n        while (!openSet.isEmpty() && loopsRemaining > 0) {\n\n            // remove current from the open list\n            var currentKey = openSet.pop();\n            var currentPoint = points[currentKey];\n            var currentParent = parents[currentKey];\n            var currentCost = costs[currentKey];\n\n            var isRouteBeginning = (currentParent === undefined); // undefined for route starts\n            var isStart = currentPoint.equals(start); // (is source anchor or `from` point) = can leave in any direction\n\n            var previousDirectionAngle;\n            if (!isRouteBeginning) previousDirectionAngle = getDirectionAngle(currentParent, currentPoint, numDirections, grid, opt); // a vertex on the route\n            else if (!isPathBeginning) previousDirectionAngle = previousRouteDirectionAngle; // beginning of route on the path\n            else if (!isStart) previousDirectionAngle = getDirectionAngle(start, currentPoint, numDirections, grid, opt); // beginning of path, start rect point\n            else previousDirectionAngle = null; // beginning of path, source anchor or `from` point\n\n            // check if we reached any endpoint\n            var samePoints = startPoints.length === endPoints.length;\n            if (samePoints) {\n                for (var j = 0; j < startPoints.length; j++) {\n                    if (!startPoints[j].equals(endPoints[j])) {\n                        samePoints = false;\n                        break;\n                    }\n                }\n            }\n            var skipEndCheck = (isRouteBeginning && samePoints);\n            if (!skipEndCheck && (endPointsKeys.indexOf(currentKey) >= 0)) {\n                opt.previousDirectionAngle = previousDirectionAngle;\n                return reconstructRoute(parents, points, currentPoint, start, end, grid, opt);\n            }\n\n            // go over all possible directions and find neighbors\n            for (i = 0; i < numDirections; i++) {\n                direction = directions[i];\n\n                var directionAngle = direction.angle;\n                directionChange = getDirectionChange(previousDirectionAngle, directionAngle);\n\n                // if the direction changed rapidly, don't use this point\n                // any direction is allowed for starting points\n                if (!(isPathBeginning && isStart) && directionChange > opt.maxAllowedDirectionChange) continue;\n\n                var neighborPoint = align(currentPoint.clone().offset(direction.gridOffsetX, direction.gridOffsetY), grid, precision);\n                var neighborKey = getKey(neighborPoint);\n\n                // Closed points from the openSet were already evaluated.\n                if (openSet.isClose(neighborKey) || isPointObstacle(neighborPoint)) continue;\n\n                // We can only enter end points at an acceptable angle.\n                if (endPointsKeys.indexOf(neighborKey) >= 0) { // neighbor is an end point\n\n                    var isNeighborEnd = neighborPoint.equals(end); // (is target anchor or `to` point) = can be entered in any direction\n\n                    if (!isNeighborEnd) {\n                        var endDirectionAngle = getDirectionAngle(neighborPoint, end, numDirections, grid, opt);\n                        var endDirectionChange = getDirectionChange(directionAngle, endDirectionAngle);\n\n                        if (endDirectionChange > opt.maxAllowedDirectionChange) continue;\n                    }\n                }\n\n                // The current direction is ok.\n\n                var neighborCost = direction.cost;\n                var neighborPenalty = isStart ? 0 : opt.penalties[directionChange]; // no penalties for start point\n                var costFromStart = currentCost + neighborCost + neighborPenalty;\n\n                if (!openSet.isOpen(neighborKey) || (costFromStart < costs[neighborKey])) {\n                    // neighbor point has not been processed yet\n                    // or the cost of the path from start is lower than previously calculated\n\n                    points[neighborKey] = neighborPoint;\n                    parents[neighborKey] = currentPoint;\n                    costs[neighborKey] = costFromStart;\n                    openSet.add(neighborKey, costFromStart + estimateCost(neighborPoint, endPoints));\n                }\n            }\n\n            loopsRemaining--;\n        }\n    }\n\n    // no route found (`to` point either wasn't accessible or finding route took\n    // way too much calculation)\n    return opt.fallbackRoute.call(this, start, end, opt);\n}\n\n// resolve some of the options\nfunction resolveOptions(opt) {\n\n    opt.directions = util.result(opt, 'directions');\n    opt.penalties = util.result(opt, 'penalties');\n    opt.paddingBox = util.result(opt, 'paddingBox');\n    opt.padding = util.result(opt, 'padding');\n\n    if (opt.padding) {\n        // if both provided, opt.padding wins over opt.paddingBox\n        var sides = util.normalizeSides(opt.padding);\n        opt.paddingBox = {\n            x: -sides.left,\n            y: -sides.top,\n            width: sides.left + sides.right,\n            height: sides.top + sides.bottom\n        };\n    }\n\n    util.toArray(opt.directions).forEach(function(direction) {\n\n        var point1 = new g.Point(0, 0);\n        var point2 = new g.Point(direction.offsetX, direction.offsetY);\n\n        direction.angle = g.normalizeAngle(point1.theta(point2));\n    });\n}\n\n// initialization of the route finding\nfunction router(vertices, opt, linkView) {\n\n    resolveOptions(opt);\n\n    // enable/disable linkView perpendicular option\n    linkView.options.perpendicular = !!opt.perpendicular;\n\n    var sourceBBox = getSourceBBox(linkView, opt);\n    var targetBBox = getTargetBBox(linkView, opt);\n\n    var sourceAnchor = getSourceAnchor(linkView, opt);\n    //var targetAnchor = getTargetAnchor(linkView, opt);\n\n    // pathfinding\n    let isPointObstacle;\n    if (typeof opt.isPointObstacle === 'function') {\n        isPointObstacle = opt.isPointObstacle;\n    } else {\n        const map = new ObstacleMap(opt);\n        map.build(linkView.paper.model, linkView.model);\n        isPointObstacle = (point) => !map.isPointAccessible(point);\n    }\n\n    var oldVertices = util.toArray(vertices).map(g.Point);\n    var newVertices = [];\n    var tailPoint = sourceAnchor; // the origin of first route's grid, does not need snapping\n\n    // find a route by concatenating all partial routes (routes need to pass through vertices)\n    // source -> vertex[1] -> ... -> vertex[n] -> target\n    var to, from;\n\n    for (var i = 0, len = oldVertices.length; i <= len; i++) {\n\n        var partialRoute = null;\n\n        from = to || sourceBBox;\n        to = oldVertices[i];\n\n        if (!to) {\n            // this is the last iteration\n            // we ran through all vertices in oldVertices\n            // 'to' is not a vertex.\n\n            to = targetBBox;\n\n            // If the target is a point (i.e. it's not an element), we\n            // should use dragging route instead of main routing method if it has been provided.\n            var isEndingAtPoint = !linkView.model.get('source').id || !linkView.model.get('target').id;\n\n            if (isEndingAtPoint && util.isFunction(opt.draggingRoute)) {\n                // Make sure we are passing points only (not rects).\n                var dragFrom = (from === sourceBBox) ? sourceAnchor : from;\n                var dragTo = to.origin();\n\n                partialRoute = opt.draggingRoute.call(linkView, dragFrom, dragTo, opt);\n            }\n        }\n\n        // if partial route has not been calculated yet use the main routing method to find one\n        partialRoute = partialRoute || findRoute.call(linkView, from, to, isPointObstacle, opt);\n\n        if (partialRoute === null) { // the partial route cannot be found\n            return opt.fallbackRouter(vertices, opt, linkView);\n        }\n\n        var leadPoint = partialRoute[0];\n\n        // remove the first point if the previous partial route had the same point as last\n        if (leadPoint && leadPoint.equals(tailPoint)) partialRoute.shift();\n\n        // save tailPoint for next iteration\n        tailPoint = partialRoute[partialRoute.length - 1] || tailPoint;\n\n        Array.prototype.push.apply(newVertices, partialRoute);\n    }\n\n    return newVertices;\n}\n\n// public function\nexport const manhattan = function(vertices, opt, linkView) {\n    return router(vertices, util.assign({}, config, opt), linkView);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}