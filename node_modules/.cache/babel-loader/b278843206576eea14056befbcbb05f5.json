{"ast":null,"code":"/*\n    Point is the most basic object consisting of x/y coordinate.\n\n    Possible instantiations are:\n    * `Point(10, 20)`\n    * `new Point(10, 20)`\n    * `Point('10 20')`\n    * `Point(Point(10, 20))`\n*/\nimport { normalizeAngle, random, snapToGrid, toDeg, toRad } from './geometry.helpers.mjs';\nimport { bearing } from './line.bearing.mjs';\nimport { squaredLength } from './line.squaredLength.mjs';\nimport { length } from './line.length.mjs';\nimport { types } from './types.mjs';\nconst {\n  abs,\n  cos,\n  sin,\n  sqrt,\n  min,\n  max,\n  atan2,\n  round,\n  pow,\n  PI\n} = Math;\nexport const Point = function (x, y) {\n  if (!(this instanceof Point)) {\n    return new Point(x, y);\n  }\n\n  if (typeof x === 'string') {\n    var xy = x.split(x.indexOf('@') === -1 ? ' ' : '@');\n    x = parseFloat(xy[0]);\n    y = parseFloat(xy[1]);\n  } else if (Object(x) === x) {\n    y = x.y;\n    x = x.x;\n  }\n\n  this.x = x === undefined ? 0 : x;\n  this.y = y === undefined ? 0 : y;\n}; // Alternative constructor, from polar coordinates.\n// @param {number} Distance.\n// @param {number} Angle in radians.\n// @param {point} [optional] Origin.\n\nPoint.fromPolar = function (distance, angle, origin) {\n  origin = new Point(origin);\n  var x = abs(distance * cos(angle));\n  var y = abs(distance * sin(angle));\n  var deg = normalizeAngle(toDeg(angle));\n\n  if (deg < 90) {\n    y = -y;\n  } else if (deg < 180) {\n    x = -x;\n    y = -y;\n  } else if (deg < 270) {\n    x = -x;\n  }\n\n  return new Point(origin.x + x, origin.y + y);\n}; // Create a point with random coordinates that fall into the range `[x1, x2]` and `[y1, y2]`.\n\n\nPoint.random = function (x1, x2, y1, y2) {\n  return new Point(random(x1, x2), random(y1, y2));\n};\n\nPoint.prototype = {\n  type: types.Point,\n  chooseClosest: function (points) {\n    var n = points.length;\n    if (n === 1) return new Point(points[0]);\n    var closest = null;\n    var minSqrDistance = Infinity;\n\n    for (var i = 0; i < n; i++) {\n      var p = new Point(points[i]);\n      var sqrDistance = this.squaredDistance(p);\n\n      if (sqrDistance < minSqrDistance) {\n        closest = p;\n        minSqrDistance = sqrDistance;\n      }\n    }\n\n    return closest;\n  },\n  // If point lies outside rectangle `r`, return the nearest point on the boundary of rect `r`,\n  // otherwise return point itself.\n  // (see Squeak Smalltalk, Point>>adhereTo:)\n  adhereToRect: function (r) {\n    if (r.containsPoint(this)) {\n      return this;\n    }\n\n    this.x = min(max(this.x, r.x), r.x + r.width);\n    this.y = min(max(this.y, r.y), r.y + r.height);\n    return this;\n  },\n  // Compute the angle between vector from me to p1 and the vector from me to p2.\n  // ordering of points p1 and p2 is important!\n  // theta function's angle convention:\n  // returns angles between 0 and 180 when the angle is counterclockwise\n  // returns angles between 180 and 360 to convert clockwise angles into counterclockwise ones\n  // returns NaN if any of the points p1, p2 is coincident with this point\n  angleBetween: function (p1, p2) {\n    var angleBetween = this.equals(p1) || this.equals(p2) ? NaN : this.theta(p2) - this.theta(p1);\n\n    if (angleBetween < 0) {\n      angleBetween += 360; // correction to keep angleBetween between 0 and 360\n    }\n\n    return angleBetween;\n  },\n  // Return the bearing between me and the given point.\n  bearing: function (point) {\n    return bearing(this, point);\n  },\n  // Returns change in angle from my previous position (-dx, -dy) to my new position\n  // relative to ref point.\n  changeInAngle: function (dx, dy, ref) {\n    // Revert the translation and measure the change in angle around x-axis.\n    return this.clone().offset(-dx, -dy).theta(ref) - this.theta(ref);\n  },\n  clone: function () {\n    return new Point(this);\n  },\n  // Returns the cross product of this point relative to two other points\n  // this point is the common point\n  // point p1 lies on the first vector, point p2 lies on the second vector\n  // watch out for the ordering of points p1 and p2!\n  // positive result indicates a clockwise (\"right\") turn from first to second vector\n  // negative result indicates a counterclockwise (\"left\") turn from first to second vector\n  // zero indicates that the first and second vector are collinear\n  // note that the above directions are reversed from the usual answer on the Internet\n  // that is because we are in a left-handed coord system (because the y-axis points downward)\n  cross: function (p1, p2) {\n    return p1 && p2 ? (p2.x - this.x) * (p1.y - this.y) - (p2.y - this.y) * (p1.x - this.x) : NaN;\n  },\n  difference: function (dx, dy) {\n    if (Object(dx) === dx) {\n      dy = dx.y;\n      dx = dx.x;\n    }\n\n    return new Point(this.x - (dx || 0), this.y - (dy || 0));\n  },\n  // Returns distance between me and point `p`.\n  distance: function (p) {\n    return length(this, p);\n  },\n  // Returns the dot product of this point with given other point\n  dot: function (p) {\n    return p ? this.x * p.x + this.y * p.y : NaN;\n  },\n  equals: function (p) {\n    return !!p && this.x === p.x && this.y === p.y;\n  },\n  // Linear interpolation\n  lerp: function (p, t) {\n    var x = this.x;\n    var y = this.y;\n    return new Point((1 - t) * x + t * p.x, (1 - t) * y + t * p.y);\n  },\n  magnitude: function () {\n    return sqrt(this.x * this.x + this.y * this.y) || 0.01;\n  },\n  // Returns a manhattan (taxi-cab) distance between me and point `p`.\n  manhattanDistance: function (p) {\n    return abs(p.x - this.x) + abs(p.y - this.y);\n  },\n  // Move point on line starting from ref ending at me by\n  // distance distance.\n  move: function (ref, distance) {\n    var theta = toRad(new Point(ref).theta(this));\n    var offset = this.offset(cos(theta) * distance, -sin(theta) * distance);\n    return offset;\n  },\n  // Scales x and y such that the distance between the point and the origin (0,0) is equal to the given length.\n  normalize: function (length) {\n    var scale = (length || 1) / this.magnitude();\n    return this.scale(scale, scale);\n  },\n  // Offset me by the specified amount.\n  offset: function (dx, dy) {\n    if (Object(dx) === dx) {\n      dy = dx.y;\n      dx = dx.x;\n    }\n\n    this.x += dx || 0;\n    this.y += dy || 0;\n    return this;\n  },\n  // Returns a point that is the reflection of me with\n  // the center of inversion in ref point.\n  reflection: function (ref) {\n    return new Point(ref).move(this, this.distance(ref));\n  },\n  // Rotate point by angle around origin.\n  // Angle is flipped because this is a left-handed coord system (y-axis points downward).\n  rotate: function (origin, angle) {\n    if (angle === 0) return this;\n    origin = origin || new Point(0, 0);\n    angle = toRad(normalizeAngle(-angle));\n    var cosAngle = cos(angle);\n    var sinAngle = sin(angle);\n    var x = cosAngle * (this.x - origin.x) - sinAngle * (this.y - origin.y) + origin.x;\n    var y = sinAngle * (this.x - origin.x) + cosAngle * (this.y - origin.y) + origin.y;\n    this.x = x;\n    this.y = y;\n    return this;\n  },\n  round: function (precision) {\n    let f = 1; // case 0\n\n    if (precision) {\n      switch (precision) {\n        case 1:\n          f = 10;\n          break;\n\n        case 2:\n          f = 100;\n          break;\n\n        case 3:\n          f = 1000;\n          break;\n\n        default:\n          f = pow(10, precision);\n          break;\n      }\n    }\n\n    this.x = round(this.x * f) / f;\n    this.y = round(this.y * f) / f;\n    return this;\n  },\n  // Scale point with origin.\n  scale: function (sx, sy, origin) {\n    origin = origin && new Point(origin) || new Point(0, 0);\n    this.x = origin.x + sx * (this.x - origin.x);\n    this.y = origin.y + sy * (this.y - origin.y);\n    return this;\n  },\n  snapToGrid: function (gx, gy) {\n    this.x = snapToGrid(this.x, gx);\n    this.y = snapToGrid(this.y, gy || gx);\n    return this;\n  },\n  squaredDistance: function (p) {\n    return squaredLength(this, p);\n  },\n  // Compute the angle between me and `p` and the x axis.\n  // (cartesian-to-polar coordinates conversion)\n  // Return theta angle in degrees.\n  theta: function (p) {\n    p = new Point(p); // Invert the y-axis.\n\n    var y = -(p.y - this.y);\n    var x = p.x - this.x;\n    var rad = atan2(y, x); // defined for all 0 corner cases\n    // Correction for III. and IV. quadrant.\n\n    if (rad < 0) {\n      rad = 2 * PI + rad;\n    }\n\n    return 180 * rad / PI;\n  },\n  toJSON: function () {\n    return {\n      x: this.x,\n      y: this.y\n    };\n  },\n  // Converts rectangular to polar coordinates.\n  // An origin can be specified, otherwise it's 0@0.\n  toPolar: function (o) {\n    o = o && new Point(o) || new Point(0, 0);\n    var x = this.x;\n    var y = this.y;\n    this.x = sqrt((x - o.x) * (x - o.x) + (y - o.y) * (y - o.y)); // r\n\n    this.y = toRad(o.theta(new Point(x, y)));\n    return this;\n  },\n  toString: function () {\n    return this.x + '@' + this.y;\n  },\n  serialize: function () {\n    return this.x + ',' + this.y;\n  },\n  update: function (x, y) {\n    if (Object(x) === x) {\n      y = x.y;\n      x = x.x;\n    }\n\n    this.x = x || 0;\n    this.y = y || 0;\n    return this;\n  },\n  // Compute the angle between the vector from 0,0 to me and the vector from 0,0 to p.\n  // Returns NaN if p is at 0,0.\n  vectorAngle: function (p) {\n    var zero = new Point(0, 0);\n    return zero.angleBetween(this, p);\n  }\n};\nPoint.prototype.translate = Point.prototype.offset; // For backwards compatibility:\n\nexport const point = Point;","map":{"version":3,"names":["normalizeAngle","random","snapToGrid","toDeg","toRad","bearing","squaredLength","length","types","abs","cos","sin","sqrt","min","max","atan2","round","pow","PI","Math","Point","x","y","xy","split","indexOf","parseFloat","Object","undefined","fromPolar","distance","angle","origin","deg","x1","x2","y1","y2","prototype","type","chooseClosest","points","n","closest","minSqrDistance","Infinity","i","p","sqrDistance","squaredDistance","adhereToRect","r","containsPoint","width","height","angleBetween","p1","p2","equals","NaN","theta","point","changeInAngle","dx","dy","ref","clone","offset","cross","difference","dot","lerp","t","magnitude","manhattanDistance","move","normalize","scale","reflection","rotate","cosAngle","sinAngle","precision","f","sx","sy","gx","gy","rad","toJSON","toPolar","o","toString","serialize","update","vectorAngle","zero","translate"],"sources":["C:/Users/Admin/dataflow-test/node_modules/jointjs/src/g/point.mjs"],"sourcesContent":["/*\n    Point is the most basic object consisting of x/y coordinate.\n\n    Possible instantiations are:\n    * `Point(10, 20)`\n    * `new Point(10, 20)`\n    * `Point('10 20')`\n    * `Point(Point(10, 20))`\n*/\nimport { normalizeAngle, random, snapToGrid, toDeg, toRad } from './geometry.helpers.mjs';\nimport { bearing } from './line.bearing.mjs';\nimport { squaredLength } from './line.squaredLength.mjs';\nimport { length } from './line.length.mjs';\nimport { types } from './types.mjs';\n\nconst {\n    abs,\n    cos,\n    sin,\n    sqrt,\n    min,\n    max,\n    atan2,\n    round,\n    pow,\n    PI\n} = Math;\n\nexport const Point = function(x, y) {\n\n    if (!(this instanceof Point)) {\n        return new Point(x, y);\n    }\n\n    if (typeof x === 'string') {\n        var xy = x.split(x.indexOf('@') === -1 ? ' ' : '@');\n        x = parseFloat(xy[0]);\n        y = parseFloat(xy[1]);\n\n    } else if (Object(x) === x) {\n        y = x.y;\n        x = x.x;\n    }\n\n    this.x = x === undefined ? 0 : x;\n    this.y = y === undefined ? 0 : y;\n};\n\n// Alternative constructor, from polar coordinates.\n// @param {number} Distance.\n// @param {number} Angle in radians.\n// @param {point} [optional] Origin.\nPoint.fromPolar = function(distance, angle, origin) {\n\n    origin = new Point(origin);\n    var x = abs(distance * cos(angle));\n    var y = abs(distance * sin(angle));\n    var deg = normalizeAngle(toDeg(angle));\n\n    if (deg < 90) {\n        y = -y;\n\n    } else if (deg < 180) {\n        x = -x;\n        y = -y;\n\n    } else if (deg < 270) {\n        x = -x;\n    }\n\n    return new Point(origin.x + x, origin.y + y);\n};\n\n// Create a point with random coordinates that fall into the range `[x1, x2]` and `[y1, y2]`.\nPoint.random = function(x1, x2, y1, y2) {\n\n    return new Point(random(x1, x2), random(y1, y2));\n};\n\nPoint.prototype = {\n\n    type: types.Point,\n\n    chooseClosest: function(points) {\n\n        var n = points.length;\n        if (n === 1) return new Point(points[0]);\n        var closest = null;\n        var minSqrDistance = Infinity;\n        for (var i = 0; i < n; i++) {\n            var p = new Point(points[i]);\n            var sqrDistance = this.squaredDistance(p);\n            if (sqrDistance < minSqrDistance) {\n                closest = p;\n                minSqrDistance = sqrDistance;\n            }\n        }\n        return closest;\n    },\n\n    // If point lies outside rectangle `r`, return the nearest point on the boundary of rect `r`,\n    // otherwise return point itself.\n    // (see Squeak Smalltalk, Point>>adhereTo:)\n    adhereToRect: function(r) {\n\n        if (r.containsPoint(this)) {\n            return this;\n        }\n\n        this.x = min(max(this.x, r.x), r.x + r.width);\n        this.y = min(max(this.y, r.y), r.y + r.height);\n        return this;\n    },\n\n    // Compute the angle between vector from me to p1 and the vector from me to p2.\n    // ordering of points p1 and p2 is important!\n    // theta function's angle convention:\n    // returns angles between 0 and 180 when the angle is counterclockwise\n    // returns angles between 180 and 360 to convert clockwise angles into counterclockwise ones\n    // returns NaN if any of the points p1, p2 is coincident with this point\n    angleBetween: function(p1, p2) {\n\n        var angleBetween = (this.equals(p1) || this.equals(p2)) ? NaN : (this.theta(p2) - this.theta(p1));\n\n        if (angleBetween < 0) {\n            angleBetween += 360; // correction to keep angleBetween between 0 and 360\n        }\n\n        return angleBetween;\n    },\n\n    // Return the bearing between me and the given point.\n    bearing: function(point) {\n        return bearing(this, point);\n    },\n\n    // Returns change in angle from my previous position (-dx, -dy) to my new position\n    // relative to ref point.\n    changeInAngle: function(dx, dy, ref) {\n\n        // Revert the translation and measure the change in angle around x-axis.\n        return this.clone().offset(-dx, -dy).theta(ref) - this.theta(ref);\n    },\n\n    clone: function() {\n\n        return new Point(this);\n    },\n\n    // Returns the cross product of this point relative to two other points\n    // this point is the common point\n    // point p1 lies on the first vector, point p2 lies on the second vector\n    // watch out for the ordering of points p1 and p2!\n    // positive result indicates a clockwise (\"right\") turn from first to second vector\n    // negative result indicates a counterclockwise (\"left\") turn from first to second vector\n    // zero indicates that the first and second vector are collinear\n    // note that the above directions are reversed from the usual answer on the Internet\n    // that is because we are in a left-handed coord system (because the y-axis points downward)\n    cross: function(p1, p2) {\n\n        return (p1 && p2) ? (((p2.x - this.x) * (p1.y - this.y)) - ((p2.y - this.y) * (p1.x - this.x))) : NaN;\n    },\n\n    difference: function(dx, dy) {\n\n        if ((Object(dx) === dx)) {\n            dy = dx.y;\n            dx = dx.x;\n        }\n\n        return new Point(this.x - (dx || 0), this.y - (dy || 0));\n    },\n\n    // Returns distance between me and point `p`.\n    distance: function(p) {\n        return length(this, p);\n    },\n\n    // Returns the dot product of this point with given other point\n    dot: function(p) {\n\n        return p ? (this.x * p.x + this.y * p.y) : NaN;\n    },\n\n    equals: function(p) {\n\n        return !!p &&\n            this.x === p.x &&\n            this.y === p.y;\n    },\n\n    // Linear interpolation\n    lerp: function(p, t) {\n\n        var x = this.x;\n        var y = this.y;\n        return new Point((1 - t) * x + t * p.x, (1 - t) * y + t * p.y);\n    },\n\n    magnitude: function() {\n\n        return sqrt((this.x * this.x) + (this.y * this.y)) || 0.01;\n    },\n\n    // Returns a manhattan (taxi-cab) distance between me and point `p`.\n    manhattanDistance: function(p) {\n\n        return abs(p.x - this.x) + abs(p.y - this.y);\n    },\n\n    // Move point on line starting from ref ending at me by\n    // distance distance.\n    move: function(ref, distance) {\n\n        var theta = toRad((new Point(ref)).theta(this));\n        var offset = this.offset(cos(theta) * distance, -sin(theta) * distance);\n        return offset;\n    },\n\n    // Scales x and y such that the distance between the point and the origin (0,0) is equal to the given length.\n    normalize: function(length) {\n\n        var scale = (length || 1) / this.magnitude();\n        return this.scale(scale, scale);\n    },\n\n    // Offset me by the specified amount.\n    offset: function(dx, dy) {\n\n        if ((Object(dx) === dx)) {\n            dy = dx.y;\n            dx = dx.x;\n        }\n\n        this.x += dx || 0;\n        this.y += dy || 0;\n        return this;\n    },\n\n    // Returns a point that is the reflection of me with\n    // the center of inversion in ref point.\n    reflection: function(ref) {\n\n        return (new Point(ref)).move(this, this.distance(ref));\n    },\n\n    // Rotate point by angle around origin.\n    // Angle is flipped because this is a left-handed coord system (y-axis points downward).\n    rotate: function(origin, angle) {\n\n        if (angle === 0) return this;\n\n        origin = origin || new Point(0, 0);\n\n        angle = toRad(normalizeAngle(-angle));\n        var cosAngle = cos(angle);\n        var sinAngle = sin(angle);\n\n        var x = (cosAngle * (this.x - origin.x)) - (sinAngle * (this.y - origin.y)) + origin.x;\n        var y = (sinAngle * (this.x - origin.x)) + (cosAngle * (this.y - origin.y)) + origin.y;\n\n        this.x = x;\n        this.y = y;\n        return this;\n    },\n\n    round: function(precision) {\n\n        let f = 1; // case 0\n        if (precision) {\n            switch (precision) {\n                case 1: f = 10; break;\n                case 2: f = 100; break;\n                case 3: f = 1000; break;\n                default: f = pow(10, precision); break;\n            }\n        }\n\n        this.x = round(this.x * f) / f;\n        this.y = round(this.y * f) / f;\n        return this;\n    },\n\n    // Scale point with origin.\n    scale: function(sx, sy, origin) {\n\n        origin = (origin && new Point(origin)) || new Point(0, 0);\n        this.x = origin.x + sx * (this.x - origin.x);\n        this.y = origin.y + sy * (this.y - origin.y);\n        return this;\n    },\n\n    snapToGrid: function(gx, gy) {\n\n        this.x = snapToGrid(this.x, gx);\n        this.y = snapToGrid(this.y, gy || gx);\n        return this;\n    },\n\n    squaredDistance: function(p) {\n        return squaredLength(this, p);\n    },\n\n    // Compute the angle between me and `p` and the x axis.\n    // (cartesian-to-polar coordinates conversion)\n    // Return theta angle in degrees.\n    theta: function(p) {\n\n        p = new Point(p);\n\n        // Invert the y-axis.\n        var y = -(p.y - this.y);\n        var x = p.x - this.x;\n        var rad = atan2(y, x); // defined for all 0 corner cases\n\n        // Correction for III. and IV. quadrant.\n        if (rad < 0) {\n            rad = 2 * PI + rad;\n        }\n\n        return 180 * rad / PI;\n    },\n\n    toJSON: function() {\n\n        return { x: this.x, y: this.y };\n    },\n\n    // Converts rectangular to polar coordinates.\n    // An origin can be specified, otherwise it's 0@0.\n    toPolar: function(o) {\n\n        o = (o && new Point(o)) || new Point(0, 0);\n        var x = this.x;\n        var y = this.y;\n        this.x = sqrt((x - o.x) * (x - o.x) + (y - o.y) * (y - o.y)); // r\n        this.y = toRad(o.theta(new Point(x, y)));\n        return this;\n    },\n\n    toString: function() {\n\n        return this.x + '@' + this.y;\n    },\n\n    serialize: function() {\n\n        return this.x + ',' + this.y;\n    },\n\n    update: function(x, y) {\n\n        if ((Object(x) === x)) {\n            y = x.y;\n            x = x.x;\n        }\n\n        this.x = x || 0;\n        this.y = y || 0;\n        return this;\n    },\n\n    // Compute the angle between the vector from 0,0 to me and the vector from 0,0 to p.\n    // Returns NaN if p is at 0,0.\n    vectorAngle: function(p) {\n\n        var zero = new Point(0, 0);\n        return zero.angleBetween(this, p);\n    }\n};\n\nPoint.prototype.translate = Point.prototype.offset;\n\n// For backwards compatibility:\nexport const point = Point;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}