{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport { config } from '../config/index.mjs';\nimport { assign, isFunction, toArray } from '../util/index.mjs';\nimport { CellView } from './CellView.mjs';\nimport { Cell } from './Cell.mjs';\nimport V from '../V/index.mjs';\nimport { elementViewPortPrototype } from './ports.mjs';\nimport { Rect, snapToGrid } from '../g/index.mjs';\nconst Flags = {\n  UPDATE: 'UPDATE',\n  TRANSLATE: 'TRANSLATE',\n  TOOLS: 'TOOLS',\n  RESIZE: 'RESIZE',\n  PORTS: 'PORTS',\n  ROTATE: 'ROTATE',\n  RENDER: 'RENDER'\n}; // Element base view and controller.\n// -------------------------------------------\n\nexport const ElementView = CellView.extend({\n  /**\n   * @abstract\n   */\n  _removePorts: function () {// implemented in ports.js\n  },\n\n  /**\n   *\n   * @abstract\n   */\n  _renderPorts: function () {// implemented in ports.js\n  },\n  className: function () {\n    var classNames = CellView.prototype.className.apply(this).split(' ');\n    classNames.push('element');\n    return classNames.join(' ');\n  },\n  initialize: function () {\n    CellView.prototype.initialize.apply(this, arguments);\n\n    this._initializePorts();\n  },\n  presentationAttributes: {\n    'attrs': [Flags.UPDATE],\n    'position': [Flags.TRANSLATE, Flags.TOOLS],\n    'size': [Flags.RESIZE, Flags.PORTS, Flags.TOOLS],\n    'angle': [Flags.ROTATE, Flags.TOOLS],\n    'markup': [Flags.RENDER],\n    'ports': [Flags.PORTS]\n  },\n  initFlag: [Flags.RENDER],\n  UPDATE_PRIORITY: 0,\n  confirmUpdate: function (flag, opt) {\n    const {\n      useCSSSelectors\n    } = config;\n\n    if (this.hasFlag(flag, Flags.PORTS)) {\n      this._removePorts();\n\n      this._cleanPortsCache();\n    }\n\n    let transformHighlighters = false;\n\n    if (this.hasFlag(flag, Flags.RENDER)) {\n      this.render();\n      this.updateTools(opt);\n      this.updateHighlighters(true);\n      transformHighlighters = true;\n      flag = this.removeFlag(flag, [Flags.RENDER, Flags.UPDATE, Flags.RESIZE, Flags.TRANSLATE, Flags.ROTATE, Flags.PORTS, Flags.TOOLS]);\n    } else {\n      let updateHighlighters = false; // Skip this branch if render is required\n\n      if (this.hasFlag(flag, Flags.RESIZE)) {\n        this.resize(opt);\n        updateHighlighters = true; // Resize method is calling `update()` internally\n\n        flag = this.removeFlag(flag, [Flags.RESIZE, Flags.UPDATE]);\n      }\n\n      if (this.hasFlag(flag, Flags.UPDATE)) {\n        this.update(this.model, null, opt);\n        flag = this.removeFlag(flag, Flags.UPDATE);\n        updateHighlighters = true;\n\n        if (useCSSSelectors) {\n          // `update()` will render ports when useCSSSelectors are enabled\n          flag = this.removeFlag(flag, Flags.PORTS);\n        }\n      }\n\n      if (this.hasFlag(flag, Flags.TRANSLATE)) {\n        this.translate();\n        flag = this.removeFlag(flag, Flags.TRANSLATE);\n        transformHighlighters = true;\n      }\n\n      if (this.hasFlag(flag, Flags.ROTATE)) {\n        this.rotate();\n        flag = this.removeFlag(flag, Flags.ROTATE);\n        transformHighlighters = true;\n      }\n\n      if (this.hasFlag(flag, Flags.PORTS)) {\n        this._renderPorts();\n\n        updateHighlighters = true;\n        flag = this.removeFlag(flag, Flags.PORTS);\n      }\n\n      if (updateHighlighters) {\n        this.updateHighlighters(false);\n      }\n    }\n\n    if (transformHighlighters) {\n      this.transformHighlighters();\n    }\n\n    if (this.hasFlag(flag, Flags.TOOLS)) {\n      this.updateTools(opt);\n      flag = this.removeFlag(flag, Flags.TOOLS);\n    }\n\n    return flag;\n  },\n\n  /**\n   * @abstract\n   */\n  _initializePorts: function () {},\n  update: function (_, renderingOnlyAttrs) {\n    this.cleanNodesCache(); // When CSS selector strings are used, make sure no rule matches port nodes.\n\n    const {\n      useCSSSelectors\n    } = config;\n    if (useCSSSelectors) this._removePorts();\n    var model = this.model;\n    var modelAttrs = model.attr();\n    this.updateDOMSubtreeAttributes(this.el, modelAttrs, {\n      rootBBox: new Rect(model.size()),\n      selectors: this.selectors,\n      scalableNode: this.scalableNode,\n      rotatableNode: this.rotatableNode,\n      // Use rendering only attributes if they differs from the model attributes\n      roAttributes: renderingOnlyAttrs === modelAttrs ? null : renderingOnlyAttrs\n    });\n\n    if (useCSSSelectors) {\n      this._renderPorts();\n    }\n  },\n  rotatableSelector: 'rotatable',\n  scalableSelector: 'scalable',\n  scalableNode: null,\n  rotatableNode: null,\n  // `prototype.markup` is rendered by default. Set the `markup` attribute on the model if the\n  // default markup is not desirable.\n  renderMarkup: function () {\n    var element = this.model;\n    var markup = element.get('markup') || element.markup;\n    if (!markup) throw new Error('dia.ElementView: markup required');\n    if (Array.isArray(markup)) return this.renderJSONMarkup(markup);\n    if (typeof markup === 'string') return this.renderStringMarkup(markup);\n    throw new Error('dia.ElementView: invalid markup');\n  },\n  renderJSONMarkup: function (markup) {\n    var doc = this.parseDOMJSON(markup, this.el);\n    var selectors = this.selectors = doc.selectors;\n    this.rotatableNode = V(selectors[this.rotatableSelector]) || null;\n    this.scalableNode = V(selectors[this.scalableSelector]) || null; // Fragment\n\n    this.vel.append(doc.fragment);\n  },\n  renderStringMarkup: function (markup) {\n    var vel = this.vel;\n    vel.append(V(markup)); // Cache transformation groups\n\n    this.rotatableNode = vel.findOne('.rotatable');\n    this.scalableNode = vel.findOne('.scalable');\n    var selectors = this.selectors = {};\n    selectors[this.selector] = this.el;\n  },\n  render: function () {\n    this.vel.empty();\n    this.renderMarkup();\n\n    if (this.scalableNode) {\n      // Double update is necessary for elements with the scalable group only\n      // Note the resize() triggers the other `update`.\n      this.update();\n    }\n\n    this.resize();\n\n    if (this.rotatableNode) {\n      // Translate transformation is applied on `this.el` while the rotation transformation\n      // on `this.rotatableNode`\n      this.rotate();\n      this.translate();\n    } else {\n      this.updateTransformation();\n    }\n\n    if (!config.useCSSSelectors) this._renderPorts();\n    return this;\n  },\n  resize: function (opt) {\n    if (this.scalableNode) return this.sgResize(opt);\n    if (this.model.attributes.angle) this.rotate();\n    this.update();\n  },\n  translate: function () {\n    if (this.rotatableNode) return this.rgTranslate();\n    this.updateTransformation();\n  },\n  rotate: function () {\n    if (this.rotatableNode) {\n      this.rgRotate(); // It's necessary to call the update for the nodes outside\n      // the rotatable group referencing nodes inside the group\n\n      this.update();\n      return;\n    }\n\n    this.updateTransformation();\n  },\n  updateTransformation: function () {\n    var transformation = this.getTranslateString();\n    var rotateString = this.getRotateString();\n    if (rotateString) transformation += ' ' + rotateString;\n    this.vel.attr('transform', transformation);\n  },\n  getTranslateString: function () {\n    var position = this.model.attributes.position;\n    return 'translate(' + position.x + ',' + position.y + ')';\n  },\n  getRotateString: function () {\n    var attributes = this.model.attributes;\n    var angle = attributes.angle;\n    if (!angle) return null;\n    var size = attributes.size;\n    return 'rotate(' + angle + ',' + size.width / 2 + ',' + size.height / 2 + ')';\n  },\n  // Rotatable & Scalable Group\n  // always slower, kept mainly for backwards compatibility\n  rgRotate: function () {\n    this.rotatableNode.attr('transform', this.getRotateString());\n  },\n  rgTranslate: function () {\n    this.vel.attr('transform', this.getTranslateString());\n  },\n  sgResize: function (opt) {\n    var model = this.model;\n    var angle = model.angle();\n    var size = model.size();\n    var scalable = this.scalableNode; // Getting scalable group's bbox.\n    // Due to a bug in webkit's native SVG .getBBox implementation, the bbox of groups with path children includes the paths' control points.\n    // To work around the issue, we need to check whether there are any path elements inside the scalable group.\n\n    var recursive = false;\n\n    if (scalable.node.getElementsByTagName('path').length > 0) {\n      // If scalable has at least one descendant that is a path, we need to switch to recursive bbox calculation.\n      // If there are no path descendants, group bbox calculation works and so we can use the (faster) native function directly.\n      recursive = true;\n    }\n\n    var scalableBBox = scalable.getBBox({\n      recursive: recursive\n    }); // Make sure `scalableBbox.width` and `scalableBbox.height` are not zero which can happen if the element does not have any content. By making\n    // the width/height 1, we prevent HTML errors of the type `scale(Infinity, Infinity)`.\n\n    var sx = size.width / (scalableBBox.width || 1);\n    var sy = size.height / (scalableBBox.height || 1);\n    scalable.attr('transform', 'scale(' + sx + ',' + sy + ')'); // Now the interesting part. The goal is to be able to store the object geometry via just `x`, `y`, `angle`, `width` and `height`\n    // Order of transformations is significant but we want to reconstruct the object always in the order:\n    // resize(), rotate(), translate() no matter of how the object was transformed. For that to work,\n    // we must adjust the `x` and `y` coordinates of the object whenever we resize it (because the origin of the\n    // rotation changes). The new `x` and `y` coordinates are computed by canceling the previous rotation\n    // around the center of the resized object (which is a different origin then the origin of the previous rotation)\n    // and getting the top-left corner of the resulting object. Then we clean up the rotation back to what it originally was.\n    // Cancel the rotation but now around a different origin, which is the center of the scaled object.\n\n    var rotatable = this.rotatableNode;\n    var rotation = rotatable && rotatable.attr('transform');\n\n    if (rotation) {\n      rotatable.attr('transform', rotation + ' rotate(' + -angle + ',' + size.width / 2 + ',' + size.height / 2 + ')');\n      var rotatableBBox = scalable.getBBox({\n        target: this.paper.cells\n      }); // Store new x, y and perform rotate() again against the new rotation origin.\n\n      model.set('position', {\n        x: rotatableBBox.x,\n        y: rotatableBBox.y\n      }, assign({\n        updateHandled: true\n      }, opt));\n      this.translate();\n      this.rotate();\n    } // Update must always be called on non-rotated element. Otherwise, relative positioning\n    // would work with wrong (rotated) bounding boxes.\n\n\n    this.update();\n  },\n  // Embedding mode methods.\n  // -----------------------\n  prepareEmbedding: function (data = {}) {\n    const element = data.model || this.model;\n    const paper = data.paper || this.paper;\n    const graph = paper.model;\n    const initialZIndices = data.initialZIndices = {};\n    const embeddedCells = element.getEmbeddedCells({\n      deep: true\n    });\n    const connectedLinks = graph.getConnectedLinks(element, {\n      deep: true,\n      includeEnclosed: true\n    }); // Note: an embedded cell can be a connect link, but it's fine\n    // to iterate over the cell twice.\n\n    [element, ...embeddedCells, ...connectedLinks].forEach(cell => initialZIndices[cell.id] = cell.attributes.z);\n    element.startBatch('to-front'); // Bring the model to the front with all his embeds.\n\n    element.toFront({\n      deep: true,\n      ui: true\n    }); // Note that at this point cells in the collection are not sorted by z index (it's running in the batch, see\n    // the dia.Graph._sortOnChangeZ), so we can't assume that the last cell in the collection has the highest z.\n\n    const maxZ = graph.getElements().reduce((max, cell) => Math.max(max, cell.attributes.z || 0), 0); // Move to front also all the inbound and outbound links that are connected\n    // to any of the element descendant. If we bring to front only embedded elements,\n    // links connected to them would stay in the background.\n\n    connectedLinks.forEach(link => {\n      if (link.attributes.z <= maxZ) {\n        link.set('z', maxZ + 1, {\n          ui: true\n        });\n      }\n    });\n    element.stopBatch('to-front'); // Before we start looking for suitable parent we remove the current one.\n\n    const parentId = element.parent();\n\n    if (parentId) {\n      const parent = graph.getCell(parentId);\n      parent.unembed(element, {\n        ui: true\n      });\n      data.initialParentId = parentId;\n    } else {\n      data.initialParentId = null;\n    }\n  },\n  processEmbedding: function (data = {}, evt, x, y) {\n    const model = data.model || this.model;\n    const paper = data.paper || this.paper;\n    const graph = paper.model;\n    const {\n      findParentBy,\n      frontParentOnly,\n      validateEmbedding\n    } = paper.options;\n    let candidates;\n\n    if (isFunction(findParentBy)) {\n      candidates = toArray(findParentBy.call(graph, this, evt, x, y));\n    } else if (findParentBy === 'pointer') {\n      candidates = toArray(graph.findModelsFromPoint({\n        x,\n        y\n      }));\n    } else {\n      candidates = graph.findModelsUnderElement(model, {\n        searchBy: findParentBy\n      });\n    }\n\n    candidates = candidates.filter(el => {\n      return el instanceof Cell && model.id !== el.id && !el.isEmbeddedIn(model);\n    });\n\n    if (frontParentOnly) {\n      // pick the element with the highest `z` index\n      candidates = candidates.slice(-1);\n    }\n\n    let newCandidateView = null;\n    const prevCandidateView = data.candidateEmbedView; // iterate over all candidates starting from the last one (has the highest z-index).\n\n    for (let i = candidates.length - 1; i >= 0; i--) {\n      const candidate = candidates[i];\n\n      if (prevCandidateView && prevCandidateView.model.id == candidate.id) {\n        // candidate remains the same\n        newCandidateView = prevCandidateView;\n        break;\n      } else {\n        const view = candidate.findView(paper);\n\n        if (!isFunction(validateEmbedding) || validateEmbedding.call(paper, this, view)) {\n          // flip to the new candidate\n          newCandidateView = view;\n          break;\n        }\n      }\n    }\n\n    if (newCandidateView && newCandidateView != prevCandidateView) {\n      // A new candidate view found. Highlight the new one.\n      this.clearEmbedding(data);\n      data.candidateEmbedView = newCandidateView.highlight(newCandidateView.findProxyNode(null, 'container'), {\n        embedding: true\n      });\n    }\n\n    if (!newCandidateView && prevCandidateView) {\n      // No candidate view found. Unhighlight the previous candidate.\n      this.clearEmbedding(data);\n    }\n  },\n  clearEmbedding: function (data) {\n    data || (data = {});\n    var candidateView = data.candidateEmbedView;\n\n    if (candidateView) {\n      // No candidate view found. Unhighlight the previous candidate.\n      candidateView.unhighlight(candidateView.findProxyNode(null, 'container'), {\n        embedding: true\n      });\n      data.candidateEmbedView = null;\n    }\n  },\n  finalizeEmbedding: function (data = {}) {\n    const candidateView = data.candidateEmbedView;\n    const element = data.model || this.model;\n    const paper = data.paper || this.paper;\n\n    if (candidateView) {\n      // We finished embedding. Candidate view is chosen to become the parent of the model.\n      candidateView.model.embed(element, {\n        ui: true\n      });\n      candidateView.unhighlight(candidateView.findProxyNode(null, 'container'), {\n        embedding: true\n      });\n      data.candidateEmbedView = null;\n    } else {\n      const {\n        validateUnembedding\n      } = paper.options;\n      const {\n        initialParentId\n      } = data; // The element was originally embedded into another element.\n      // The interaction would unembed the element. Let's validate\n      // if the element can be unembedded.\n\n      if (initialParentId && typeof validateUnembedding === 'function' && !validateUnembedding.call(paper, this)) {\n        this._disallowUnembed(data);\n\n        return;\n      }\n    }\n\n    paper.model.getConnectedLinks(element, {\n      deep: true\n    }).forEach(link => {\n      link.reparent({\n        ui: true\n      });\n    });\n  },\n  _disallowUnembed: function (data) {\n    const {\n      model,\n      whenNotAllowed = 'revert'\n    } = data;\n    const element = model || this.model;\n    const paper = data.paper || this.paper;\n    const graph = paper.model;\n\n    switch (whenNotAllowed) {\n      case 'remove':\n        {\n          element.remove({\n            ui: true\n          });\n          break;\n        }\n\n      case 'revert':\n        {\n          const {\n            initialParentId,\n            initialPosition,\n            initialZIndices\n          } = data; // Revert the element's position (and the position of its embedded cells if any)\n\n          if (initialPosition) {\n            const {\n              x,\n              y\n            } = initialPosition;\n            element.position(x, y, {\n              deep: true,\n              ui: true\n            });\n          } // Revert all the z-indices changed during the embedding\n\n\n          if (initialZIndices) {\n            Object.keys(initialZIndices).forEach(id => {\n              const cell = graph.getCell(id);\n\n              if (cell) {\n                cell.set('z', initialZIndices[id], {\n                  ui: true\n                });\n              }\n            });\n          } // Revert the original parent\n\n\n          const parent = graph.getCell(initialParentId);\n\n          if (parent) {\n            parent.embed(element, {\n              ui: true\n            });\n          }\n\n          break;\n        }\n    }\n  },\n  getDelegatedView: function () {\n    var view = this;\n    var model = view.model;\n    var paper = view.paper;\n\n    while (view) {\n      if (model.isLink()) break;\n      if (!model.isEmbedded() || view.can('stopDelegation')) return view;\n      model = model.getParentCell();\n      view = paper.findViewByModel(model);\n    }\n\n    return null;\n  },\n  findProxyNode: function (el, type) {\n    el || (el = this.el);\n    const nodeSelector = el.getAttribute(`${type}-selector`);\n\n    if (nodeSelector) {\n      const port = this.findAttribute('port', el);\n\n      if (port) {\n        const proxyPortNode = this.findPortNode(port, nodeSelector);\n        if (proxyPortNode) return proxyPortNode;\n      } else {\n        const [proxyNode] = this.findBySelector(nodeSelector);\n        if (proxyNode) return proxyNode;\n      }\n    }\n\n    return el;\n  },\n\n  // Interaction. The controller part.\n  // ---------------------------------\n  notifyPointerdown(evt, x, y) {\n    CellView.prototype.pointerdown.call(this, evt, x, y);\n    this.notify('element:pointerdown', evt, x, y);\n  },\n\n  notifyPointermove(evt, x, y) {\n    CellView.prototype.pointermove.call(this, evt, x, y);\n    this.notify('element:pointermove', evt, x, y);\n  },\n\n  notifyPointerup(evt, x, y) {\n    this.notify('element:pointerup', evt, x, y);\n    CellView.prototype.pointerup.call(this, evt, x, y);\n  },\n\n  pointerdblclick: function (evt, x, y) {\n    CellView.prototype.pointerdblclick.apply(this, arguments);\n    this.notify('element:pointerdblclick', evt, x, y);\n  },\n  pointerclick: function (evt, x, y) {\n    CellView.prototype.pointerclick.apply(this, arguments);\n    this.notify('element:pointerclick', evt, x, y);\n  },\n  contextmenu: function (evt, x, y) {\n    CellView.prototype.contextmenu.apply(this, arguments);\n    this.notify('element:contextmenu', evt, x, y);\n  },\n  pointerdown: function (evt, x, y) {\n    if (this.isPropagationStopped(evt)) return;\n    this.notifyPointerdown(evt, x, y);\n    this.dragStart(evt, x, y);\n  },\n  pointermove: function (evt, x, y) {\n    var data = this.eventData(evt);\n\n    switch (data.action) {\n      case 'magnet':\n        this.dragMagnet(evt, x, y);\n        break;\n\n      case 'move':\n        (data.delegatedView || this).drag(evt, x, y);\n      // eslint: no-fallthrough=false\n\n      default:\n        this.notifyPointermove(evt, x, y);\n        break;\n    } // Make sure the element view data is passed along.\n    // It could have been wiped out in the handlers above.\n\n\n    this.eventData(evt, data);\n  },\n  pointerup: function (evt, x, y) {\n    var data = this.eventData(evt);\n\n    switch (data.action) {\n      case 'magnet':\n        this.dragMagnetEnd(evt, x, y);\n        break;\n\n      case 'move':\n        (data.delegatedView || this).dragEnd(evt, x, y);\n      // eslint: no-fallthrough=false\n\n      default:\n        this.notifyPointerup(evt, x, y);\n    }\n\n    var magnet = data.targetMagnet;\n    if (magnet) this.magnetpointerclick(evt, magnet, x, y);\n    this.checkMouseleave(evt);\n  },\n  mouseover: function (evt) {\n    CellView.prototype.mouseover.apply(this, arguments);\n    this.notify('element:mouseover', evt);\n  },\n  mouseout: function (evt) {\n    CellView.prototype.mouseout.apply(this, arguments);\n    this.notify('element:mouseout', evt);\n  },\n  mouseenter: function (evt) {\n    CellView.prototype.mouseenter.apply(this, arguments);\n    this.notify('element:mouseenter', evt);\n  },\n  mouseleave: function (evt) {\n    CellView.prototype.mouseleave.apply(this, arguments);\n    this.notify('element:mouseleave', evt);\n  },\n  mousewheel: function (evt, x, y, delta) {\n    CellView.prototype.mousewheel.apply(this, arguments);\n    this.notify('element:mousewheel', evt, x, y, delta);\n  },\n  onmagnet: function (evt, x, y) {\n    this.dragMagnetStart(evt, x, y);\n  },\n  magnetpointerdblclick: function (evt, magnet, x, y) {\n    this.notify('element:magnet:pointerdblclick', evt, magnet, x, y);\n  },\n  magnetcontextmenu: function (evt, magnet, x, y) {\n    this.notify('element:magnet:contextmenu', evt, magnet, x, y);\n  },\n  // Drag Start Handlers\n  dragStart: function (evt, x, y) {\n    var view = this.getDelegatedView();\n    if (!view || !view.can('elementMove')) return;\n    this.eventData(evt, {\n      action: 'move',\n      delegatedView: view\n    });\n    const position = view.model.position();\n    view.eventData(evt, {\n      initialPosition: position,\n      pointerOffset: position.difference(x, y),\n      restrictedArea: this.paper.getRestrictedArea(view, x, y)\n    });\n  },\n  dragMagnetStart: function (evt, x, y) {\n    if (!this.can('addLinkFromMagnet')) return;\n    var magnet = evt.currentTarget;\n    var paper = this.paper;\n    this.eventData(evt, {\n      targetMagnet: magnet\n    });\n    evt.stopPropagation();\n\n    if (paper.options.validateMagnet(this, magnet, evt)) {\n      if (paper.options.magnetThreshold <= 0) {\n        this.dragLinkStart(evt, magnet, x, y);\n      }\n\n      this.eventData(evt, {\n        action: 'magnet'\n      });\n      this.stopPropagation(evt);\n    } else {\n      this.pointerdown(evt, x, y);\n    }\n\n    paper.delegateDragEvents(this, evt.data);\n  },\n  // Drag Handlers\n  drag: function (evt, x, y) {\n    var paper = this.paper;\n    var grid = paper.options.gridSize;\n    var element = this.model;\n    var data = this.eventData(evt);\n    var {\n      pointerOffset,\n      restrictedArea,\n      embedding\n    } = data; // Make sure the new element's position always snaps to the current grid\n\n    var elX = snapToGrid(x + pointerOffset.x, grid);\n    var elY = snapToGrid(y + pointerOffset.y, grid);\n    element.position(elX, elY, {\n      restrictedArea,\n      deep: true,\n      ui: true\n    });\n\n    if (paper.options.embeddingMode) {\n      if (!embedding) {\n        // Prepare the element for embedding only if the pointer moves.\n        // We don't want to do unnecessary action with the element\n        // if an user only clicks/dblclicks on it.\n        this.prepareEmbedding(data);\n        embedding = true;\n      }\n\n      this.processEmbedding(data, evt, x, y);\n    }\n\n    this.eventData(evt, {\n      embedding\n    });\n  },\n  dragMagnet: function (evt, x, y) {\n    this.dragLink(evt, x, y);\n  },\n  // Drag End Handlers\n  dragEnd: function (evt, x, y) {\n    var data = this.eventData(evt);\n    if (data.embedding) this.finalizeEmbedding(data);\n  },\n  dragMagnetEnd: function (evt, x, y) {\n    this.dragLinkEnd(evt, x, y);\n  },\n  magnetpointerclick: function (evt, magnet, x, y) {\n    var paper = this.paper;\n    if (paper.eventData(evt).mousemoved > paper.options.clickThreshold) return;\n    this.notify('element:magnet:pointerclick', evt, magnet, x, y);\n  }\n}, {\n  Flags: Flags\n});\nassign(ElementView.prototype, elementViewPortPrototype);","map":{"version":3,"names":["config","assign","isFunction","toArray","CellView","Cell","V","elementViewPortPrototype","Rect","snapToGrid","Flags","UPDATE","TRANSLATE","TOOLS","RESIZE","PORTS","ROTATE","RENDER","ElementView","extend","_removePorts","_renderPorts","className","classNames","prototype","apply","split","push","join","initialize","arguments","_initializePorts","presentationAttributes","initFlag","UPDATE_PRIORITY","confirmUpdate","flag","opt","useCSSSelectors","hasFlag","_cleanPortsCache","transformHighlighters","render","updateTools","updateHighlighters","removeFlag","resize","update","model","translate","rotate","_","renderingOnlyAttrs","cleanNodesCache","modelAttrs","attr","updateDOMSubtreeAttributes","el","rootBBox","size","selectors","scalableNode","rotatableNode","roAttributes","rotatableSelector","scalableSelector","renderMarkup","element","markup","get","Error","Array","isArray","renderJSONMarkup","renderStringMarkup","doc","parseDOMJSON","vel","append","fragment","findOne","selector","empty","updateTransformation","sgResize","attributes","angle","rgTranslate","rgRotate","transformation","getTranslateString","rotateString","getRotateString","position","x","y","width","height","scalable","recursive","node","getElementsByTagName","length","scalableBBox","getBBox","sx","sy","rotatable","rotation","rotatableBBox","target","paper","cells","set","updateHandled","prepareEmbedding","data","graph","initialZIndices","embeddedCells","getEmbeddedCells","deep","connectedLinks","getConnectedLinks","includeEnclosed","forEach","cell","id","z","startBatch","toFront","ui","maxZ","getElements","reduce","max","Math","link","stopBatch","parentId","parent","getCell","unembed","initialParentId","processEmbedding","evt","findParentBy","frontParentOnly","validateEmbedding","options","candidates","call","findModelsFromPoint","findModelsUnderElement","searchBy","filter","isEmbeddedIn","slice","newCandidateView","prevCandidateView","candidateEmbedView","i","candidate","view","findView","clearEmbedding","highlight","findProxyNode","embedding","candidateView","unhighlight","finalizeEmbedding","embed","validateUnembedding","_disallowUnembed","reparent","whenNotAllowed","remove","initialPosition","Object","keys","getDelegatedView","isLink","isEmbedded","can","getParentCell","findViewByModel","type","nodeSelector","getAttribute","port","findAttribute","proxyPortNode","findPortNode","proxyNode","findBySelector","notifyPointerdown","pointerdown","notify","notifyPointermove","pointermove","notifyPointerup","pointerup","pointerdblclick","pointerclick","contextmenu","isPropagationStopped","dragStart","eventData","action","dragMagnet","delegatedView","drag","dragMagnetEnd","dragEnd","magnet","targetMagnet","magnetpointerclick","checkMouseleave","mouseover","mouseout","mouseenter","mouseleave","mousewheel","delta","onmagnet","dragMagnetStart","magnetpointerdblclick","magnetcontextmenu","pointerOffset","difference","restrictedArea","getRestrictedArea","currentTarget","stopPropagation","validateMagnet","magnetThreshold","dragLinkStart","delegateDragEvents","grid","gridSize","elX","elY","embeddingMode","dragLink","dragLinkEnd","mousemoved","clickThreshold"],"sources":["C:/Users/Admin/dataflow-test/node_modules/jointjs/src/dia/ElementView.mjs"],"sourcesContent":["import { config } from '../config/index.mjs';\nimport { assign, isFunction, toArray } from '../util/index.mjs';\nimport { CellView } from './CellView.mjs';\nimport { Cell } from './Cell.mjs';\nimport V from '../V/index.mjs';\nimport { elementViewPortPrototype } from './ports.mjs';\nimport { Rect, snapToGrid } from '../g/index.mjs';\n\nconst Flags = {\n    UPDATE: 'UPDATE',\n    TRANSLATE: 'TRANSLATE',\n    TOOLS: 'TOOLS',\n    RESIZE: 'RESIZE',\n    PORTS: 'PORTS',\n    ROTATE: 'ROTATE',\n    RENDER: 'RENDER'\n};\n\n// Element base view and controller.\n// -------------------------------------------\n\nexport const ElementView = CellView.extend({\n\n    /**\n     * @abstract\n     */\n    _removePorts: function() {\n        // implemented in ports.js\n    },\n\n    /**\n     *\n     * @abstract\n     */\n    _renderPorts: function() {\n        // implemented in ports.js\n    },\n\n    className: function() {\n\n        var classNames = CellView.prototype.className.apply(this).split(' ');\n\n        classNames.push('element');\n\n        return classNames.join(' ');\n    },\n\n    initialize: function() {\n\n        CellView.prototype.initialize.apply(this, arguments);\n\n        this._initializePorts();\n    },\n\n    presentationAttributes: {\n        'attrs': [Flags.UPDATE],\n        'position': [Flags.TRANSLATE, Flags.TOOLS],\n        'size': [Flags.RESIZE, Flags.PORTS, Flags.TOOLS],\n        'angle': [Flags.ROTATE, Flags.TOOLS],\n        'markup': [Flags.RENDER],\n        'ports': [Flags.PORTS],\n    },\n\n    initFlag: [Flags.RENDER],\n\n    UPDATE_PRIORITY: 0,\n\n    confirmUpdate: function(flag, opt) {\n\n        const { useCSSSelectors } = config;\n        if (this.hasFlag(flag, Flags.PORTS)) {\n            this._removePorts();\n            this._cleanPortsCache();\n        }\n        let transformHighlighters = false;\n        if (this.hasFlag(flag, Flags.RENDER)) {\n            this.render();\n            this.updateTools(opt);\n            this.updateHighlighters(true);\n            transformHighlighters = true;\n            flag = this.removeFlag(flag, [Flags.RENDER, Flags.UPDATE, Flags.RESIZE, Flags.TRANSLATE, Flags.ROTATE, Flags.PORTS, Flags.TOOLS]);\n        } else {\n            let updateHighlighters = false;\n\n            // Skip this branch if render is required\n            if (this.hasFlag(flag, Flags.RESIZE)) {\n                this.resize(opt);\n                updateHighlighters = true;\n                // Resize method is calling `update()` internally\n                flag = this.removeFlag(flag, [Flags.RESIZE, Flags.UPDATE]);\n            }\n            if (this.hasFlag(flag, Flags.UPDATE)) {\n                this.update(this.model, null, opt);\n                flag = this.removeFlag(flag, Flags.UPDATE);\n                updateHighlighters = true;\n                if (useCSSSelectors) {\n                    // `update()` will render ports when useCSSSelectors are enabled\n                    flag = this.removeFlag(flag, Flags.PORTS);\n                }\n            }\n            if (this.hasFlag(flag, Flags.TRANSLATE)) {\n                this.translate();\n                flag = this.removeFlag(flag, Flags.TRANSLATE);\n                transformHighlighters = true;\n            }\n            if (this.hasFlag(flag, Flags.ROTATE)) {\n                this.rotate();\n                flag = this.removeFlag(flag, Flags.ROTATE);\n                transformHighlighters = true;\n            }\n            if (this.hasFlag(flag, Flags.PORTS)) {\n                this._renderPorts();\n                updateHighlighters = true;\n                flag = this.removeFlag(flag, Flags.PORTS);\n            }\n\n            if (updateHighlighters) {\n                this.updateHighlighters(false);\n            }\n        }\n\n        if (transformHighlighters) {\n            this.transformHighlighters();\n        }\n\n        if (this.hasFlag(flag, Flags.TOOLS)) {\n            this.updateTools(opt);\n            flag = this.removeFlag(flag, Flags.TOOLS);\n        }\n\n        return flag;\n    },\n\n    /**\n     * @abstract\n     */\n    _initializePorts: function() {\n\n    },\n\n    update: function(_, renderingOnlyAttrs) {\n\n        this.cleanNodesCache();\n\n        // When CSS selector strings are used, make sure no rule matches port nodes.\n        const { useCSSSelectors } = config;\n        if (useCSSSelectors) this._removePorts();\n\n        var model = this.model;\n        var modelAttrs = model.attr();\n        this.updateDOMSubtreeAttributes(this.el, modelAttrs, {\n            rootBBox: new Rect(model.size()),\n            selectors: this.selectors,\n            scalableNode: this.scalableNode,\n            rotatableNode: this.rotatableNode,\n            // Use rendering only attributes if they differs from the model attributes\n            roAttributes: (renderingOnlyAttrs === modelAttrs) ? null : renderingOnlyAttrs\n        });\n\n        if (useCSSSelectors) {\n            this._renderPorts();\n        }\n    },\n\n    rotatableSelector: 'rotatable',\n    scalableSelector: 'scalable',\n    scalableNode: null,\n    rotatableNode: null,\n\n    // `prototype.markup` is rendered by default. Set the `markup` attribute on the model if the\n    // default markup is not desirable.\n    renderMarkup: function() {\n\n        var element = this.model;\n        var markup = element.get('markup') || element.markup;\n        if (!markup) throw new Error('dia.ElementView: markup required');\n        if (Array.isArray(markup)) return this.renderJSONMarkup(markup);\n        if (typeof markup === 'string') return this.renderStringMarkup(markup);\n        throw new Error('dia.ElementView: invalid markup');\n    },\n\n    renderJSONMarkup: function(markup) {\n\n        var doc = this.parseDOMJSON(markup, this.el);\n        var selectors = this.selectors = doc.selectors;\n        this.rotatableNode = V(selectors[this.rotatableSelector]) || null;\n        this.scalableNode = V(selectors[this.scalableSelector]) || null;\n        // Fragment\n        this.vel.append(doc.fragment);\n    },\n\n    renderStringMarkup: function(markup) {\n\n        var vel = this.vel;\n        vel.append(V(markup));\n        // Cache transformation groups\n        this.rotatableNode = vel.findOne('.rotatable');\n        this.scalableNode = vel.findOne('.scalable');\n\n        var selectors = this.selectors = {};\n        selectors[this.selector] = this.el;\n    },\n\n    render: function() {\n\n        this.vel.empty();\n        this.renderMarkup();\n        if (this.scalableNode) {\n            // Double update is necessary for elements with the scalable group only\n            // Note the resize() triggers the other `update`.\n            this.update();\n        }\n        this.resize();\n        if (this.rotatableNode) {\n            // Translate transformation is applied on `this.el` while the rotation transformation\n            // on `this.rotatableNode`\n            this.rotate();\n            this.translate();\n        } else {\n            this.updateTransformation();\n        }\n        if (!config.useCSSSelectors) this._renderPorts();\n        return this;\n    },\n\n    resize: function(opt) {\n\n        if (this.scalableNode) return this.sgResize(opt);\n        if (this.model.attributes.angle) this.rotate();\n        this.update();\n    },\n\n    translate: function() {\n\n        if (this.rotatableNode) return this.rgTranslate();\n        this.updateTransformation();\n    },\n\n    rotate: function() {\n\n        if (this.rotatableNode) {\n            this.rgRotate();\n            // It's necessary to call the update for the nodes outside\n            // the rotatable group referencing nodes inside the group\n            this.update();\n            return;\n        }\n        this.updateTransformation();\n    },\n\n    updateTransformation: function() {\n\n        var transformation = this.getTranslateString();\n        var rotateString = this.getRotateString();\n        if (rotateString) transformation += ' ' + rotateString;\n        this.vel.attr('transform', transformation);\n    },\n\n    getTranslateString: function() {\n\n        var position = this.model.attributes.position;\n        return 'translate(' + position.x + ',' + position.y + ')';\n    },\n\n    getRotateString: function() {\n        var attributes = this.model.attributes;\n        var angle = attributes.angle;\n        if (!angle) return null;\n        var size = attributes.size;\n        return 'rotate(' + angle + ',' + (size.width / 2) + ',' + (size.height / 2) + ')';\n    },\n\n    // Rotatable & Scalable Group\n    // always slower, kept mainly for backwards compatibility\n\n    rgRotate: function() {\n\n        this.rotatableNode.attr('transform', this.getRotateString());\n    },\n\n    rgTranslate: function() {\n\n        this.vel.attr('transform', this.getTranslateString());\n    },\n\n    sgResize: function(opt) {\n\n        var model = this.model;\n        var angle = model.angle();\n        var size = model.size();\n        var scalable = this.scalableNode;\n\n        // Getting scalable group's bbox.\n        // Due to a bug in webkit's native SVG .getBBox implementation, the bbox of groups with path children includes the paths' control points.\n        // To work around the issue, we need to check whether there are any path elements inside the scalable group.\n        var recursive = false;\n        if (scalable.node.getElementsByTagName('path').length > 0) {\n            // If scalable has at least one descendant that is a path, we need to switch to recursive bbox calculation.\n            // If there are no path descendants, group bbox calculation works and so we can use the (faster) native function directly.\n            recursive = true;\n        }\n        var scalableBBox = scalable.getBBox({ recursive: recursive });\n\n        // Make sure `scalableBbox.width` and `scalableBbox.height` are not zero which can happen if the element does not have any content. By making\n        // the width/height 1, we prevent HTML errors of the type `scale(Infinity, Infinity)`.\n        var sx = (size.width / (scalableBBox.width || 1));\n        var sy = (size.height / (scalableBBox.height || 1));\n        scalable.attr('transform', 'scale(' + sx + ',' + sy + ')');\n\n        // Now the interesting part. The goal is to be able to store the object geometry via just `x`, `y`, `angle`, `width` and `height`\n        // Order of transformations is significant but we want to reconstruct the object always in the order:\n        // resize(), rotate(), translate() no matter of how the object was transformed. For that to work,\n        // we must adjust the `x` and `y` coordinates of the object whenever we resize it (because the origin of the\n        // rotation changes). The new `x` and `y` coordinates are computed by canceling the previous rotation\n        // around the center of the resized object (which is a different origin then the origin of the previous rotation)\n        // and getting the top-left corner of the resulting object. Then we clean up the rotation back to what it originally was.\n\n        // Cancel the rotation but now around a different origin, which is the center of the scaled object.\n        var rotatable = this.rotatableNode;\n        var rotation = rotatable && rotatable.attr('transform');\n        if (rotation) {\n\n            rotatable.attr('transform', rotation + ' rotate(' + (-angle) + ',' + (size.width / 2) + ',' + (size.height / 2) + ')');\n            var rotatableBBox = scalable.getBBox({ target: this.paper.cells });\n\n            // Store new x, y and perform rotate() again against the new rotation origin.\n            model.set('position', { x: rotatableBBox.x, y: rotatableBBox.y }, assign({ updateHandled: true }, opt));\n            this.translate();\n            this.rotate();\n        }\n\n        // Update must always be called on non-rotated element. Otherwise, relative positioning\n        // would work with wrong (rotated) bounding boxes.\n        this.update();\n    },\n\n    // Embedding mode methods.\n    // -----------------------\n\n    prepareEmbedding: function(data = {}) {\n\n        const element = data.model || this.model;\n        const paper = data.paper || this.paper;\n        const graph = paper.model;\n\n        const initialZIndices = data.initialZIndices = {};\n        const embeddedCells = element.getEmbeddedCells({ deep: true });\n        const connectedLinks = graph.getConnectedLinks(element, { deep: true, includeEnclosed: true });\n\n        // Note: an embedded cell can be a connect link, but it's fine\n        // to iterate over the cell twice.\n        [\n            element,\n            ...embeddedCells,\n            ...connectedLinks\n        ].forEach(cell => initialZIndices[cell.id] = cell.attributes.z);\n\n        element.startBatch('to-front');\n\n        // Bring the model to the front with all his embeds.\n        element.toFront({ deep: true, ui: true });\n\n        // Note that at this point cells in the collection are not sorted by z index (it's running in the batch, see\n        // the dia.Graph._sortOnChangeZ), so we can't assume that the last cell in the collection has the highest z.\n        const maxZ = graph.getElements().reduce((max, cell) => Math.max(max, cell.attributes.z || 0), 0);\n\n        // Move to front also all the inbound and outbound links that are connected\n        // to any of the element descendant. If we bring to front only embedded elements,\n        // links connected to them would stay in the background.\n        connectedLinks.forEach((link) => {\n            if (link.attributes.z <= maxZ) {\n                link.set('z', maxZ + 1, { ui: true });\n            }\n        });\n\n        element.stopBatch('to-front');\n\n        // Before we start looking for suitable parent we remove the current one.\n        const parentId = element.parent();\n        if (parentId) {\n            const parent = graph.getCell(parentId);\n            parent.unembed(element, { ui: true });\n            data.initialParentId = parentId;\n        } else {\n            data.initialParentId = null;\n        }\n    },\n\n    processEmbedding: function(data = {}, evt, x, y) {\n\n        const model = data.model || this.model;\n        const paper = data.paper || this.paper;\n        const graph = paper.model;\n        const { findParentBy, frontParentOnly, validateEmbedding } = paper.options;\n\n        let candidates;\n        if (isFunction(findParentBy)) {\n            candidates = toArray(findParentBy.call(graph, this, evt, x, y));\n        } else if (findParentBy === 'pointer') {\n            candidates = toArray(graph.findModelsFromPoint({ x, y }));\n        } else {\n            candidates = graph.findModelsUnderElement(model, { searchBy: findParentBy });\n        }\n\n        candidates = candidates.filter((el) => {\n            return (el instanceof Cell) && (model.id !== el.id) && !el.isEmbeddedIn(model);\n        });\n\n        if (frontParentOnly) {\n            // pick the element with the highest `z` index\n            candidates = candidates.slice(-1);\n        }\n\n        let newCandidateView = null;\n        const prevCandidateView = data.candidateEmbedView;\n\n        // iterate over all candidates starting from the last one (has the highest z-index).\n        for (let i = candidates.length - 1; i >= 0; i--) {\n            const candidate = candidates[i];\n            if (prevCandidateView && prevCandidateView.model.id == candidate.id) {\n                // candidate remains the same\n                newCandidateView = prevCandidateView;\n                break;\n            } else {\n                const view = candidate.findView(paper);\n                if (!isFunction(validateEmbedding) || validateEmbedding.call(paper, this, view)) {\n                    // flip to the new candidate\n                    newCandidateView = view;\n                    break;\n                }\n            }\n        }\n\n        if (newCandidateView && newCandidateView != prevCandidateView) {\n            // A new candidate view found. Highlight the new one.\n            this.clearEmbedding(data);\n            data.candidateEmbedView = newCandidateView.highlight(\n                newCandidateView.findProxyNode(null, 'container'),\n                { embedding: true }\n            );\n        }\n\n        if (!newCandidateView && prevCandidateView) {\n            // No candidate view found. Unhighlight the previous candidate.\n            this.clearEmbedding(data);\n        }\n    },\n\n    clearEmbedding: function(data) {\n\n        data || (data = {});\n\n        var candidateView = data.candidateEmbedView;\n        if (candidateView) {\n            // No candidate view found. Unhighlight the previous candidate.\n            candidateView.unhighlight(\n                candidateView.findProxyNode(null, 'container'),\n                { embedding: true }\n            );\n            data.candidateEmbedView = null;\n        }\n    },\n\n    finalizeEmbedding: function(data = {}) {\n\n        const candidateView = data.candidateEmbedView;\n        const element = data.model || this.model;\n        const paper = data.paper || this.paper;\n\n        if (candidateView) {\n\n            // We finished embedding. Candidate view is chosen to become the parent of the model.\n            candidateView.model.embed(element, { ui: true });\n            candidateView.unhighlight(candidateView.findProxyNode(null, 'container'), { embedding: true });\n\n            data.candidateEmbedView = null;\n\n        } else {\n\n            const { validateUnembedding } = paper.options;\n            const { initialParentId } = data;\n            // The element was originally embedded into another element.\n            // The interaction would unembed the element. Let's validate\n            // if the element can be unembedded.\n            if (\n                initialParentId &&\n                typeof validateUnembedding === 'function' &&\n                !validateUnembedding.call(paper, this)\n            ) {\n                this._disallowUnembed(data);\n                return;\n            }\n        }\n\n        paper.model.getConnectedLinks(element, { deep: true }).forEach(link => {\n            link.reparent({ ui: true });\n        });\n    },\n\n    _disallowUnembed: function(data) {\n        const { model, whenNotAllowed = 'revert' } = data;\n        const element = model || this.model;\n        const paper = data.paper || this.paper;\n        const graph = paper.model;\n        switch (whenNotAllowed) {\n            case 'remove': {\n                element.remove({ ui: true });\n                break;\n            }\n            case 'revert': {\n                const { initialParentId, initialPosition, initialZIndices } = data;\n                // Revert the element's position (and the position of its embedded cells if any)\n                if (initialPosition) {\n                    const { x, y } = initialPosition;\n                    element.position(x, y, { deep: true, ui: true });\n                }\n                // Revert all the z-indices changed during the embedding\n                if (initialZIndices) {\n                    Object.keys(initialZIndices).forEach(id => {\n                        const cell = graph.getCell(id);\n                        if (cell) {\n                            cell.set('z', initialZIndices[id], { ui: true });\n                        }\n                    });\n                }\n                // Revert the original parent\n                const parent = graph.getCell(initialParentId);\n                if (parent) {\n                    parent.embed(element, { ui: true });\n                }\n                break;\n            }\n        }\n    },\n\n    getDelegatedView: function() {\n\n        var view = this;\n        var model = view.model;\n        var paper = view.paper;\n\n        while (view) {\n            if (model.isLink()) break;\n            if (!model.isEmbedded() || view.can('stopDelegation')) return view;\n            model = model.getParentCell();\n            view = paper.findViewByModel(model);\n        }\n\n        return null;\n    },\n\n    findProxyNode: function(el, type) {\n        el || (el = this.el);\n        const nodeSelector = el.getAttribute(`${type}-selector`);\n        if (nodeSelector) {\n            const port = this.findAttribute('port', el);\n            if (port) {\n                const proxyPortNode = this.findPortNode(port, nodeSelector);\n                if (proxyPortNode) return proxyPortNode;\n            } else {\n                const [proxyNode] = this.findBySelector(nodeSelector);\n                if (proxyNode) return proxyNode;\n            }\n        }\n        return el;\n    },\n\n    // Interaction. The controller part.\n    // ---------------------------------\n\n    notifyPointerdown(evt, x, y) {\n        CellView.prototype.pointerdown.call(this, evt, x, y);\n        this.notify('element:pointerdown', evt, x, y);\n    },\n\n    notifyPointermove(evt, x, y) {\n        CellView.prototype.pointermove.call(this, evt, x, y);\n        this.notify('element:pointermove', evt, x, y);\n    },\n\n    notifyPointerup(evt, x, y) {\n        this.notify('element:pointerup', evt, x, y);\n        CellView.prototype.pointerup.call(this, evt, x, y);\n    },\n\n    pointerdblclick: function(evt, x, y) {\n\n        CellView.prototype.pointerdblclick.apply(this, arguments);\n        this.notify('element:pointerdblclick', evt, x, y);\n    },\n\n    pointerclick: function(evt, x, y) {\n\n        CellView.prototype.pointerclick.apply(this, arguments);\n        this.notify('element:pointerclick', evt, x, y);\n    },\n\n    contextmenu: function(evt, x, y) {\n\n        CellView.prototype.contextmenu.apply(this, arguments);\n        this.notify('element:contextmenu', evt, x, y);\n    },\n\n    pointerdown: function(evt, x, y) {\n\n        if (this.isPropagationStopped(evt)) return;\n\n        this.notifyPointerdown(evt, x, y);\n        this.dragStart(evt, x, y);\n    },\n\n    pointermove: function(evt, x, y) {\n\n        var data = this.eventData(evt);\n\n        switch (data.action) {\n            case 'magnet':\n                this.dragMagnet(evt, x, y);\n                break;\n            case 'move':\n                (data.delegatedView || this).drag(evt, x, y);\n            // eslint: no-fallthrough=false\n            default:\n                this.notifyPointermove(evt, x, y);\n                break;\n        }\n\n        // Make sure the element view data is passed along.\n        // It could have been wiped out in the handlers above.\n        this.eventData(evt, data);\n    },\n\n    pointerup: function(evt, x, y) {\n\n        var data = this.eventData(evt);\n        switch (data.action) {\n            case 'magnet':\n                this.dragMagnetEnd(evt, x, y);\n                break;\n            case 'move':\n                (data.delegatedView || this).dragEnd(evt, x, y);\n            // eslint: no-fallthrough=false\n            default:\n                this.notifyPointerup(evt, x, y);\n        }\n\n        var magnet = data.targetMagnet;\n        if (magnet) this.magnetpointerclick(evt, magnet, x, y);\n\n        this.checkMouseleave(evt);\n    },\n\n    mouseover: function(evt) {\n\n        CellView.prototype.mouseover.apply(this, arguments);\n        this.notify('element:mouseover', evt);\n    },\n\n    mouseout: function(evt) {\n\n        CellView.prototype.mouseout.apply(this, arguments);\n        this.notify('element:mouseout', evt);\n    },\n\n    mouseenter: function(evt) {\n\n        CellView.prototype.mouseenter.apply(this, arguments);\n        this.notify('element:mouseenter', evt);\n    },\n\n    mouseleave: function(evt) {\n\n        CellView.prototype.mouseleave.apply(this, arguments);\n        this.notify('element:mouseleave', evt);\n    },\n\n    mousewheel: function(evt, x, y, delta) {\n\n        CellView.prototype.mousewheel.apply(this, arguments);\n        this.notify('element:mousewheel', evt, x, y, delta);\n    },\n\n    onmagnet: function(evt, x, y) {\n\n        this.dragMagnetStart(evt, x, y);\n    },\n\n    magnetpointerdblclick: function(evt, magnet, x, y) {\n\n        this.notify('element:magnet:pointerdblclick', evt, magnet, x, y);\n    },\n\n    magnetcontextmenu: function(evt, magnet, x, y) {\n\n        this.notify('element:magnet:contextmenu', evt, magnet, x, y);\n    },\n\n    // Drag Start Handlers\n\n    dragStart: function(evt, x, y) {\n\n        var view = this.getDelegatedView();\n        if (!view || !view.can('elementMove')) return;\n\n        this.eventData(evt, {\n            action: 'move',\n            delegatedView: view\n        });\n\n        const position = view.model.position();\n        view.eventData(evt, {\n            initialPosition: position,\n            pointerOffset: position.difference(x, y),\n            restrictedArea: this.paper.getRestrictedArea(view, x, y)\n        });\n    },\n\n    dragMagnetStart: function(evt, x, y) {\n\n        if (!this.can('addLinkFromMagnet')) return;\n\n        var magnet = evt.currentTarget;\n        var paper = this.paper;\n        this.eventData(evt, { targetMagnet: magnet });\n        evt.stopPropagation();\n\n        if (paper.options.validateMagnet(this, magnet, evt)) {\n\n            if (paper.options.magnetThreshold <= 0) {\n                this.dragLinkStart(evt, magnet, x, y);\n            }\n\n            this.eventData(evt, { action: 'magnet' });\n            this.stopPropagation(evt);\n\n        } else {\n\n            this.pointerdown(evt, x, y);\n        }\n\n        paper.delegateDragEvents(this, evt.data);\n    },\n\n    // Drag Handlers\n\n    drag: function(evt, x, y) {\n\n        var paper = this.paper;\n        var grid = paper.options.gridSize;\n        var element = this.model;\n        var data = this.eventData(evt);\n        var { pointerOffset, restrictedArea, embedding } = data;\n\n        // Make sure the new element's position always snaps to the current grid\n        var elX = snapToGrid(x + pointerOffset.x, grid);\n        var elY = snapToGrid(y + pointerOffset.y, grid);\n\n        element.position(elX, elY, { restrictedArea, deep: true, ui: true });\n\n        if (paper.options.embeddingMode) {\n            if (!embedding) {\n                // Prepare the element for embedding only if the pointer moves.\n                // We don't want to do unnecessary action with the element\n                // if an user only clicks/dblclicks on it.\n                this.prepareEmbedding(data);\n                embedding = true;\n            }\n            this.processEmbedding(data, evt, x, y);\n        }\n\n        this.eventData(evt, {\n            embedding\n        });\n    },\n\n    dragMagnet: function(evt, x, y) {\n        this.dragLink(evt, x, y);\n    },\n\n    // Drag End Handlers\n\n    dragEnd: function(evt, x, y) {\n\n        var data = this.eventData(evt);\n        if (data.embedding) this.finalizeEmbedding(data);\n    },\n\n    dragMagnetEnd: function(evt, x, y) {\n        this.dragLinkEnd(evt, x, y);\n    },\n\n    magnetpointerclick: function(evt, magnet, x, y) {\n        var paper = this.paper;\n        if (paper.eventData(evt).mousemoved > paper.options.clickThreshold) return;\n        this.notify('element:magnet:pointerclick', evt, magnet, x, y);\n    }\n\n}, {\n\n    Flags: Flags,\n});\n\nassign(ElementView.prototype, elementViewPortPrototype);\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}