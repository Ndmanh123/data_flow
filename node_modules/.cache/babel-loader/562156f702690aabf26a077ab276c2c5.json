{"ast":null,"code":"import { Path, Point, Curve } from '../g/index.mjs';\nconst Directions = {\n  AUTO: 'auto',\n  HORIZONTAL: 'horizontal',\n  VERTICAL: 'vertical',\n  CLOSEST_POINT: 'closest-point',\n  OUTWARDS: 'outwards'\n};\nconst TangentDirections = {\n  UP: 'up',\n  DOWN: 'down',\n  LEFT: 'left',\n  RIGHT: 'right',\n  AUTO: 'auto',\n  CLOSEST_POINT: 'closest-point',\n  OUTWARDS: 'outwards'\n};\nexport const curve = function (sourcePoint, targetPoint, route = [], opt = {}, linkView) {\n  const raw = Boolean(opt.raw); // distanceCoefficient - a coefficient of the tangent vector length relative to the distance between points.\n  // angleTangentCoefficient - a coefficient of the end tangents length in the case of angles larger than 45 degrees.\n  // tension - a Catmull-Rom curve tension parameter.\n  // sourceTangent - a tangent vector along the curve at the sourcePoint.\n  // sourceDirection - a unit direction vector along the curve at the sourcePoint.\n  // targetTangent - a tangent vector along the curve at the targetPoint.\n  // targetDirection - a unit direction vector along the curve at the targetPoint.\n  // precision - a rounding precision for path values.\n\n  const {\n    direction = Directions.AUTO,\n    precision = 3\n  } = opt;\n  const options = {\n    coeff: opt.distanceCoefficient || 0.6,\n    angleTangentCoefficient: opt.angleTangentCoefficient || 80,\n    tau: opt.tension || 0.5,\n    sourceTangent: opt.sourceTangent ? new Point(opt.sourceTangent) : null,\n    targetTangent: opt.targetTangent ? new Point(opt.targetTangent) : null\n  };\n  if (typeof opt.sourceDirection === 'string') options.sourceDirection = opt.sourceDirection;else if (typeof opt.sourceDirection === 'number') options.sourceDirection = new Point(1, 0).rotate(null, opt.sourceDirection);else options.sourceDirection = opt.sourceDirection ? new Point(opt.sourceDirection).normalize() : null;\n  if (typeof opt.targetDirection === 'string') options.targetDirection = opt.targetDirection;else if (typeof opt.targetDirection === 'number') options.targetDirection = new Point(1, 0).rotate(null, opt.targetDirection);else options.targetDirection = opt.targetDirection ? new Point(opt.targetDirection).normalize() : null;\n  const completeRoute = [sourcePoint, ...route.map(p => new Point(p)), targetPoint]; // The calculation of a sourceTangent\n\n  let sourceTangent;\n\n  if (options.sourceTangent) {\n    sourceTangent = options.sourceTangent;\n  } else {\n    const sourceDirection = getSourceTangentDirection(linkView, completeRoute, direction, options);\n    const tangentLength = completeRoute[0].distance(completeRoute[1]) * options.coeff;\n    const pointsVector = completeRoute[1].difference(completeRoute[0]).normalize();\n    const angle = angleBetweenVectors(sourceDirection, pointsVector);\n\n    if (angle > Math.PI / 4) {\n      const updatedLength = tangentLength + (angle - Math.PI / 4) * options.angleTangentCoefficient;\n      sourceTangent = sourceDirection.clone().scale(updatedLength, updatedLength);\n    } else {\n      sourceTangent = sourceDirection.clone().scale(tangentLength, tangentLength);\n    }\n  } // The calculation of a targetTangent\n\n\n  let targetTangent;\n\n  if (options.targetTangent) {\n    targetTangent = options.targetTangent;\n  } else {\n    const targetDirection = getTargetTangentDirection(linkView, completeRoute, direction, options);\n    const last = completeRoute.length - 1;\n    const tangentLength = completeRoute[last - 1].distance(completeRoute[last]) * options.coeff;\n    const pointsVector = completeRoute[last - 1].difference(completeRoute[last]).normalize();\n    const angle = angleBetweenVectors(targetDirection, pointsVector);\n\n    if (angle > Math.PI / 4) {\n      const updatedLength = tangentLength + (angle - Math.PI / 4) * options.angleTangentCoefficient;\n      targetTangent = targetDirection.clone().scale(updatedLength, updatedLength);\n    } else {\n      targetTangent = targetDirection.clone().scale(tangentLength, tangentLength);\n    }\n  }\n\n  const catmullRomCurves = createCatmullRomCurves(completeRoute, sourceTangent, targetTangent, options);\n  const bezierCurves = catmullRomCurves.map(curve => catmullRomToBezier(curve, options));\n  const path = new Path(bezierCurves).round(precision);\n  return raw ? path : path.serialize();\n};\ncurve.Directions = Directions;\ncurve.TangentDirections = TangentDirections;\n\nfunction getHorizontalSourceDirection(linkView, route, options) {\n  const {\n    sourceBBox\n  } = linkView;\n  let sourceSide;\n\n  if (!sourceBBox.width || !sourceBBox.height) {\n    if (sourceBBox.x > route[1].x) sourceSide = 'right';else sourceSide = 'left';\n  } else {\n    sourceSide = sourceBBox.sideNearestToPoint(route[0]);\n  }\n\n  switch (sourceSide) {\n    case 'left':\n      return new Point(-1, 0);\n\n    case 'right':\n    default:\n      return new Point(1, 0);\n  }\n}\n\nfunction getHorizontalTargetDirection(linkView, route, options) {\n  const {\n    targetBBox\n  } = linkView;\n  let targetSide;\n\n  if (!targetBBox.width || !targetBBox.height) {\n    if (targetBBox.x > route[route.length - 2].x) targetSide = 'left';else targetSide = 'right';\n  } else {\n    targetSide = targetBBox.sideNearestToPoint(route[route.length - 1]);\n  }\n\n  switch (targetSide) {\n    case 'left':\n      return new Point(-1, 0);\n\n    case 'right':\n    default:\n      return new Point(1, 0);\n  }\n}\n\nfunction getVerticalSourceDirection(linkView, route, options) {\n  const {\n    sourceBBox\n  } = linkView;\n  let sourceSide;\n\n  if (!sourceBBox.width || !sourceBBox.height) {\n    if (sourceBBox.y > route[1].y) sourceSide = 'bottom';else sourceSide = 'top';\n  } else {\n    sourceSide = sourceBBox.sideNearestToPoint(route[0]);\n  }\n\n  switch (sourceSide) {\n    case 'top':\n      return new Point(0, -1);\n\n    case 'bottom':\n    default:\n      return new Point(0, 1);\n  }\n}\n\nfunction getVerticalTargetDirection(linkView, route, options) {\n  const {\n    targetBBox\n  } = linkView;\n  let targetSide;\n\n  if (!targetBBox.width || !targetBBox.height) {\n    if (targetBBox.y > route[route.length - 2].y) targetSide = 'top';else targetSide = 'bottom';\n  } else {\n    targetSide = targetBBox.sideNearestToPoint(route[route.length - 1]);\n  }\n\n  switch (targetSide) {\n    case 'top':\n      return new Point(0, -1);\n\n    case 'bottom':\n    default:\n      return new Point(0, 1);\n  }\n}\n\nfunction getAutoSourceDirection(linkView, route, options) {\n  const {\n    sourceBBox\n  } = linkView;\n  let sourceSide;\n\n  if (!sourceBBox.width || !sourceBBox.height) {\n    sourceSide = sourceBBox.sideNearestToPoint(route[1]);\n  } else {\n    sourceSide = sourceBBox.sideNearestToPoint(route[0]);\n  }\n\n  switch (sourceSide) {\n    case 'top':\n      return new Point(0, -1);\n\n    case 'bottom':\n      return new Point(0, 1);\n\n    case 'right':\n      return new Point(1, 0);\n\n    case 'left':\n      return new Point(-1, 0);\n  }\n}\n\nfunction getAutoTargetDirection(linkView, route, options) {\n  const {\n    targetBBox\n  } = linkView;\n  let targetSide;\n\n  if (!targetBBox.width || !targetBBox.height) {\n    targetSide = targetBBox.sideNearestToPoint(route[route.length - 2]);\n  } else {\n    targetSide = targetBBox.sideNearestToPoint(route[route.length - 1]);\n  }\n\n  switch (targetSide) {\n    case 'top':\n      return new Point(0, -1);\n\n    case 'bottom':\n      return new Point(0, 1);\n\n    case 'right':\n      return new Point(1, 0);\n\n    case 'left':\n      return new Point(-1, 0);\n  }\n}\n\nfunction getClosestPointSourceDirection(linkView, route, options) {\n  return route[1].difference(route[0]).normalize();\n}\n\nfunction getClosestPointTargetDirection(linkView, route, options) {\n  const last = route.length - 1;\n  return route[last - 1].difference(route[last]).normalize();\n}\n\nfunction getOutwardsSourceDirection(linkView, route, options) {\n  const {\n    sourceBBox\n  } = linkView;\n  const sourceCenter = sourceBBox.center();\n  return route[0].difference(sourceCenter).normalize();\n}\n\nfunction getOutwardsTargetDirection(linkView, route, options) {\n  const {\n    targetBBox\n  } = linkView;\n  const targetCenter = targetBBox.center();\n  return route[route.length - 1].difference(targetCenter).normalize();\n}\n\nfunction getSourceTangentDirection(linkView, route, direction, options) {\n  if (options.sourceDirection) {\n    switch (options.sourceDirection) {\n      case TangentDirections.UP:\n        return new Point(0, -1);\n\n      case TangentDirections.DOWN:\n        return new Point(0, 1);\n\n      case TangentDirections.LEFT:\n        return new Point(-1, 0);\n\n      case TangentDirections.RIGHT:\n        return new Point(1, 0);\n\n      case TangentDirections.AUTO:\n        return getAutoSourceDirection(linkView, route, options);\n\n      case TangentDirections.CLOSEST_POINT:\n        return getClosestPointSourceDirection(linkView, route, options);\n\n      case TangentDirections.OUTWARDS:\n        return getOutwardsSourceDirection(linkView, route, options);\n\n      default:\n        return options.sourceDirection;\n    }\n  }\n\n  switch (direction) {\n    case Directions.HORIZONTAL:\n      return getHorizontalSourceDirection(linkView, route, options);\n\n    case Directions.VERTICAL:\n      return getVerticalSourceDirection(linkView, route, options);\n\n    case Directions.CLOSEST_POINT:\n      return getClosestPointSourceDirection(linkView, route, options);\n\n    case Directions.OUTWARDS:\n      return getOutwardsSourceDirection(linkView, route, options);\n\n    case Directions.AUTO:\n    default:\n      return getAutoSourceDirection(linkView, route, options);\n  }\n}\n\nfunction getTargetTangentDirection(linkView, route, direction, options) {\n  if (options.targetDirection) {\n    switch (options.targetDirection) {\n      case TangentDirections.UP:\n        return new Point(0, -1);\n\n      case TangentDirections.DOWN:\n        return new Point(0, 1);\n\n      case TangentDirections.LEFT:\n        return new Point(-1, 0);\n\n      case TangentDirections.RIGHT:\n        return new Point(0, 1);\n\n      case TangentDirections.AUTO:\n        return getAutoTargetDirection(linkView, route, options);\n\n      case TangentDirections.CLOSEST_POINT:\n        return getClosestPointTargetDirection(linkView, route, options);\n\n      case TangentDirections.OUTWARDS:\n        return getOutwardsTargetDirection(linkView, route, options);\n\n      default:\n        return options.targetDirection;\n    }\n  }\n\n  switch (direction) {\n    case Directions.HORIZONTAL:\n      return getHorizontalTargetDirection(linkView, route, options);\n\n    case Directions.VERTICAL:\n      return getVerticalTargetDirection(linkView, route, options);\n\n    case Directions.CLOSEST_POINT:\n      return getClosestPointTargetDirection(linkView, route, options);\n\n    case Directions.OUTWARDS:\n      return getOutwardsTargetDirection(linkView, route, options);\n\n    case Directions.AUTO:\n    default:\n      return getAutoTargetDirection(linkView, route, options);\n  }\n}\n\nfunction rotateVector(vector, angle) {\n  const cos = Math.cos(angle);\n  const sin = Math.sin(angle);\n  const x = cos * vector.x - sin * vector.y;\n  const y = sin * vector.x + cos * vector.y;\n  vector.x = x;\n  vector.y = y;\n}\n\nfunction angleBetweenVectors(v1, v2) {\n  let cos = v1.dot(v2) / (v1.magnitude() * v2.magnitude());\n  if (cos < -1) cos = -1;\n  if (cos > 1) cos = 1;\n  return Math.acos(cos);\n}\n\nfunction determinant(v1, v2) {\n  return v1.x * v2.y - v1.y * v2.x;\n}\n\nfunction createCatmullRomCurves(points, sourceTangent, targetTangent, options) {\n  const {\n    tau,\n    coeff\n  } = options;\n  const distances = [];\n  const tangents = [];\n  const catmullRomCurves = [];\n  const n = points.length - 1;\n\n  for (let i = 0; i < n; i++) {\n    distances[i] = points[i].distance(points[i + 1]);\n  }\n\n  tangents[0] = sourceTangent;\n  tangents[n] = targetTangent; // The calculation of tangents of vertices\n\n  for (let i = 1; i < n; i++) {\n    let tpPrev;\n    let tpNext;\n\n    if (i === 1) {\n      tpPrev = points[i - 1].clone().offset(tangents[i - 1].x, tangents[i - 1].y);\n    } else {\n      tpPrev = points[i - 1].clone();\n    }\n\n    if (i === n - 1) {\n      tpNext = points[i + 1].clone().offset(tangents[i + 1].x, tangents[i + 1].y);\n    } else {\n      tpNext = points[i + 1].clone();\n    }\n\n    const v1 = tpPrev.difference(points[i]).normalize();\n    const v2 = tpNext.difference(points[i]).normalize();\n    const vAngle = angleBetweenVectors(v1, v2);\n    let rot = (Math.PI - vAngle) / 2;\n    let t;\n    const vectorDeterminant = determinant(v1, v2);\n    let pointsDeterminant;\n    pointsDeterminant = determinant(points[i].difference(points[i + 1]), points[i].difference(points[i - 1]));\n\n    if (vectorDeterminant < 0) {\n      rot = -rot;\n    }\n\n    if (vAngle < Math.PI / 2 && (rot < 0 && pointsDeterminant < 0 || rot > 0 && pointsDeterminant > 0)) {\n      rot = rot - Math.PI;\n    }\n\n    t = v2.clone();\n    rotateVector(t, rot);\n    const t1 = t.clone();\n    const t2 = t.clone();\n    const scaleFactor1 = distances[i - 1] * coeff;\n    const scaleFactor2 = distances[i] * coeff;\n    t1.scale(scaleFactor1, scaleFactor1);\n    t2.scale(scaleFactor2, scaleFactor2);\n    tangents[i] = [t1, t2];\n  } // The building of a Catmull-Rom curve based of tangents of points\n\n\n  for (let i = 0; i < n; i++) {\n    let p0;\n    let p3;\n\n    if (i === 0) {\n      p0 = points[i + 1].difference(tangents[i].x / tau, tangents[i].y / tau);\n    } else {\n      p0 = points[i + 1].difference(tangents[i][1].x / tau, tangents[i][1].y / tau);\n    }\n\n    if (i === n - 1) {\n      p3 = points[i].clone().offset(tangents[i + 1].x / tau, tangents[i + 1].y / tau);\n    } else {\n      p3 = points[i].difference(tangents[i + 1][0].x / tau, tangents[i + 1][0].y / tau);\n    }\n\n    catmullRomCurves[i] = [p0, points[i], points[i + 1], p3];\n  }\n\n  return catmullRomCurves;\n} // The function to convert Catmull-Rom curve to Bezier curve using the tension (tau)\n\n\nfunction catmullRomToBezier(points, options) {\n  const {\n    tau\n  } = options;\n  const bcp1 = new Point();\n  bcp1.x = points[1].x + (points[2].x - points[0].x) / (6 * tau);\n  bcp1.y = points[1].y + (points[2].y - points[0].y) / (6 * tau);\n  const bcp2 = new Point();\n  bcp2.x = points[2].x + (points[3].x - points[1].x) / (6 * tau);\n  bcp2.y = points[2].y + (points[3].y - points[1].y) / (6 * tau);\n  return new Curve(points[1], bcp1, bcp2, points[2]);\n}","map":{"version":3,"names":["Path","Point","Curve","Directions","AUTO","HORIZONTAL","VERTICAL","CLOSEST_POINT","OUTWARDS","TangentDirections","UP","DOWN","LEFT","RIGHT","curve","sourcePoint","targetPoint","route","opt","linkView","raw","Boolean","direction","precision","options","coeff","distanceCoefficient","angleTangentCoefficient","tau","tension","sourceTangent","targetTangent","sourceDirection","rotate","normalize","targetDirection","completeRoute","map","p","getSourceTangentDirection","tangentLength","distance","pointsVector","difference","angle","angleBetweenVectors","Math","PI","updatedLength","clone","scale","getTargetTangentDirection","last","length","catmullRomCurves","createCatmullRomCurves","bezierCurves","catmullRomToBezier","path","round","serialize","getHorizontalSourceDirection","sourceBBox","sourceSide","width","height","x","sideNearestToPoint","getHorizontalTargetDirection","targetBBox","targetSide","getVerticalSourceDirection","y","getVerticalTargetDirection","getAutoSourceDirection","getAutoTargetDirection","getClosestPointSourceDirection","getClosestPointTargetDirection","getOutwardsSourceDirection","sourceCenter","center","getOutwardsTargetDirection","targetCenter","rotateVector","vector","cos","sin","v1","v2","dot","magnitude","acos","determinant","points","distances","tangents","n","i","tpPrev","tpNext","offset","vAngle","rot","t","vectorDeterminant","pointsDeterminant","t1","t2","scaleFactor1","scaleFactor2","p0","p3","bcp1","bcp2"],"sources":["C:/Users/Admin/dataflow-test/node_modules/jointjs/src/connectors/curve.mjs"],"sourcesContent":["import { Path, Point, Curve } from '../g/index.mjs';\n\nconst Directions = {\n    AUTO: 'auto',\n    HORIZONTAL: 'horizontal',\n    VERTICAL: 'vertical',\n    CLOSEST_POINT: 'closest-point',\n    OUTWARDS: 'outwards'\n};\n\nconst TangentDirections = {\n    UP: 'up',\n    DOWN: 'down',\n    LEFT: 'left',\n    RIGHT: 'right',\n    AUTO: 'auto',\n    CLOSEST_POINT: 'closest-point',\n    OUTWARDS: 'outwards'\n};\n\nexport const curve = function(sourcePoint, targetPoint, route = [], opt = {}, linkView) {\n    const raw = Boolean(opt.raw);\n    // distanceCoefficient - a coefficient of the tangent vector length relative to the distance between points.\n    // angleTangentCoefficient - a coefficient of the end tangents length in the case of angles larger than 45 degrees.\n    // tension - a Catmull-Rom curve tension parameter.\n    // sourceTangent - a tangent vector along the curve at the sourcePoint.\n    // sourceDirection - a unit direction vector along the curve at the sourcePoint.\n    // targetTangent - a tangent vector along the curve at the targetPoint.\n    // targetDirection - a unit direction vector along the curve at the targetPoint.\n    // precision - a rounding precision for path values.\n    const { direction = Directions.AUTO, precision = 3 } = opt;\n    const options = {\n        coeff: opt.distanceCoefficient || 0.6,\n        angleTangentCoefficient: opt.angleTangentCoefficient || 80,\n        tau: opt.tension || 0.5,\n        sourceTangent: opt.sourceTangent ? new Point(opt.sourceTangent) : null,\n        targetTangent: opt.targetTangent ? new Point(opt.targetTangent) : null\n    };\n    if (typeof opt.sourceDirection === 'string')\n        options.sourceDirection = opt.sourceDirection;\n    else if (typeof opt.sourceDirection === 'number')\n        options.sourceDirection = new Point(1, 0).rotate(null, opt.sourceDirection);\n    else\n        options.sourceDirection = opt.sourceDirection ? new Point(opt.sourceDirection).normalize() : null;\n\n    if (typeof opt.targetDirection === 'string')\n        options.targetDirection = opt.targetDirection;\n    else if (typeof opt.targetDirection === 'number')\n        options.targetDirection = new Point(1, 0).rotate(null, opt.targetDirection);\n    else\n        options.targetDirection = opt.targetDirection ? new Point(opt.targetDirection).normalize() : null;\n\n    const completeRoute = [sourcePoint, ...route.map(p => new Point(p)), targetPoint];\n\n    // The calculation of a sourceTangent\n    let sourceTangent;\n    if (options.sourceTangent) {\n        sourceTangent = options.sourceTangent;\n    } else {\n        const sourceDirection = getSourceTangentDirection(linkView, completeRoute, direction, options);\n        const tangentLength = completeRoute[0].distance(completeRoute[1]) * options.coeff;\n        const pointsVector = completeRoute[1].difference(completeRoute[0]).normalize();\n        const angle = angleBetweenVectors(sourceDirection, pointsVector);\n        if (angle > Math.PI / 4) {\n            const updatedLength = tangentLength + (angle - Math.PI / 4) * options.angleTangentCoefficient;\n            sourceTangent = sourceDirection.clone().scale(updatedLength, updatedLength);\n        } else {\n            sourceTangent = sourceDirection.clone().scale(tangentLength, tangentLength);\n        }\n    }\n\n    // The calculation of a targetTangent\n    let targetTangent;\n    if (options.targetTangent) {\n        targetTangent = options.targetTangent;\n    } else {\n        const targetDirection = getTargetTangentDirection(linkView, completeRoute, direction, options);\n        const last = completeRoute.length - 1;\n        const tangentLength = completeRoute[last - 1].distance(completeRoute[last]) * options.coeff;\n        const pointsVector = completeRoute[last - 1].difference(completeRoute[last]).normalize();\n        const angle = angleBetweenVectors(targetDirection, pointsVector);\n        if (angle > Math.PI / 4) {\n            const updatedLength = tangentLength + (angle - Math.PI / 4) * options.angleTangentCoefficient;\n            targetTangent = targetDirection.clone().scale(updatedLength, updatedLength);\n        } else {\n            targetTangent = targetDirection.clone().scale(tangentLength, tangentLength);\n        }\n    }\n\n    const catmullRomCurves = createCatmullRomCurves(completeRoute, sourceTangent, targetTangent, options);\n    const bezierCurves = catmullRomCurves.map(curve => catmullRomToBezier(curve, options));\n    const path = new Path(bezierCurves).round(precision);\n\n    return (raw) ? path : path.serialize();\n};\ncurve.Directions = Directions;\ncurve.TangentDirections = TangentDirections;\n\nfunction getHorizontalSourceDirection(linkView, route, options) {\n    const { sourceBBox } = linkView;\n\n    let sourceSide;\n    if (!sourceBBox.width || !sourceBBox.height) {\n        if (sourceBBox.x > route[1].x)\n            sourceSide = 'right';\n        else\n            sourceSide = 'left';\n    } else {\n        sourceSide = sourceBBox.sideNearestToPoint(route[0]);\n    }\n\n    switch (sourceSide) {\n        case 'left':\n            return new Point(-1, 0);\n        case 'right':\n        default:\n            return new Point(1, 0);\n    }\n}\n\nfunction getHorizontalTargetDirection(linkView, route, options) {\n    const { targetBBox } = linkView;\n\n    let targetSide;\n    if (!targetBBox.width || !targetBBox.height) {\n        if (targetBBox.x > route[route.length - 2].x)\n            targetSide = 'left';\n        else\n            targetSide = 'right';\n    } else {\n        targetSide = targetBBox.sideNearestToPoint(route[route.length - 1]);\n    }\n\n    switch (targetSide) {\n        case 'left':\n            return new Point(-1, 0);\n        case 'right':\n        default:\n            return new Point(1, 0);\n    }\n}\n\nfunction getVerticalSourceDirection(linkView, route, options) {\n    const { sourceBBox } = linkView;\n\n    let sourceSide;\n    if (!sourceBBox.width || !sourceBBox.height) {\n        if (sourceBBox.y > route[1].y)\n            sourceSide = 'bottom';\n        else\n            sourceSide = 'top';\n    } else {\n        sourceSide = sourceBBox.sideNearestToPoint(route[0]);\n    }\n\n    switch (sourceSide) {\n        case 'top':\n            return new Point(0, -1);\n        case 'bottom':\n        default:\n            return new Point(0, 1);\n    }\n}\n\nfunction getVerticalTargetDirection(linkView, route, options) {\n    const { targetBBox } = linkView;\n\n    let targetSide;\n    if (!targetBBox.width || !targetBBox.height) {\n        if (targetBBox.y > route[route.length - 2].y)\n            targetSide = 'top';\n        else\n            targetSide = 'bottom';\n    } else {\n        targetSide = targetBBox.sideNearestToPoint(route[route.length - 1]);\n    }\n\n    switch (targetSide) {\n        case 'top':\n            return new Point(0, -1);\n        case 'bottom':\n        default:\n            return new Point(0, 1);\n    }\n}\n\nfunction getAutoSourceDirection(linkView, route, options) {\n    const { sourceBBox } = linkView;\n\n    let sourceSide;\n    if (!sourceBBox.width || !sourceBBox.height) {\n        sourceSide = sourceBBox.sideNearestToPoint(route[1]);\n    } else {\n        sourceSide = sourceBBox.sideNearestToPoint(route[0]);\n    }\n\n    switch (sourceSide) {\n        case 'top':\n            return new Point(0, -1);\n        case 'bottom':\n            return new Point(0, 1);\n        case 'right':\n            return new Point(1, 0);\n        case 'left':\n            return new Point(-1, 0);\n    }\n}\n\nfunction getAutoTargetDirection(linkView, route, options) {\n    const { targetBBox } = linkView;\n\n    let targetSide;\n    if (!targetBBox.width || !targetBBox.height) {\n        targetSide = targetBBox.sideNearestToPoint(route[route.length - 2]);\n    } else {\n        targetSide = targetBBox.sideNearestToPoint(route[route.length - 1]);\n    }\n\n    switch (targetSide) {\n        case 'top':\n            return new Point(0, -1);\n        case 'bottom':\n            return new Point(0, 1);\n        case 'right':\n            return new Point(1, 0);\n        case 'left':\n            return new Point(-1, 0);\n    }\n}\n\nfunction getClosestPointSourceDirection(linkView, route, options) {\n    return route[1].difference(route[0]).normalize();\n}\n\nfunction getClosestPointTargetDirection(linkView, route, options) {\n    const last = route.length - 1;\n    return route[last - 1].difference(route[last]).normalize();\n}\n\nfunction getOutwardsSourceDirection(linkView, route, options) {\n    const { sourceBBox } = linkView;\n    const sourceCenter = sourceBBox.center();\n    return route[0].difference(sourceCenter).normalize();\n}\n\nfunction getOutwardsTargetDirection(linkView, route, options) {\n    const { targetBBox } = linkView;\n    const targetCenter = targetBBox.center();\n    return route[route.length - 1].difference(targetCenter).normalize();\n}\n\nfunction getSourceTangentDirection(linkView, route, direction, options) {\n    if (options.sourceDirection) {\n        switch (options.sourceDirection) {\n            case TangentDirections.UP:\n                return new Point(0, -1);\n            case TangentDirections.DOWN:\n                return new Point(0, 1);\n            case TangentDirections.LEFT:\n                return new Point(-1, 0);\n            case TangentDirections.RIGHT:\n                return new Point(1, 0);\n            case TangentDirections.AUTO:\n                return getAutoSourceDirection(linkView, route, options);\n            case TangentDirections.CLOSEST_POINT:\n                return getClosestPointSourceDirection(linkView, route, options);\n            case TangentDirections.OUTWARDS:\n                return getOutwardsSourceDirection(linkView, route, options);\n            default:\n                return options.sourceDirection;\n        }\n    }\n\n    switch (direction) {\n        case Directions.HORIZONTAL:\n            return getHorizontalSourceDirection(linkView, route, options);\n        case Directions.VERTICAL:\n            return getVerticalSourceDirection(linkView, route, options);\n        case Directions.CLOSEST_POINT:\n            return getClosestPointSourceDirection(linkView, route, options);\n        case Directions.OUTWARDS:\n            return getOutwardsSourceDirection(linkView, route, options);\n        case Directions.AUTO:\n        default:\n            return getAutoSourceDirection(linkView, route, options);\n    }\n}\n\nfunction getTargetTangentDirection(linkView, route, direction, options) {\n    if (options.targetDirection) {\n        switch (options.targetDirection) {\n            case TangentDirections.UP:\n                return new Point(0, -1);\n            case TangentDirections.DOWN:\n                return new Point(0, 1);\n            case TangentDirections.LEFT:\n                return new Point(-1, 0);\n            case TangentDirections.RIGHT:\n                return new Point(0, 1);\n            case TangentDirections.AUTO:\n                return getAutoTargetDirection(linkView, route, options);\n            case TangentDirections.CLOSEST_POINT:\n                return getClosestPointTargetDirection(linkView, route, options);\n            case TangentDirections.OUTWARDS:\n                return getOutwardsTargetDirection(linkView, route, options);\n            default:\n                return options.targetDirection;\n        }\n    }\n\n    switch (direction) {\n        case Directions.HORIZONTAL:\n            return getHorizontalTargetDirection(linkView, route, options);\n        case Directions.VERTICAL:\n            return getVerticalTargetDirection(linkView, route, options);\n        case Directions.CLOSEST_POINT:\n            return getClosestPointTargetDirection(linkView, route, options);\n        case Directions.OUTWARDS:\n            return getOutwardsTargetDirection(linkView, route, options);\n        case Directions.AUTO:\n        default:\n            return getAutoTargetDirection(linkView, route, options);\n    }\n}\n\nfunction rotateVector(vector, angle) {\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n    const x = cos * vector.x - sin * vector.y;\n    const y = sin * vector.x + cos * vector.y;\n    vector.x = x;\n    vector.y = y;\n}\n\nfunction angleBetweenVectors(v1, v2) {\n    let cos = v1.dot(v2) / (v1.magnitude() * v2.magnitude());\n    if (cos < -1) cos = -1;\n    if (cos > 1) cos = 1;\n    return Math.acos(cos);\n}\n\nfunction determinant(v1, v2) {\n    return v1.x * v2.y - v1.y * v2.x;\n}\n\nfunction createCatmullRomCurves(points, sourceTangent, targetTangent, options) {\n    const { tau, coeff } = options;\n    const distances = [];\n    const tangents = [];\n    const catmullRomCurves = [];\n    const n = points.length - 1;\n\n    for (let i = 0; i < n; i++) {\n        distances[i] = points[i].distance(points[i + 1]);\n    }\n\n    tangents[0] = sourceTangent;\n    tangents[n] = targetTangent;\n\n    // The calculation of tangents of vertices\n    for (let i = 1; i < n; i++) {\n        let tpPrev;\n        let tpNext;\n        if (i === 1) {\n            tpPrev = points[i - 1].clone().offset(tangents[i - 1].x, tangents[i - 1].y);\n        } else {\n            tpPrev = points[i - 1].clone();\n        }\n        if (i === n - 1) {\n            tpNext = points[i + 1].clone().offset(tangents[i + 1].x, tangents[i + 1].y);\n        } else {\n            tpNext = points[i + 1].clone();\n        }\n        const v1 = tpPrev.difference(points[i]).normalize();\n        const v2 = tpNext.difference(points[i]).normalize();\n        const vAngle = angleBetweenVectors(v1, v2);\n\n        let rot = (Math.PI - vAngle) / 2;\n        let t;\n        const vectorDeterminant = determinant(v1, v2);\n        let pointsDeterminant;\n        pointsDeterminant = determinant(points[i].difference(points[i + 1]), points[i].difference(points[i - 1]));\n        if (vectorDeterminant < 0) {\n            rot = -rot;\n        }\n        if ((vAngle < Math.PI / 2) && ((rot < 0 && pointsDeterminant < 0) || (rot > 0 && pointsDeterminant > 0))) {\n            rot = rot - Math.PI;\n        }\n        t = v2.clone();\n        rotateVector(t, rot);\n\n        const t1 = t.clone();\n        const t2 = t.clone();\n        const scaleFactor1 = distances[i - 1] * coeff;\n        const scaleFactor2 = distances[i] * coeff;\n        t1.scale(scaleFactor1, scaleFactor1);\n        t2.scale(scaleFactor2, scaleFactor2);\n\n        tangents[i] = [t1, t2];\n    }\n\n    // The building of a Catmull-Rom curve based of tangents of points\n    for (let i = 0; i < n; i++) {\n        let p0;\n        let p3;\n        if (i === 0) {\n            p0 = points[i + 1].difference(tangents[i].x / tau, tangents[i].y / tau);\n        } else {\n            p0 = points[i + 1].difference(tangents[i][1].x / tau, tangents[i][1].y / tau);\n        }\n        if (i === n - 1) {\n            p3 = points[i].clone().offset(tangents[i + 1].x / tau, tangents[i + 1].y / tau);\n        } else {\n            p3 = points[i].difference(tangents[i + 1][0].x / tau, tangents[i + 1][0].y / tau);\n        }\n\n        catmullRomCurves[i] = [p0, points[i], points[i + 1], p3];\n    }\n    return catmullRomCurves;\n}\n\n// The function to convert Catmull-Rom curve to Bezier curve using the tension (tau)\nfunction catmullRomToBezier(points, options) {\n    const { tau } = options;\n\n    const bcp1 = new Point();\n    bcp1.x = points[1].x + (points[2].x - points[0].x) / (6 * tau);\n    bcp1.y = points[1].y + (points[2].y - points[0].y) / (6 * tau);\n\n    const bcp2 = new Point();\n    bcp2.x = points[2].x + (points[3].x - points[1].x) / (6 * tau);\n    bcp2.y = points[2].y + (points[3].y - points[1].y) / (6 * tau);\n    return new Curve(\n        points[1],\n        bcp1,\n        bcp2,\n        points[2]\n    );\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}