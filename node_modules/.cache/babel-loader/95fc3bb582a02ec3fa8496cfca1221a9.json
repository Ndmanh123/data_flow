{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport { Point } from './point.mjs';\nimport { Rect } from './rect.mjs';\nimport { Line } from './line.mjs';\nimport { Polyline } from './polyline.mjs';\nimport { types } from './types.mjs';\nconst {\n  abs,\n  sqrt,\n  min,\n  max,\n  pow\n} = Math;\nexport const Curve = function (p1, p2, p3, p4) {\n  if (!(this instanceof Curve)) {\n    return new Curve(p1, p2, p3, p4);\n  }\n\n  if (p1 instanceof Curve) {\n    return new Curve(p1.start, p1.controlPoint1, p1.controlPoint2, p1.end);\n  }\n\n  this.start = new Point(p1);\n  this.controlPoint1 = new Point(p2);\n  this.controlPoint2 = new Point(p3);\n  this.end = new Point(p4);\n}; // Curve passing through points.\n// Ported from C# implementation by Oleg V. Polikarpotchkin and Peter Lee (http://www.codeproject.com/KB/graphics/BezierSpline.aspx).\n// @param {array} points Array of points through which the smooth line will go.\n// @return {array} curves.\n\nCurve.throughPoints = function () {\n  // Get open-ended Bezier Spline Control Points.\n  // @param knots Input Knot Bezier spline points (At least two points!).\n  // @param firstControlPoints Output First Control points. Array of knots.length - 1 length.\n  // @param secondControlPoints Output Second Control points. Array of knots.length - 1 length.\n  function getCurveControlPoints(knots) {\n    var firstControlPoints = [];\n    var secondControlPoints = [];\n    var n = knots.length - 1;\n    var i; // Special case: Bezier curve should be a straight line.\n\n    if (n == 1) {\n      // 3P1 = 2P0 + P3\n      firstControlPoints[0] = new Point((2 * knots[0].x + knots[1].x) / 3, (2 * knots[0].y + knots[1].y) / 3); // P2 = 2P1 â€“ P0\n\n      secondControlPoints[0] = new Point(2 * firstControlPoints[0].x - knots[0].x, 2 * firstControlPoints[0].y - knots[0].y);\n      return [firstControlPoints, secondControlPoints];\n    } // Calculate first Bezier control points.\n    // Right hand side vector.\n\n\n    var rhs = []; // Set right hand side X values.\n\n    for (i = 1; i < n - 1; i++) {\n      rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;\n    }\n\n    rhs[0] = knots[0].x + 2 * knots[1].x;\n    rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0; // Get first control points X-values.\n\n    var x = getFirstControlPoints(rhs); // Set right hand side Y values.\n\n    for (i = 1; i < n - 1; ++i) {\n      rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;\n    }\n\n    rhs[0] = knots[0].y + 2 * knots[1].y;\n    rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0; // Get first control points Y-values.\n\n    var y = getFirstControlPoints(rhs); // Fill output arrays.\n\n    for (i = 0; i < n; i++) {\n      // First control point.\n      firstControlPoints.push(new Point(x[i], y[i])); // Second control point.\n\n      if (i < n - 1) {\n        secondControlPoints.push(new Point(2 * knots[i + 1].x - x[i + 1], 2 * knots[i + 1].y - y[i + 1]));\n      } else {\n        secondControlPoints.push(new Point((knots[n].x + x[n - 1]) / 2, (knots[n].y + y[n - 1]) / 2));\n      }\n    }\n\n    return [firstControlPoints, secondControlPoints];\n  } // Solves a tridiagonal system for one of coordinates (x or y) of first Bezier control points.\n  // @param rhs Right hand side vector.\n  // @return Solution vector.\n\n\n  function getFirstControlPoints(rhs) {\n    var n = rhs.length; // `x` is a solution vector.\n\n    var x = [];\n    var tmp = [];\n    var b = 2.0;\n    x[0] = rhs[0] / b; // Decomposition and forward substitution.\n\n    for (var i = 1; i < n; i++) {\n      tmp[i] = 1 / b;\n      b = (i < n - 1 ? 4.0 : 3.5) - tmp[i];\n      x[i] = (rhs[i] - x[i - 1]) / b;\n    }\n\n    for (i = 1; i < n; i++) {\n      // Backsubstitution.\n      x[n - i - 1] -= tmp[n - i] * x[n - i];\n    }\n\n    return x;\n  }\n\n  return function (points) {\n    if (!points || Array.isArray(points) && points.length < 2) {\n      throw new Error('At least 2 points are required');\n    }\n\n    var controlPoints = getCurveControlPoints(points);\n    var curves = [];\n    var n = controlPoints[0].length;\n\n    for (var i = 0; i < n; i++) {\n      var controlPoint1 = new Point(controlPoints[0][i].x, controlPoints[0][i].y);\n      var controlPoint2 = new Point(controlPoints[1][i].x, controlPoints[1][i].y);\n      curves.push(new Curve(points[i], controlPoint1, controlPoint2, points[i + 1]));\n    }\n\n    return curves;\n  };\n}();\n\nCurve.prototype = {\n  type: types.Curve,\n  // Returns a bbox that tightly envelops the curve.\n  bbox: function () {\n    var start = this.start;\n    var controlPoint1 = this.controlPoint1;\n    var controlPoint2 = this.controlPoint2;\n    var end = this.end;\n    var x0 = start.x;\n    var y0 = start.y;\n    var x1 = controlPoint1.x;\n    var y1 = controlPoint1.y;\n    var x2 = controlPoint2.x;\n    var y2 = controlPoint2.y;\n    var x3 = end.x;\n    var y3 = end.y;\n    var points = new Array(); // local extremes\n\n    var tvalues = new Array(); // t values of local extremes\n\n    var bounds = [new Array(), new Array()];\n    var a, b, c, t;\n    var t1, t2;\n    var b2ac, sqrtb2ac;\n\n    for (var i = 0; i < 2; ++i) {\n      if (i === 0) {\n        b = 6 * x0 - 12 * x1 + 6 * x2;\n        a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n        c = 3 * x1 - 3 * x0;\n      } else {\n        b = 6 * y0 - 12 * y1 + 6 * y2;\n        a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n        c = 3 * y1 - 3 * y0;\n      }\n\n      if (abs(a) < 1e-12) {\n        // Numerical robustness\n        if (abs(b) < 1e-12) {\n          // Numerical robustness\n          continue;\n        }\n\n        t = -c / b;\n        if (0 < t && t < 1) tvalues.push(t);\n        continue;\n      }\n\n      b2ac = b * b - 4 * c * a;\n      sqrtb2ac = sqrt(b2ac);\n      if (b2ac < 0) continue;\n      t1 = (-b + sqrtb2ac) / (2 * a);\n      if (0 < t1 && t1 < 1) tvalues.push(t1);\n      t2 = (-b - sqrtb2ac) / (2 * a);\n      if (0 < t2 && t2 < 1) tvalues.push(t2);\n    }\n\n    var j = tvalues.length;\n    var jlen = j;\n    var mt;\n    var x, y;\n\n    while (j--) {\n      t = tvalues[j];\n      mt = 1 - t;\n      x = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;\n      bounds[0][j] = x;\n      y = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;\n      bounds[1][j] = y;\n      points[j] = {\n        X: x,\n        Y: y\n      };\n    }\n\n    tvalues[jlen] = 0;\n    tvalues[jlen + 1] = 1;\n    points[jlen] = {\n      X: x0,\n      Y: y0\n    };\n    points[jlen + 1] = {\n      X: x3,\n      Y: y3\n    };\n    bounds[0][jlen] = x0;\n    bounds[1][jlen] = y0;\n    bounds[0][jlen + 1] = x3;\n    bounds[1][jlen + 1] = y3;\n    tvalues.length = jlen + 2;\n    bounds[0].length = jlen + 2;\n    bounds[1].length = jlen + 2;\n    points.length = jlen + 2;\n    var left = min.apply(null, bounds[0]);\n    var top = min.apply(null, bounds[1]);\n    var right = max.apply(null, bounds[0]);\n    var bottom = max.apply(null, bounds[1]);\n    return new Rect(left, top, right - left, bottom - top);\n  },\n  clone: function () {\n    return new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n  },\n  // Returns the point on the curve closest to point `p`\n  closestPoint: function (p, opt) {\n    return this.pointAtT(this.closestPointT(p, opt));\n  },\n  closestPointLength: function (p, opt) {\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({\n      precision: precision\n    }) : opt.subdivisions;\n    var localOpt = {\n      precision: precision,\n      subdivisions: subdivisions\n    };\n    return this.lengthAtT(this.closestPointT(p, localOpt), localOpt);\n  },\n  closestPointNormalizedLength: function (p, opt) {\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({\n      precision: precision\n    }) : opt.subdivisions;\n    var localOpt = {\n      precision: precision,\n      subdivisions: subdivisions\n    };\n    var cpLength = this.closestPointLength(p, localOpt);\n    if (!cpLength) return 0;\n    var length = this.length(localOpt);\n    if (length === 0) return 0;\n    return cpLength / length;\n  },\n  // Returns `t` of the point on the curve closest to point `p`\n  closestPointT: function (p, opt) {\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({\n      precision: precision\n    }) : opt.subdivisions; // does not use localOpt\n    // identify the subdivision that contains the point:\n\n    var investigatedSubdivision;\n    var investigatedSubdivisionStartT; // assume that subdivisions are evenly spaced\n\n    var investigatedSubdivisionEndT;\n    var distFromStart; // distance of point from start of baseline\n\n    var distFromEnd; // distance of point from end of baseline\n\n    var chordLength; // distance between start and end of the subdivision\n\n    var minSumDist; // lowest observed sum of the two distances\n\n    var n = subdivisions.length;\n    var subdivisionSize = n ? 1 / n : 0;\n\n    for (var i = 0; i < n; i++) {\n      var currentSubdivision = subdivisions[i];\n      var startDist = currentSubdivision.start.distance(p);\n      var endDist = currentSubdivision.end.distance(p);\n      var sumDist = startDist + endDist; // check that the point is closest to current subdivision and not any other\n\n      if (!minSumDist || sumDist < minSumDist) {\n        investigatedSubdivision = currentSubdivision;\n        investigatedSubdivisionStartT = i * subdivisionSize;\n        investigatedSubdivisionEndT = (i + 1) * subdivisionSize;\n        distFromStart = startDist;\n        distFromEnd = endDist;\n        chordLength = currentSubdivision.start.distance(currentSubdivision.end);\n        minSumDist = sumDist;\n      }\n    }\n\n    var precisionRatio = pow(10, -precision); // recursively divide investigated subdivision:\n    // until distance between baselinePoint and closest path endpoint is within 10^(-precision)\n    // then return the closest endpoint of that final subdivision\n\n    while (true) {\n      // check if we have reached at least one required observed precision\n      // - calculated as: the difference in distances from point to start and end divided by the distance\n      // - note that this function is not monotonic = it doesn't converge stably but has \"teeth\"\n      // - the function decreases while one of the endpoints is fixed but \"jumps\" whenever we switch\n      // - this criterion works well for points lying far away from the curve\n      var startPrecisionRatio = distFromStart ? abs(distFromStart - distFromEnd) / distFromStart : 0;\n      var endPrecisionRatio = distFromEnd ? abs(distFromStart - distFromEnd) / distFromEnd : 0;\n      var hasRequiredPrecision = startPrecisionRatio < precisionRatio || endPrecisionRatio < precisionRatio; // check if we have reached at least one required minimal distance\n      // - calculated as: the subdivision chord length multiplied by precisionRatio\n      // - calculation is relative so it will work for arbitrarily large/small curves and their subdivisions\n      // - this is a backup criterion that works well for points lying \"almost at\" the curve\n\n      var hasMinimalStartDistance = distFromStart ? distFromStart < chordLength * precisionRatio : true;\n      var hasMinimalEndDistance = distFromEnd ? distFromEnd < chordLength * precisionRatio : true;\n      var hasMinimalDistance = hasMinimalStartDistance || hasMinimalEndDistance; // do we stop now?\n\n      if (hasRequiredPrecision || hasMinimalDistance) {\n        return distFromStart <= distFromEnd ? investigatedSubdivisionStartT : investigatedSubdivisionEndT;\n      } // otherwise, set up for next iteration\n\n\n      var divided = investigatedSubdivision.divide(0.5);\n      subdivisionSize /= 2;\n      var startDist1 = divided[0].start.distance(p);\n      var endDist1 = divided[0].end.distance(p);\n      var sumDist1 = startDist1 + endDist1;\n      var startDist2 = divided[1].start.distance(p);\n      var endDist2 = divided[1].end.distance(p);\n      var sumDist2 = startDist2 + endDist2;\n\n      if (sumDist1 <= sumDist2) {\n        investigatedSubdivision = divided[0];\n        investigatedSubdivisionEndT -= subdivisionSize; // subdivisionSize was already halved\n\n        distFromStart = startDist1;\n        distFromEnd = endDist1;\n      } else {\n        investigatedSubdivision = divided[1];\n        investigatedSubdivisionStartT += subdivisionSize; // subdivisionSize was already halved\n\n        distFromStart = startDist2;\n        distFromEnd = endDist2;\n      }\n    }\n  },\n  closestPointTangent: function (p, opt) {\n    return this.tangentAtT(this.closestPointT(p, opt));\n  },\n  // Returns `true` if the area surrounded by the curve contains the point `p`.\n  // Implements the even-odd algorithm (self-intersections are \"outside\").\n  // Closes open curves (always imagines a closing segment).\n  // Precision may be adjusted by passing an `opt` object.\n  containsPoint: function (p, opt) {\n    var polyline = this.toPolyline(opt);\n    return polyline.containsPoint(p);\n  },\n  // Divides the curve into two at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.\n  // For a function that uses `t`, use Curve.divideAtT().\n  divideAt: function (ratio, opt) {\n    if (ratio <= 0) return this.divideAtT(0);\n    if (ratio >= 1) return this.divideAtT(1);\n    var t = this.tAt(ratio, opt);\n    return this.divideAtT(t);\n  },\n  // Divides the curve into two at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n  divideAtLength: function (length, opt) {\n    var t = this.tAtLength(length, opt);\n    return this.divideAtT(t);\n  },\n  // Divides the curve into two at point defined by `t` between 0 and 1.\n  // Using de Casteljau's algorithm (http://math.stackexchange.com/a/317867).\n  // Additional resource: https://pomax.github.io/bezierinfo/#decasteljau\n  divideAtT: function (t) {\n    var start = this.start;\n    var controlPoint1 = this.controlPoint1;\n    var controlPoint2 = this.controlPoint2;\n    var end = this.end; // shortcuts for `t` values that are out of range\n\n    if (t <= 0) {\n      return [new Curve(start, start, start, start), new Curve(start, controlPoint1, controlPoint2, end)];\n    }\n\n    if (t >= 1) {\n      return [new Curve(start, controlPoint1, controlPoint2, end), new Curve(end, end, end, end)];\n    }\n\n    var dividerPoints = this.getSkeletonPoints(t);\n    var startControl1 = dividerPoints.startControlPoint1;\n    var startControl2 = dividerPoints.startControlPoint2;\n    var divider = dividerPoints.divider;\n    var dividerControl1 = dividerPoints.dividerControlPoint1;\n    var dividerControl2 = dividerPoints.dividerControlPoint2; // return array with two new curves\n\n    return [new Curve(start, startControl1, startControl2, divider), new Curve(divider, dividerControl1, dividerControl2, end)];\n  },\n  // Returns the distance between the curve's start and end points.\n  endpointDistance: function () {\n    return this.start.distance(this.end);\n  },\n  // Checks whether two curves are exactly the same.\n  equals: function (c) {\n    return !!c && this.start.x === c.start.x && this.start.y === c.start.y && this.controlPoint1.x === c.controlPoint1.x && this.controlPoint1.y === c.controlPoint1.y && this.controlPoint2.x === c.controlPoint2.x && this.controlPoint2.y === c.controlPoint2.y && this.end.x === c.end.x && this.end.y === c.end.y;\n  },\n  // Returns five helper points necessary for curve division.\n  getSkeletonPoints: function (t) {\n    var start = this.start;\n    var control1 = this.controlPoint1;\n    var control2 = this.controlPoint2;\n    var end = this.end; // shortcuts for `t` values that are out of range\n\n    if (t <= 0) {\n      return {\n        startControlPoint1: start.clone(),\n        startControlPoint2: start.clone(),\n        divider: start.clone(),\n        dividerControlPoint1: control1.clone(),\n        dividerControlPoint2: control2.clone()\n      };\n    }\n\n    if (t >= 1) {\n      return {\n        startControlPoint1: control1.clone(),\n        startControlPoint2: control2.clone(),\n        divider: end.clone(),\n        dividerControlPoint1: end.clone(),\n        dividerControlPoint2: end.clone()\n      };\n    }\n\n    var midpoint1 = new Line(start, control1).pointAt(t);\n    var midpoint2 = new Line(control1, control2).pointAt(t);\n    var midpoint3 = new Line(control2, end).pointAt(t);\n    var subControl1 = new Line(midpoint1, midpoint2).pointAt(t);\n    var subControl2 = new Line(midpoint2, midpoint3).pointAt(t);\n    var divider = new Line(subControl1, subControl2).pointAt(t);\n    var output = {\n      startControlPoint1: midpoint1,\n      startControlPoint2: subControl1,\n      divider: divider,\n      dividerControlPoint1: subControl2,\n      dividerControlPoint2: midpoint3\n    };\n    return output;\n  },\n  // Returns a list of curves whose flattened length is better than `opt.precision`.\n  // That is, observed difference in length between recursions is less than 10^(-3) = 0.001 = 0.1%\n  // (Observed difference is not real precision, but close enough as long as special cases are covered)\n  // (That is why skipping iteration 1 is important)\n  // As a rule of thumb, increasing `precision` by 1 requires two more division operations\n  // - Precision 0 (endpointDistance) - total of 2^0 - 1 = 0 operations (1 subdivision)\n  // - Precision 1 (<10% error) - total of 2^2 - 1 = 3 operations (4 subdivisions)\n  // - Precision 2 (<1% error) - total of 2^4 - 1 = 15 operations requires 4 division operations on all elements (15 operations total) (16 subdivisions)\n  // - Precision 3 (<0.1% error) - total of 2^6 - 1 = 63 operations - acceptable when drawing (64 subdivisions)\n  // - Precision 4 (<0.01% error) - total of 2^8 - 1 = 255 operations - high resolution, can be used to interpolate `t` (256 subdivisions)\n  // (Variation of 1 recursion worse or better is possible depending on the curve, doubling/halving the number of operations accordingly)\n  getSubdivisions: function (opt) {\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision; // not using opt.subdivisions\n    // not using localOpt\n\n    var subdivisions = [new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end)];\n    if (precision === 0) return subdivisions;\n    var previousLength = this.endpointDistance();\n    var precisionRatio = pow(10, -precision); // recursively divide curve at `t = 0.5`\n    // until the difference between observed length at subsequent iterations is lower than precision\n\n    var iteration = 0;\n\n    while (true) {\n      iteration += 1; // divide all subdivisions\n\n      var newSubdivisions = [];\n      var numSubdivisions = subdivisions.length;\n\n      for (var i = 0; i < numSubdivisions; i++) {\n        var currentSubdivision = subdivisions[i];\n        var divided = currentSubdivision.divide(0.5); // dividing at t = 0.5 (not at middle length!)\n\n        newSubdivisions.push(divided[0], divided[1]);\n      } // measure new length\n\n\n      var length = 0;\n      var numNewSubdivisions = newSubdivisions.length;\n\n      for (var j = 0; j < numNewSubdivisions; j++) {\n        var currentNewSubdivision = newSubdivisions[j];\n        length += currentNewSubdivision.endpointDistance();\n      } // check if we have reached required observed precision\n      // sine-like curves may have the same observed length in iteration 0 and 1 - skip iteration 1\n      // not a problem for further iterations because cubic curves cannot have more than two local extrema\n      // (i.e. cubic curves cannot intersect the baseline more than once)\n      // therefore two subsequent iterations cannot produce sampling with equal length\n\n\n      var observedPrecisionRatio = length !== 0 ? (length - previousLength) / length : 0;\n\n      if (iteration > 1 && observedPrecisionRatio < precisionRatio) {\n        return newSubdivisions;\n      } // otherwise, set up for next iteration\n\n\n      subdivisions = newSubdivisions;\n      previousLength = length;\n    }\n  },\n  isDifferentiable: function () {\n    var start = this.start;\n    var control1 = this.controlPoint1;\n    var control2 = this.controlPoint2;\n    var end = this.end;\n    return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));\n  },\n  // Returns flattened length of the curve with precision better than `opt.precision`; or using `opt.subdivisions` provided.\n  length: function (opt) {\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision; // opt.precision only used in getSubdivisions() call\n\n    var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({\n      precision: precision\n    }) : opt.subdivisions; // not using localOpt\n\n    var length = 0;\n    var n = subdivisions.length;\n\n    for (var i = 0; i < n; i++) {\n      var currentSubdivision = subdivisions[i];\n      length += currentSubdivision.endpointDistance();\n    }\n\n    return length;\n  },\n  // Returns distance along the curve up to `t` with precision better than requested `opt.precision`. (Not using `opt.subdivisions`.)\n  lengthAtT: function (t, opt) {\n    if (t <= 0) return 0;\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision; // not using opt.subdivisions\n    // not using localOpt\n\n    var subCurve = this.divide(t)[0];\n    var subCurveLength = subCurve.length({\n      precision: precision\n    });\n    return subCurveLength;\n  },\n  // Returns point at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.\n  // Mirrors Line.pointAt() function.\n  // For a function that tracks `t`, use Curve.pointAtT().\n  pointAt: function (ratio, opt) {\n    if (ratio <= 0) return this.start.clone();\n    if (ratio >= 1) return this.end.clone();\n    var t = this.tAt(ratio, opt);\n    return this.pointAtT(t);\n  },\n  // Returns point at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n  pointAtLength: function (length, opt) {\n    var t = this.tAtLength(length, opt);\n    return this.pointAtT(t);\n  },\n  // Returns the point at provided `t` between 0 and 1.\n  // `t` does not track distance along curve as it does in Line objects.\n  // Non-linear relationship, speeds up and slows down as curve warps!\n  // For linear length-based solution, use Curve.pointAt().\n  pointAtT: function (t) {\n    if (t <= 0) return this.start.clone();\n    if (t >= 1) return this.end.clone();\n    return this.getSkeletonPoints(t).divider;\n  },\n  // Default precision\n  PRECISION: 3,\n  round: function (precision) {\n    this.start.round(precision);\n    this.controlPoint1.round(precision);\n    this.controlPoint2.round(precision);\n    this.end.round(precision);\n    return this;\n  },\n  scale: function (sx, sy, origin) {\n    this.start.scale(sx, sy, origin);\n    this.controlPoint1.scale(sx, sy, origin);\n    this.controlPoint2.scale(sx, sy, origin);\n    this.end.scale(sx, sy, origin);\n    return this;\n  },\n  // Returns a tangent line at requested `ratio` with precision better than requested `opt.precision`; or using `opt.subdivisions` provided.\n  tangentAt: function (ratio, opt) {\n    if (!this.isDifferentiable()) return null;\n    if (ratio < 0) ratio = 0;else if (ratio > 1) ratio = 1;\n    var t = this.tAt(ratio, opt);\n    return this.tangentAtT(t);\n  },\n  // Returns a tangent line at requested `length` with precision better than requested `opt.precision`; or using `opt.subdivisions` provided.\n  tangentAtLength: function (length, opt) {\n    if (!this.isDifferentiable()) return null;\n    var t = this.tAtLength(length, opt);\n    return this.tangentAtT(t);\n  },\n  // Returns a tangent line at requested `t`.\n  tangentAtT: function (t) {\n    if (!this.isDifferentiable()) return null;\n    if (t < 0) t = 0;else if (t > 1) t = 1;\n    var skeletonPoints = this.getSkeletonPoints(t);\n    var p1 = skeletonPoints.startControlPoint2;\n    var p2 = skeletonPoints.dividerControlPoint1;\n    var tangentStart = skeletonPoints.divider;\n    var tangentLine = new Line(p1, p2);\n    tangentLine.translate(tangentStart.x - p1.x, tangentStart.y - p1.y); // move so that tangent line starts at the point requested\n\n    return tangentLine;\n  },\n  // Returns `t` at requested `ratio` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n  tAt: function (ratio, opt) {\n    if (ratio <= 0) return 0;\n    if (ratio >= 1) return 1;\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({\n      precision: precision\n    }) : opt.subdivisions;\n    var localOpt = {\n      precision: precision,\n      subdivisions: subdivisions\n    };\n    var curveLength = this.length(localOpt);\n    var length = curveLength * ratio;\n    return this.tAtLength(length, localOpt);\n  },\n  // Returns `t` at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n  // Uses `precision` to approximate length within `precision` (always underestimates)\n  // Then uses a binary search to find the `t` of a subdivision endpoint that is close (within `precision`) to the `length`, if the curve was as long as approximated\n  // As a rule of thumb, increasing `precision` by 1 causes the algorithm to go 2^(precision - 1) deeper\n  // - Precision 0 (chooses one of the two endpoints) - 0 levels\n  // - Precision 1 (chooses one of 5 points, <10% error) - 1 level\n  // - Precision 2 (<1% error) - 3 levels\n  // - Precision 3 (<0.1% error) - 7 levels\n  // - Precision 4 (<0.01% error) - 15 levels\n  tAtLength: function (length, opt) {\n    var fromStart = true;\n\n    if (length < 0) {\n      fromStart = false; // negative lengths mean start calculation from end point\n\n      length = -length; // absolute value\n    }\n\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({\n      precision: precision\n    }) : opt.subdivisions;\n    var localOpt = {\n      precision: precision,\n      subdivisions: subdivisions\n    }; // identify the subdivision that contains the point at requested `length`:\n\n    var investigatedSubdivision;\n    var investigatedSubdivisionStartT; // assume that subdivisions are evenly spaced\n\n    var investigatedSubdivisionEndT; //var baseline; // straightened version of subdivision to investigate\n    //var baselinePoint; // point on the baseline that is the requested distance away from start\n\n    var baselinePointDistFromStart; // distance of baselinePoint from start of baseline\n\n    var baselinePointDistFromEnd; // distance of baselinePoint from end of baseline\n\n    var l = 0; // length so far\n\n    var n = subdivisions.length;\n    var subdivisionSize = 1 / n;\n\n    for (var i = 0; i < n; i++) {\n      var index = fromStart ? i : n - 1 - i;\n      var currentSubdivision = subdivisions[i];\n      var d = currentSubdivision.endpointDistance(); // length of current subdivision\n\n      if (length <= l + d) {\n        investigatedSubdivision = currentSubdivision;\n        investigatedSubdivisionStartT = index * subdivisionSize;\n        investigatedSubdivisionEndT = (index + 1) * subdivisionSize;\n        baselinePointDistFromStart = fromStart ? length - l : d + l - length;\n        baselinePointDistFromEnd = fromStart ? d + l - length : length - l;\n        break;\n      }\n\n      l += d;\n    }\n\n    if (!investigatedSubdivision) return fromStart ? 1 : 0; // length requested is out of range - return maximum t\n    // note that precision affects what length is recorded\n    // (imprecise measurements underestimate length by up to 10^(-precision) of the precise length)\n    // e.g. at precision 1, the length may be underestimated by up to 10% and cause this function to return 1\n\n    var curveLength = this.length(localOpt);\n    var precisionRatio = pow(10, -precision); // recursively divide investigated subdivision:\n    // until distance between baselinePoint and closest path endpoint is within 10^(-precision)\n    // then return the closest endpoint of that final subdivision\n\n    while (true) {\n      // check if we have reached required observed precision\n      var observedPrecisionRatio;\n      observedPrecisionRatio = curveLength !== 0 ? baselinePointDistFromStart / curveLength : 0;\n      if (observedPrecisionRatio < precisionRatio) return investigatedSubdivisionStartT;\n      observedPrecisionRatio = curveLength !== 0 ? baselinePointDistFromEnd / curveLength : 0;\n      if (observedPrecisionRatio < precisionRatio) return investigatedSubdivisionEndT; // otherwise, set up for next iteration\n\n      var newBaselinePointDistFromStart;\n      var newBaselinePointDistFromEnd;\n      var divided = investigatedSubdivision.divide(0.5);\n      subdivisionSize /= 2;\n      var baseline1Length = divided[0].endpointDistance();\n      var baseline2Length = divided[1].endpointDistance();\n\n      if (baselinePointDistFromStart <= baseline1Length) {\n        // point at requested length is inside divided[0]\n        investigatedSubdivision = divided[0];\n        investigatedSubdivisionEndT -= subdivisionSize; // sudivisionSize was already halved\n\n        newBaselinePointDistFromStart = baselinePointDistFromStart;\n        newBaselinePointDistFromEnd = baseline1Length - newBaselinePointDistFromStart;\n      } else {\n        // point at requested length is inside divided[1]\n        investigatedSubdivision = divided[1];\n        investigatedSubdivisionStartT += subdivisionSize; // subdivisionSize was already halved\n\n        newBaselinePointDistFromStart = baselinePointDistFromStart - baseline1Length;\n        newBaselinePointDistFromEnd = baseline2Length - newBaselinePointDistFromStart;\n      }\n\n      baselinePointDistFromStart = newBaselinePointDistFromStart;\n      baselinePointDistFromEnd = newBaselinePointDistFromEnd;\n    }\n  },\n  // Returns an array of points that represents the curve when flattened, up to `opt.precision`; or using `opt.subdivisions` provided.\n  // Flattened length is no more than 10^(-precision) away from real curve length.\n  toPoints: function (opt) {\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision; // opt.precision only used in getSubdivisions() call\n\n    var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({\n      precision: precision\n    }) : opt.subdivisions; // not using localOpt\n\n    var points = [subdivisions[0].start.clone()];\n    var n = subdivisions.length;\n\n    for (var i = 0; i < n; i++) {\n      var currentSubdivision = subdivisions[i];\n      points.push(currentSubdivision.end.clone());\n    }\n\n    return points;\n  },\n  // Returns a polyline that represents the curve when flattened, up to `opt.precision`; or using `opt.subdivisions` provided.\n  // Flattened length is no more than 10^(-precision) away from real curve length.\n  toPolyline: function (opt) {\n    return new Polyline(this.toPoints(opt));\n  },\n  toString: function () {\n    return this.start + ' ' + this.controlPoint1 + ' ' + this.controlPoint2 + ' ' + this.end;\n  },\n  translate: function (tx, ty) {\n    this.start.translate(tx, ty);\n    this.controlPoint1.translate(tx, ty);\n    this.controlPoint2.translate(tx, ty);\n    this.end.translate(tx, ty);\n    return this;\n  }\n};\nCurve.prototype.divide = Curve.prototype.divideAtT;","map":{"version":3,"names":["Point","Rect","Line","Polyline","types","abs","sqrt","min","max","pow","Math","Curve","p1","p2","p3","p4","start","controlPoint1","controlPoint2","end","throughPoints","getCurveControlPoints","knots","firstControlPoints","secondControlPoints","n","length","i","x","y","rhs","getFirstControlPoints","push","tmp","b","points","Array","isArray","Error","controlPoints","curves","prototype","type","bbox","x0","y0","x1","y1","x2","y2","x3","y3","tvalues","bounds","a","c","t","t1","t2","b2ac","sqrtb2ac","j","jlen","mt","X","Y","left","apply","top","right","bottom","clone","closestPoint","p","opt","pointAtT","closestPointT","closestPointLength","precision","undefined","PRECISION","subdivisions","getSubdivisions","localOpt","lengthAtT","closestPointNormalizedLength","cpLength","investigatedSubdivision","investigatedSubdivisionStartT","investigatedSubdivisionEndT","distFromStart","distFromEnd","chordLength","minSumDist","subdivisionSize","currentSubdivision","startDist","distance","endDist","sumDist","precisionRatio","startPrecisionRatio","endPrecisionRatio","hasRequiredPrecision","hasMinimalStartDistance","hasMinimalEndDistance","hasMinimalDistance","divided","divide","startDist1","endDist1","sumDist1","startDist2","endDist2","sumDist2","closestPointTangent","tangentAtT","containsPoint","polyline","toPolyline","divideAt","ratio","divideAtT","tAt","divideAtLength","tAtLength","dividerPoints","getSkeletonPoints","startControl1","startControlPoint1","startControl2","startControlPoint2","divider","dividerControl1","dividerControlPoint1","dividerControl2","dividerControlPoint2","endpointDistance","equals","control1","control2","midpoint1","pointAt","midpoint2","midpoint3","subControl1","subControl2","output","previousLength","iteration","newSubdivisions","numSubdivisions","numNewSubdivisions","currentNewSubdivision","observedPrecisionRatio","isDifferentiable","subCurve","subCurveLength","pointAtLength","round","scale","sx","sy","origin","tangentAt","tangentAtLength","skeletonPoints","tangentStart","tangentLine","translate","curveLength","fromStart","baselinePointDistFromStart","baselinePointDistFromEnd","l","index","d","newBaselinePointDistFromStart","newBaselinePointDistFromEnd","baseline1Length","baseline2Length","toPoints","toString","tx","ty"],"sources":["C:/Users/Admin/dataflow-test/node_modules/jointjs/src/g/curve.mjs"],"sourcesContent":["import { Point } from './point.mjs';\nimport { Rect } from './rect.mjs';\nimport { Line } from './line.mjs';\nimport { Polyline } from './polyline.mjs';\nimport { types } from './types.mjs';\n\nconst {\n    abs,\n    sqrt,\n    min,\n    max,\n    pow\n} = Math;\n\nexport const Curve = function(p1, p2, p3, p4) {\n\n    if (!(this instanceof Curve)) {\n        return new Curve(p1, p2, p3, p4);\n    }\n\n    if (p1 instanceof Curve) {\n        return new Curve(p1.start, p1.controlPoint1, p1.controlPoint2, p1.end);\n    }\n\n    this.start = new Point(p1);\n    this.controlPoint1 = new Point(p2);\n    this.controlPoint2 = new Point(p3);\n    this.end = new Point(p4);\n};\n\n// Curve passing through points.\n// Ported from C# implementation by Oleg V. Polikarpotchkin and Peter Lee (http://www.codeproject.com/KB/graphics/BezierSpline.aspx).\n// @param {array} points Array of points through which the smooth line will go.\n// @return {array} curves.\nCurve.throughPoints = (function() {\n\n    // Get open-ended Bezier Spline Control Points.\n    // @param knots Input Knot Bezier spline points (At least two points!).\n    // @param firstControlPoints Output First Control points. Array of knots.length - 1 length.\n    // @param secondControlPoints Output Second Control points. Array of knots.length - 1 length.\n    function getCurveControlPoints(knots) {\n\n        var firstControlPoints = [];\n        var secondControlPoints = [];\n        var n = knots.length - 1;\n        var i;\n\n        // Special case: Bezier curve should be a straight line.\n        if (n == 1) {\n            // 3P1 = 2P0 + P3\n            firstControlPoints[0] = new Point(\n                (2 * knots[0].x + knots[1].x) / 3,\n                (2 * knots[0].y + knots[1].y) / 3\n            );\n\n            // P2 = 2P1 â€“ P0\n            secondControlPoints[0] = new Point(\n                2 * firstControlPoints[0].x - knots[0].x,\n                2 * firstControlPoints[0].y - knots[0].y\n            );\n\n            return [firstControlPoints, secondControlPoints];\n        }\n\n        // Calculate first Bezier control points.\n        // Right hand side vector.\n        var rhs = [];\n\n        // Set right hand side X values.\n        for (i = 1; i < n - 1; i++) {\n            rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;\n        }\n\n        rhs[0] = knots[0].x + 2 * knots[1].x;\n        rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0;\n\n        // Get first control points X-values.\n        var x = getFirstControlPoints(rhs);\n\n        // Set right hand side Y values.\n        for (i = 1; i < n - 1; ++i) {\n            rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;\n        }\n\n        rhs[0] = knots[0].y + 2 * knots[1].y;\n        rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0;\n\n        // Get first control points Y-values.\n        var y = getFirstControlPoints(rhs);\n\n        // Fill output arrays.\n        for (i = 0; i < n; i++) {\n            // First control point.\n            firstControlPoints.push(new Point(x[i], y[i]));\n\n            // Second control point.\n            if (i < n - 1) {\n                secondControlPoints.push(new Point(\n                    2 * knots [i + 1].x - x[i + 1],\n                    2 * knots[i + 1].y - y[i + 1]\n                ));\n\n            } else {\n                secondControlPoints.push(new Point(\n                    (knots[n].x + x[n - 1]) / 2,\n                    (knots[n].y + y[n - 1]) / 2\n                ));\n            }\n        }\n\n        return [firstControlPoints, secondControlPoints];\n    }\n\n    // Solves a tridiagonal system for one of coordinates (x or y) of first Bezier control points.\n    // @param rhs Right hand side vector.\n    // @return Solution vector.\n    function getFirstControlPoints(rhs) {\n\n        var n = rhs.length;\n        // `x` is a solution vector.\n        var x = [];\n        var tmp = [];\n        var b = 2.0;\n\n        x[0] = rhs[0] / b;\n\n        // Decomposition and forward substitution.\n        for (var i = 1; i < n; i++) {\n            tmp[i] = 1 / b;\n            b = (i < n - 1 ? 4.0 : 3.5) - tmp[i];\n            x[i] = (rhs[i] - x[i - 1]) / b;\n        }\n\n        for (i = 1; i < n; i++) {\n            // Backsubstitution.\n            x[n - i - 1] -= tmp[n - i] * x[n - i];\n        }\n\n        return x;\n    }\n\n    return function(points) {\n\n        if (!points || (Array.isArray(points) && points.length < 2)) {\n            throw new Error('At least 2 points are required');\n        }\n\n        var controlPoints = getCurveControlPoints(points);\n\n        var curves = [];\n        var n = controlPoints[0].length;\n        for (var i = 0; i < n; i++) {\n\n            var controlPoint1 = new Point(controlPoints[0][i].x, controlPoints[0][i].y);\n            var controlPoint2 = new Point(controlPoints[1][i].x, controlPoints[1][i].y);\n\n            curves.push(new Curve(points[i], controlPoint1, controlPoint2, points[i + 1]));\n        }\n\n        return curves;\n    };\n})();\n\nCurve.prototype = {\n\n    type: types.Curve,\n\n    // Returns a bbox that tightly envelops the curve.\n    bbox: function() {\n\n        var start = this.start;\n        var controlPoint1 = this.controlPoint1;\n        var controlPoint2 = this.controlPoint2;\n        var end = this.end;\n\n        var x0 = start.x;\n        var y0 = start.y;\n        var x1 = controlPoint1.x;\n        var y1 = controlPoint1.y;\n        var x2 = controlPoint2.x;\n        var y2 = controlPoint2.y;\n        var x3 = end.x;\n        var y3 = end.y;\n\n        var points = new Array(); // local extremes\n        var tvalues = new Array(); // t values of local extremes\n        var bounds = [new Array(), new Array()];\n\n        var a, b, c, t;\n        var t1, t2;\n        var b2ac, sqrtb2ac;\n\n        for (var i = 0; i < 2; ++i) {\n\n            if (i === 0) {\n                b = 6 * x0 - 12 * x1 + 6 * x2;\n                a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n                c = 3 * x1 - 3 * x0;\n\n            } else {\n                b = 6 * y0 - 12 * y1 + 6 * y2;\n                a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n                c = 3 * y1 - 3 * y0;\n            }\n\n            if (abs(a) < 1e-12) { // Numerical robustness\n                if (abs(b) < 1e-12) { // Numerical robustness\n                    continue;\n                }\n\n                t = -c / b;\n                if ((0 < t) && (t < 1)) tvalues.push(t);\n\n                continue;\n            }\n\n            b2ac = b * b - 4 * c * a;\n            sqrtb2ac = sqrt(b2ac);\n\n            if (b2ac < 0) continue;\n\n            t1 = (-b + sqrtb2ac) / (2 * a);\n            if ((0 < t1) && (t1 < 1)) tvalues.push(t1);\n\n            t2 = (-b - sqrtb2ac) / (2 * a);\n            if ((0 < t2) && (t2 < 1)) tvalues.push(t2);\n        }\n\n        var j = tvalues.length;\n        var jlen = j;\n        var mt;\n        var x, y;\n\n        while (j--) {\n            t = tvalues[j];\n            mt = 1 - t;\n\n            x = (mt * mt * mt * x0) + (3 * mt * mt * t * x1) + (3 * mt * t * t * x2) + (t * t * t * x3);\n            bounds[0][j] = x;\n\n            y = (mt * mt * mt * y0) + (3 * mt * mt * t * y1) + (3 * mt * t * t * y2) + (t * t * t * y3);\n            bounds[1][j] = y;\n\n            points[j] = { X: x, Y: y };\n        }\n\n        tvalues[jlen] = 0;\n        tvalues[jlen + 1] = 1;\n\n        points[jlen] = { X: x0, Y: y0 };\n        points[jlen + 1] = { X: x3, Y: y3 };\n\n        bounds[0][jlen] = x0;\n        bounds[1][jlen] = y0;\n\n        bounds[0][jlen + 1] = x3;\n        bounds[1][jlen + 1] = y3;\n\n        tvalues.length = jlen + 2;\n        bounds[0].length = jlen + 2;\n        bounds[1].length = jlen + 2;\n        points.length = jlen + 2;\n\n        var left = min.apply(null, bounds[0]);\n        var top = min.apply(null, bounds[1]);\n        var right = max.apply(null, bounds[0]);\n        var bottom = max.apply(null, bounds[1]);\n\n        return new Rect(left, top, (right - left), (bottom - top));\n    },\n\n    clone: function() {\n\n        return new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n    },\n\n    // Returns the point on the curve closest to point `p`\n    closestPoint: function(p, opt) {\n\n        return this.pointAtT(this.closestPointT(p, opt));\n    },\n\n    closestPointLength: function(p, opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n        var localOpt = { precision: precision, subdivisions: subdivisions };\n\n        return this.lengthAtT(this.closestPointT(p, localOpt), localOpt);\n    },\n\n    closestPointNormalizedLength: function(p, opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n        var localOpt = { precision: precision, subdivisions: subdivisions };\n\n        var cpLength = this.closestPointLength(p, localOpt);\n        if (!cpLength) return 0;\n\n        var length = this.length(localOpt);\n        if (length === 0) return 0;\n\n        return cpLength / length;\n    },\n\n    // Returns `t` of the point on the curve closest to point `p`\n    closestPointT: function(p, opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n        // does not use localOpt\n\n        // identify the subdivision that contains the point:\n        var investigatedSubdivision;\n        var investigatedSubdivisionStartT; // assume that subdivisions are evenly spaced\n        var investigatedSubdivisionEndT;\n        var distFromStart; // distance of point from start of baseline\n        var distFromEnd; // distance of point from end of baseline\n        var chordLength; // distance between start and end of the subdivision\n        var minSumDist; // lowest observed sum of the two distances\n        var n = subdivisions.length;\n        var subdivisionSize = (n ? (1 / n) : 0);\n        for (var i = 0; i < n; i++) {\n\n            var currentSubdivision = subdivisions[i];\n\n            var startDist = currentSubdivision.start.distance(p);\n            var endDist = currentSubdivision.end.distance(p);\n            var sumDist = startDist + endDist;\n\n            // check that the point is closest to current subdivision and not any other\n            if (!minSumDist || (sumDist < minSumDist)) {\n                investigatedSubdivision = currentSubdivision;\n\n                investigatedSubdivisionStartT = i * subdivisionSize;\n                investigatedSubdivisionEndT = (i + 1) * subdivisionSize;\n\n                distFromStart = startDist;\n                distFromEnd = endDist;\n\n                chordLength = currentSubdivision.start.distance(currentSubdivision.end);\n\n                minSumDist = sumDist;\n            }\n        }\n\n        var precisionRatio = pow(10, -precision);\n\n        // recursively divide investigated subdivision:\n        // until distance between baselinePoint and closest path endpoint is within 10^(-precision)\n        // then return the closest endpoint of that final subdivision\n        while (true) {\n\n            // check if we have reached at least one required observed precision\n            // - calculated as: the difference in distances from point to start and end divided by the distance\n            // - note that this function is not monotonic = it doesn't converge stably but has \"teeth\"\n            // - the function decreases while one of the endpoints is fixed but \"jumps\" whenever we switch\n            // - this criterion works well for points lying far away from the curve\n            var startPrecisionRatio = (distFromStart ? (abs(distFromStart - distFromEnd) / distFromStart) : 0);\n            var endPrecisionRatio = (distFromEnd ? (abs(distFromStart - distFromEnd) / distFromEnd) : 0);\n            var hasRequiredPrecision = ((startPrecisionRatio < precisionRatio) || (endPrecisionRatio < precisionRatio));\n\n            // check if we have reached at least one required minimal distance\n            // - calculated as: the subdivision chord length multiplied by precisionRatio\n            // - calculation is relative so it will work for arbitrarily large/small curves and their subdivisions\n            // - this is a backup criterion that works well for points lying \"almost at\" the curve\n            var hasMinimalStartDistance = (distFromStart ? (distFromStart < (chordLength * precisionRatio)) : true);\n            var hasMinimalEndDistance = (distFromEnd ? (distFromEnd < (chordLength * precisionRatio)) : true);\n            var hasMinimalDistance = (hasMinimalStartDistance || hasMinimalEndDistance);\n\n            // do we stop now?\n            if (hasRequiredPrecision || hasMinimalDistance) {\n                return ((distFromStart <= distFromEnd) ? investigatedSubdivisionStartT : investigatedSubdivisionEndT);\n            }\n\n            // otherwise, set up for next iteration\n            var divided = investigatedSubdivision.divide(0.5);\n            subdivisionSize /= 2;\n\n            var startDist1 = divided[0].start.distance(p);\n            var endDist1 = divided[0].end.distance(p);\n            var sumDist1 = startDist1 + endDist1;\n\n            var startDist2 = divided[1].start.distance(p);\n            var endDist2 = divided[1].end.distance(p);\n            var sumDist2 = startDist2 + endDist2;\n\n            if (sumDist1 <= sumDist2) {\n                investigatedSubdivision = divided[0];\n\n                investigatedSubdivisionEndT -= subdivisionSize; // subdivisionSize was already halved\n\n                distFromStart = startDist1;\n                distFromEnd = endDist1;\n\n            } else {\n                investigatedSubdivision = divided[1];\n\n                investigatedSubdivisionStartT += subdivisionSize; // subdivisionSize was already halved\n\n                distFromStart = startDist2;\n                distFromEnd = endDist2;\n            }\n        }\n    },\n\n    closestPointTangent: function(p, opt) {\n\n        return this.tangentAtT(this.closestPointT(p, opt));\n    },\n\n    // Returns `true` if the area surrounded by the curve contains the point `p`.\n    // Implements the even-odd algorithm (self-intersections are \"outside\").\n    // Closes open curves (always imagines a closing segment).\n    // Precision may be adjusted by passing an `opt` object.\n    containsPoint: function(p, opt) {\n\n        var polyline = this.toPolyline(opt);\n        return polyline.containsPoint(p);\n    },\n\n    // Divides the curve into two at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.\n    // For a function that uses `t`, use Curve.divideAtT().\n    divideAt: function(ratio, opt) {\n\n        if (ratio <= 0) return this.divideAtT(0);\n        if (ratio >= 1) return this.divideAtT(1);\n\n        var t = this.tAt(ratio, opt);\n\n        return this.divideAtT(t);\n    },\n\n    // Divides the curve into two at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n    divideAtLength: function(length, opt) {\n\n        var t = this.tAtLength(length, opt);\n\n        return this.divideAtT(t);\n    },\n\n    // Divides the curve into two at point defined by `t` between 0 and 1.\n    // Using de Casteljau's algorithm (http://math.stackexchange.com/a/317867).\n    // Additional resource: https://pomax.github.io/bezierinfo/#decasteljau\n    divideAtT: function(t) {\n\n        var start = this.start;\n        var controlPoint1 = this.controlPoint1;\n        var controlPoint2 = this.controlPoint2;\n        var end = this.end;\n\n        // shortcuts for `t` values that are out of range\n        if (t <= 0) {\n            return [\n                new Curve(start, start, start, start),\n                new Curve(start, controlPoint1, controlPoint2, end)\n            ];\n        }\n\n        if (t >= 1) {\n            return [\n                new Curve(start, controlPoint1, controlPoint2, end),\n                new Curve(end, end, end, end)\n            ];\n        }\n\n        var dividerPoints = this.getSkeletonPoints(t);\n\n        var startControl1 = dividerPoints.startControlPoint1;\n        var startControl2 = dividerPoints.startControlPoint2;\n        var divider = dividerPoints.divider;\n        var dividerControl1 = dividerPoints.dividerControlPoint1;\n        var dividerControl2 = dividerPoints.dividerControlPoint2;\n\n        // return array with two new curves\n        return [\n            new Curve(start, startControl1, startControl2, divider),\n            new Curve(divider, dividerControl1, dividerControl2, end)\n        ];\n    },\n\n    // Returns the distance between the curve's start and end points.\n    endpointDistance: function() {\n\n        return this.start.distance(this.end);\n    },\n\n    // Checks whether two curves are exactly the same.\n    equals: function(c) {\n\n        return !!c &&\n            this.start.x === c.start.x &&\n            this.start.y === c.start.y &&\n            this.controlPoint1.x === c.controlPoint1.x &&\n            this.controlPoint1.y === c.controlPoint1.y &&\n            this.controlPoint2.x === c.controlPoint2.x &&\n            this.controlPoint2.y === c.controlPoint2.y &&\n            this.end.x === c.end.x &&\n            this.end.y === c.end.y;\n    },\n\n    // Returns five helper points necessary for curve division.\n    getSkeletonPoints: function(t) {\n\n        var start = this.start;\n        var control1 = this.controlPoint1;\n        var control2 = this.controlPoint2;\n        var end = this.end;\n\n        // shortcuts for `t` values that are out of range\n        if (t <= 0) {\n            return {\n                startControlPoint1: start.clone(),\n                startControlPoint2: start.clone(),\n                divider: start.clone(),\n                dividerControlPoint1: control1.clone(),\n                dividerControlPoint2: control2.clone()\n            };\n        }\n\n        if (t >= 1) {\n            return {\n                startControlPoint1: control1.clone(),\n                startControlPoint2: control2.clone(),\n                divider: end.clone(),\n                dividerControlPoint1: end.clone(),\n                dividerControlPoint2: end.clone()\n            };\n        }\n\n        var midpoint1 = (new Line(start, control1)).pointAt(t);\n        var midpoint2 = (new Line(control1, control2)).pointAt(t);\n        var midpoint3 = (new Line(control2, end)).pointAt(t);\n\n        var subControl1 = (new Line(midpoint1, midpoint2)).pointAt(t);\n        var subControl2 = (new Line(midpoint2, midpoint3)).pointAt(t);\n\n        var divider = (new Line(subControl1, subControl2)).pointAt(t);\n\n        var output = {\n            startControlPoint1: midpoint1,\n            startControlPoint2: subControl1,\n            divider: divider,\n            dividerControlPoint1: subControl2,\n            dividerControlPoint2: midpoint3\n        };\n\n        return output;\n    },\n\n    // Returns a list of curves whose flattened length is better than `opt.precision`.\n    // That is, observed difference in length between recursions is less than 10^(-3) = 0.001 = 0.1%\n    // (Observed difference is not real precision, but close enough as long as special cases are covered)\n    // (That is why skipping iteration 1 is important)\n    // As a rule of thumb, increasing `precision` by 1 requires two more division operations\n    // - Precision 0 (endpointDistance) - total of 2^0 - 1 = 0 operations (1 subdivision)\n    // - Precision 1 (<10% error) - total of 2^2 - 1 = 3 operations (4 subdivisions)\n    // - Precision 2 (<1% error) - total of 2^4 - 1 = 15 operations requires 4 division operations on all elements (15 operations total) (16 subdivisions)\n    // - Precision 3 (<0.1% error) - total of 2^6 - 1 = 63 operations - acceptable when drawing (64 subdivisions)\n    // - Precision 4 (<0.01% error) - total of 2^8 - 1 = 255 operations - high resolution, can be used to interpolate `t` (256 subdivisions)\n    // (Variation of 1 recursion worse or better is possible depending on the curve, doubling/halving the number of operations accordingly)\n    getSubdivisions: function(opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        // not using opt.subdivisions\n        // not using localOpt\n\n        var subdivisions = [new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end)];\n        if (precision === 0) return subdivisions;\n\n        var previousLength = this.endpointDistance();\n\n        var precisionRatio = pow(10, -precision);\n\n        // recursively divide curve at `t = 0.5`\n        // until the difference between observed length at subsequent iterations is lower than precision\n        var iteration = 0;\n        while (true) {\n            iteration += 1;\n\n            // divide all subdivisions\n            var newSubdivisions = [];\n            var numSubdivisions = subdivisions.length;\n            for (var i = 0; i < numSubdivisions; i++) {\n\n                var currentSubdivision = subdivisions[i];\n                var divided = currentSubdivision.divide(0.5); // dividing at t = 0.5 (not at middle length!)\n                newSubdivisions.push(divided[0], divided[1]);\n            }\n\n            // measure new length\n            var length = 0;\n            var numNewSubdivisions = newSubdivisions.length;\n            for (var j = 0; j < numNewSubdivisions; j++) {\n\n                var currentNewSubdivision = newSubdivisions[j];\n                length += currentNewSubdivision.endpointDistance();\n            }\n\n            // check if we have reached required observed precision\n            // sine-like curves may have the same observed length in iteration 0 and 1 - skip iteration 1\n            // not a problem for further iterations because cubic curves cannot have more than two local extrema\n            // (i.e. cubic curves cannot intersect the baseline more than once)\n            // therefore two subsequent iterations cannot produce sampling with equal length\n            var observedPrecisionRatio = ((length !== 0) ? ((length - previousLength) / length) : 0);\n            if (iteration > 1 && observedPrecisionRatio < precisionRatio) {\n                return newSubdivisions;\n            }\n\n            // otherwise, set up for next iteration\n            subdivisions = newSubdivisions;\n            previousLength = length;\n        }\n    },\n\n    isDifferentiable: function() {\n\n        var start = this.start;\n        var control1 = this.controlPoint1;\n        var control2 = this.controlPoint2;\n        var end = this.end;\n\n        return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));\n    },\n\n    // Returns flattened length of the curve with precision better than `opt.precision`; or using `opt.subdivisions` provided.\n    length: function(opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision; // opt.precision only used in getSubdivisions() call\n        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n        // not using localOpt\n\n        var length = 0;\n        var n = subdivisions.length;\n        for (var i = 0; i < n; i++) {\n\n            var currentSubdivision = subdivisions[i];\n            length += currentSubdivision.endpointDistance();\n        }\n\n        return length;\n    },\n\n    // Returns distance along the curve up to `t` with precision better than requested `opt.precision`. (Not using `opt.subdivisions`.)\n    lengthAtT: function(t, opt) {\n\n        if (t <= 0) return 0;\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        // not using opt.subdivisions\n        // not using localOpt\n\n        var subCurve = this.divide(t)[0];\n        var subCurveLength = subCurve.length({ precision: precision });\n\n        return subCurveLength;\n    },\n\n    // Returns point at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.\n    // Mirrors Line.pointAt() function.\n    // For a function that tracks `t`, use Curve.pointAtT().\n    pointAt: function(ratio, opt) {\n\n        if (ratio <= 0) return this.start.clone();\n        if (ratio >= 1) return this.end.clone();\n\n        var t = this.tAt(ratio, opt);\n\n        return this.pointAtT(t);\n    },\n\n    // Returns point at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n    pointAtLength: function(length, opt) {\n\n        var t = this.tAtLength(length, opt);\n\n        return this.pointAtT(t);\n    },\n\n    // Returns the point at provided `t` between 0 and 1.\n    // `t` does not track distance along curve as it does in Line objects.\n    // Non-linear relationship, speeds up and slows down as curve warps!\n    // For linear length-based solution, use Curve.pointAt().\n    pointAtT: function(t) {\n\n        if (t <= 0) return this.start.clone();\n        if (t >= 1) return this.end.clone();\n\n        return this.getSkeletonPoints(t).divider;\n    },\n\n    // Default precision\n    PRECISION: 3,\n\n    round: function(precision) {\n\n        this.start.round(precision);\n        this.controlPoint1.round(precision);\n        this.controlPoint2.round(precision);\n        this.end.round(precision);\n        return this;\n    },\n\n    scale: function(sx, sy, origin) {\n\n        this.start.scale(sx, sy, origin);\n        this.controlPoint1.scale(sx, sy, origin);\n        this.controlPoint2.scale(sx, sy, origin);\n        this.end.scale(sx, sy, origin);\n        return this;\n    },\n\n    // Returns a tangent line at requested `ratio` with precision better than requested `opt.precision`; or using `opt.subdivisions` provided.\n    tangentAt: function(ratio, opt) {\n\n        if (!this.isDifferentiable()) return null;\n\n        if (ratio < 0) ratio = 0;\n        else if (ratio > 1) ratio = 1;\n\n        var t = this.tAt(ratio, opt);\n\n        return this.tangentAtT(t);\n    },\n\n    // Returns a tangent line at requested `length` with precision better than requested `opt.precision`; or using `opt.subdivisions` provided.\n    tangentAtLength: function(length, opt) {\n\n        if (!this.isDifferentiable()) return null;\n\n        var t = this.tAtLength(length, opt);\n\n        return this.tangentAtT(t);\n    },\n\n    // Returns a tangent line at requested `t`.\n    tangentAtT: function(t) {\n\n        if (!this.isDifferentiable()) return null;\n\n        if (t < 0) t = 0;\n        else if (t > 1) t = 1;\n\n        var skeletonPoints = this.getSkeletonPoints(t);\n\n        var p1 = skeletonPoints.startControlPoint2;\n        var p2 = skeletonPoints.dividerControlPoint1;\n\n        var tangentStart = skeletonPoints.divider;\n\n        var tangentLine = new Line(p1, p2);\n        tangentLine.translate(tangentStart.x - p1.x, tangentStart.y - p1.y); // move so that tangent line starts at the point requested\n\n        return tangentLine;\n    },\n\n    // Returns `t` at requested `ratio` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n    tAt: function(ratio, opt) {\n\n        if (ratio <= 0) return 0;\n        if (ratio >= 1) return 1;\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n        var localOpt = { precision: precision, subdivisions: subdivisions };\n\n        var curveLength = this.length(localOpt);\n        var length = curveLength * ratio;\n\n        return this.tAtLength(length, localOpt);\n    },\n\n    // Returns `t` at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n    // Uses `precision` to approximate length within `precision` (always underestimates)\n    // Then uses a binary search to find the `t` of a subdivision endpoint that is close (within `precision`) to the `length`, if the curve was as long as approximated\n    // As a rule of thumb, increasing `precision` by 1 causes the algorithm to go 2^(precision - 1) deeper\n    // - Precision 0 (chooses one of the two endpoints) - 0 levels\n    // - Precision 1 (chooses one of 5 points, <10% error) - 1 level\n    // - Precision 2 (<1% error) - 3 levels\n    // - Precision 3 (<0.1% error) - 7 levels\n    // - Precision 4 (<0.01% error) - 15 levels\n    tAtLength: function(length, opt) {\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n        var localOpt = { precision: precision, subdivisions: subdivisions };\n\n        // identify the subdivision that contains the point at requested `length`:\n        var investigatedSubdivision;\n        var investigatedSubdivisionStartT; // assume that subdivisions are evenly spaced\n        var investigatedSubdivisionEndT;\n        //var baseline; // straightened version of subdivision to investigate\n        //var baselinePoint; // point on the baseline that is the requested distance away from start\n        var baselinePointDistFromStart; // distance of baselinePoint from start of baseline\n        var baselinePointDistFromEnd; // distance of baselinePoint from end of baseline\n        var l = 0; // length so far\n        var n = subdivisions.length;\n        var subdivisionSize = 1 / n;\n        for (var i = 0; i < n; i++) {\n            var index = (fromStart ? i : (n - 1 - i));\n\n            var currentSubdivision = subdivisions[i];\n            var d = currentSubdivision.endpointDistance(); // length of current subdivision\n\n            if (length <= (l + d)) {\n                investigatedSubdivision = currentSubdivision;\n\n                investigatedSubdivisionStartT = index * subdivisionSize;\n                investigatedSubdivisionEndT = (index + 1) * subdivisionSize;\n\n                baselinePointDistFromStart = (fromStart ? (length - l) : ((d + l) - length));\n                baselinePointDistFromEnd = (fromStart ? ((d + l) - length) : (length - l));\n\n                break;\n            }\n\n            l += d;\n        }\n\n        if (!investigatedSubdivision) return (fromStart ? 1 : 0); // length requested is out of range - return maximum t\n        // note that precision affects what length is recorded\n        // (imprecise measurements underestimate length by up to 10^(-precision) of the precise length)\n        // e.g. at precision 1, the length may be underestimated by up to 10% and cause this function to return 1\n\n        var curveLength = this.length(localOpt);\n\n        var precisionRatio = pow(10, -precision);\n\n        // recursively divide investigated subdivision:\n        // until distance between baselinePoint and closest path endpoint is within 10^(-precision)\n        // then return the closest endpoint of that final subdivision\n        while (true) {\n\n            // check if we have reached required observed precision\n            var observedPrecisionRatio;\n\n            observedPrecisionRatio = ((curveLength !== 0) ? (baselinePointDistFromStart / curveLength) : 0);\n            if (observedPrecisionRatio < precisionRatio) return investigatedSubdivisionStartT;\n            observedPrecisionRatio = ((curveLength !== 0) ? (baselinePointDistFromEnd / curveLength) : 0);\n            if (observedPrecisionRatio < precisionRatio) return investigatedSubdivisionEndT;\n\n            // otherwise, set up for next iteration\n            var newBaselinePointDistFromStart;\n            var newBaselinePointDistFromEnd;\n\n            var divided = investigatedSubdivision.divide(0.5);\n            subdivisionSize /= 2;\n\n            var baseline1Length = divided[0].endpointDistance();\n            var baseline2Length = divided[1].endpointDistance();\n\n            if (baselinePointDistFromStart <= baseline1Length) { // point at requested length is inside divided[0]\n                investigatedSubdivision = divided[0];\n\n                investigatedSubdivisionEndT -= subdivisionSize; // sudivisionSize was already halved\n\n                newBaselinePointDistFromStart = baselinePointDistFromStart;\n                newBaselinePointDistFromEnd = baseline1Length - newBaselinePointDistFromStart;\n\n            } else { // point at requested length is inside divided[1]\n                investigatedSubdivision = divided[1];\n\n                investigatedSubdivisionStartT += subdivisionSize; // subdivisionSize was already halved\n\n                newBaselinePointDistFromStart = baselinePointDistFromStart - baseline1Length;\n                newBaselinePointDistFromEnd = baseline2Length - newBaselinePointDistFromStart;\n            }\n\n            baselinePointDistFromStart = newBaselinePointDistFromStart;\n            baselinePointDistFromEnd = newBaselinePointDistFromEnd;\n        }\n    },\n\n    // Returns an array of points that represents the curve when flattened, up to `opt.precision`; or using `opt.subdivisions` provided.\n    // Flattened length is no more than 10^(-precision) away from real curve length.\n    toPoints: function(opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision; // opt.precision only used in getSubdivisions() call\n        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n        // not using localOpt\n\n        var points = [subdivisions[0].start.clone()];\n        var n = subdivisions.length;\n        for (var i = 0; i < n; i++) {\n\n            var currentSubdivision = subdivisions[i];\n            points.push(currentSubdivision.end.clone());\n        }\n\n        return points;\n    },\n\n    // Returns a polyline that represents the curve when flattened, up to `opt.precision`; or using `opt.subdivisions` provided.\n    // Flattened length is no more than 10^(-precision) away from real curve length.\n    toPolyline: function(opt) {\n\n        return new Polyline(this.toPoints(opt));\n    },\n\n    toString: function() {\n\n        return this.start + ' ' + this.controlPoint1 + ' ' + this.controlPoint2 + ' ' + this.end;\n    },\n\n    translate: function(tx, ty) {\n\n        this.start.translate(tx, ty);\n        this.controlPoint1.translate(tx, ty);\n        this.controlPoint2.translate(tx, ty);\n        this.end.translate(tx, ty);\n        return this;\n    }\n};\n\nCurve.prototype.divide = Curve.prototype.divideAtT;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}