{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.includes.js\";\nconst props = {\n  x: 'x',\n  y: 'y',\n  width: 'w',\n  height: 'h',\n  minimum: 's',\n  maximum: 'l',\n  diagonal: 'd'\n};\nconst propsList = Object.keys(props).map(key => props[key]).join('');\nconst numberPattern = '[-+]?[0-9]*\\\\.?[0-9]+(?:[eE][-+]?[0-9]+)?';\nconst findSpacesRegex = /\\s/g;\nconst parseExpressionRegExp = new RegExp(`^(${numberPattern}\\\\*)?([${propsList}])([-+]{1,2}${numberPattern})?$`, 'g');\n\nfunction throwInvalid(expression) {\n  throw new Error(`Invalid calc() expression: ${expression}`);\n}\n\nexport function evalCalcExpression(expression, bbox) {\n  const match = parseExpressionRegExp.exec(expression.replace(findSpacesRegex, ''));\n  if (!match) throwInvalid(expression);\n  parseExpressionRegExp.lastIndex = 0; // reset regex results for the next run\n\n  const [, multiply = 1, property, add = 0] = match;\n  const {\n    x,\n    y,\n    width,\n    height\n  } = bbox;\n  let value = 0;\n\n  switch (property) {\n    case props.width:\n      {\n        value = width;\n        break;\n      }\n\n    case props.height:\n      {\n        value = height;\n        break;\n      }\n\n    case props.x:\n      {\n        value = x;\n        break;\n      }\n\n    case props.y:\n      {\n        value = y;\n        break;\n      }\n\n    case props.minimum:\n      {\n        value = Math.min(height, width);\n        break;\n      }\n\n    case props.maximum:\n      {\n        value = Math.max(height, width);\n        break;\n      }\n\n    case props.diagonal:\n      {\n        value = Math.sqrt(height * height + width * width);\n        break;\n      }\n  }\n\n  return parseFloat(multiply) * value + evalAddExpression(add);\n}\n\nfunction evalAddExpression(addExpression) {\n  if (!addExpression) return 0;\n  const [sign] = addExpression;\n\n  switch (sign) {\n    case '+':\n      {\n        return parseFloat(addExpression.substr(1));\n      }\n\n    case '-':\n      {\n        return -parseFloat(addExpression.substr(1));\n      }\n  }\n\n  return parseFloat(addExpression);\n}\n\nexport function isCalcAttribute(value) {\n  return typeof value === 'string' && value.includes('calc');\n}\nconst calcStart = 'calc(';\nconst calcStartOffset = calcStart.length;\nexport function evalCalcAttribute(attributeValue, refBBox) {\n  let value = attributeValue;\n  let startSearchIndex = 0;\n\n  do {\n    let calcIndex = value.indexOf(calcStart, startSearchIndex);\n    if (calcIndex === -1) return value;\n    let calcEndIndex = calcIndex + calcStartOffset;\n    let brackets = 1;\n\n    findClosingBracket: do {\n      switch (value[calcEndIndex]) {\n        case '(':\n          {\n            brackets++;\n            break;\n          }\n\n        case ')':\n          {\n            brackets--;\n            if (brackets === 0) break findClosingBracket;\n            break;\n          }\n\n        case undefined:\n          {\n            // Could not find the closing bracket.\n            throwInvalid(value);\n          }\n      }\n\n      calcEndIndex++;\n    } while (true); // Get the calc() expression without nested calcs (recursion)\n\n\n    let expression = value.slice(calcIndex + calcStartOffset, calcEndIndex);\n\n    if (isCalcAttribute(expression)) {\n      expression = evalCalcAttribute(expression, refBBox);\n    } // Eval the calc() expression without nested calcs.\n\n\n    const calcValue = String(evalCalcExpression(expression, refBBox)); // Replace the calc() expression and continue search\n\n    value = value.slice(0, calcIndex) + calcValue + value.slice(calcEndIndex + 1);\n    startSearchIndex = calcIndex + calcValue.length;\n  } while (true);\n}","map":{"version":3,"names":["props","x","y","width","height","minimum","maximum","diagonal","propsList","Object","keys","map","key","join","numberPattern","findSpacesRegex","parseExpressionRegExp","RegExp","throwInvalid","expression","Error","evalCalcExpression","bbox","match","exec","replace","lastIndex","multiply","property","add","value","Math","min","max","sqrt","parseFloat","evalAddExpression","addExpression","sign","substr","isCalcAttribute","includes","calcStart","calcStartOffset","length","evalCalcAttribute","attributeValue","refBBox","startSearchIndex","calcIndex","indexOf","calcEndIndex","brackets","findClosingBracket","undefined","slice","calcValue","String"],"sources":["C:/Users/Admin/dataflow-test/node_modules/jointjs/src/dia/attributes/calc.mjs"],"sourcesContent":["const props = {\n    x: 'x',\n    y: 'y',\n    width: 'w',\n    height: 'h',\n    minimum: 's',\n    maximum: 'l',\n    diagonal: 'd'\n};\nconst propsList = Object.keys(props).map(key => props[key]).join('');\nconst numberPattern = '[-+]?[0-9]*\\\\.?[0-9]+(?:[eE][-+]?[0-9]+)?';\nconst findSpacesRegex = /\\s/g;\nconst parseExpressionRegExp = new RegExp(`^(${numberPattern}\\\\*)?([${propsList}])([-+]{1,2}${numberPattern})?$`, 'g');\n\nfunction throwInvalid(expression) {\n    throw new Error(`Invalid calc() expression: ${expression}`);\n}\n\nexport function evalCalcExpression(expression, bbox) {\n    const match = parseExpressionRegExp.exec(expression.replace(findSpacesRegex, ''));\n    if (!match) throwInvalid(expression);\n    parseExpressionRegExp.lastIndex = 0; // reset regex results for the next run\n    const [,multiply = 1, property, add = 0] = match;\n    const { x, y, width, height } = bbox;\n    let value = 0;\n    switch (property) {\n        case props.width: {\n            value = width;\n            break;\n        }\n        case props.height: {\n            value = height;\n            break;\n        }\n        case props.x: {\n            value = x;\n            break;\n        }\n        case props.y: {\n            value = y;\n            break;\n        }\n        case props.minimum: {\n            value = Math.min(height, width);\n            break;\n        }\n        case props.maximum: {\n            value = Math.max(height, width);\n            break;\n        }\n        case props.diagonal: {\n            value = Math.sqrt((height * height) + (width * width));\n            break;\n        }\n    }\n    return parseFloat(multiply) * value + evalAddExpression(add);\n}\n\nfunction evalAddExpression(addExpression) {\n    if (!addExpression) return 0;\n    const [sign] = addExpression;\n    switch (sign) {\n        case '+': {\n            return parseFloat(addExpression.substr(1));\n        }\n        case '-': {\n            return -parseFloat(addExpression.substr(1));\n        }\n    }\n    return parseFloat(addExpression);\n}\n\nexport function isCalcAttribute(value) {\n    return typeof value === 'string' && value.includes('calc');\n}\n\nconst calcStart = 'calc(';\nconst calcStartOffset = calcStart.length;\n\nexport function evalCalcAttribute(attributeValue, refBBox) {\n    let value = attributeValue;\n    let startSearchIndex = 0;\n    do {\n        let calcIndex = value.indexOf(calcStart, startSearchIndex);\n        if (calcIndex === -1) return value;\n        let calcEndIndex = calcIndex + calcStartOffset;\n        let brackets = 1;\n        findClosingBracket: do {\n            switch (value[calcEndIndex]) {\n                case '(': {\n                    brackets++;\n                    break;\n                }\n                case ')': {\n                    brackets--;\n                    if (brackets === 0) break findClosingBracket;\n                    break;\n                }\n                case undefined: {\n                    // Could not find the closing bracket.\n                    throwInvalid(value);\n                }\n            }\n            calcEndIndex++;\n        } while (true);\n        // Get the calc() expression without nested calcs (recursion)\n        let expression = value.slice(calcIndex + calcStartOffset, calcEndIndex);\n        if (isCalcAttribute(expression)) {\n            expression = evalCalcAttribute(expression, refBBox);\n        }\n        // Eval the calc() expression without nested calcs.\n        const calcValue = String(evalCalcExpression(expression, refBBox));\n        // Replace the calc() expression and continue search\n        value = value.slice(0, calcIndex) + calcValue + value.slice(calcEndIndex + 1);\n        startSearchIndex = calcIndex + calcValue.length;\n    } while (true);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}