{"ast":null,"code":"import { Point, Path, Polyline } from '../../g/index.mjs';\nimport { assign, isPlainObject, pick, isObject, isPercentage, breakText } from '../../util/util.mjs';\nimport { isCalcAttribute, evalCalcAttribute } from './calc.mjs';\nimport $ from 'jquery';\nimport V from '../../V/index.mjs';\n\nfunction setWrapper(attrName, dimension) {\n  return function (value, refBBox) {\n    var isValuePercentage = isPercentage(value);\n    value = parseFloat(value);\n\n    if (isValuePercentage) {\n      value /= 100;\n    }\n\n    var attrs = {};\n\n    if (isFinite(value)) {\n      var attrValue = isValuePercentage || value >= 0 && value <= 1 ? value * refBBox[dimension] : Math.max(value + refBBox[dimension], 0);\n      attrs[attrName] = attrValue;\n    }\n\n    return attrs;\n  };\n}\n\nfunction positionWrapper(axis, dimension, origin) {\n  return function (value, refBBox) {\n    var valuePercentage = isPercentage(value);\n    value = parseFloat(value);\n\n    if (valuePercentage) {\n      value /= 100;\n    }\n\n    var delta;\n\n    if (isFinite(value)) {\n      var refOrigin = refBBox[origin]();\n\n      if (valuePercentage || value > 0 && value < 1) {\n        delta = refOrigin[axis] + refBBox[dimension] * value;\n      } else {\n        delta = refOrigin[axis] + value;\n      }\n    }\n\n    var point = Point();\n    point[axis] = delta || 0;\n    return point;\n  };\n}\n\nfunction offsetWrapper(axis, dimension, corner) {\n  return function (value, nodeBBox) {\n    var delta;\n\n    if (value === 'middle') {\n      delta = nodeBBox[dimension] / 2;\n    } else if (value === corner) {\n      delta = nodeBBox[dimension];\n    } else if (isFinite(value)) {\n      // TODO: or not to do a breaking change?\n      delta = value > -1 && value < 1 ? -nodeBBox[dimension] * value : -value;\n    } else if (isPercentage(value)) {\n      delta = nodeBBox[dimension] * parseFloat(value) / 100;\n    } else {\n      delta = 0;\n    }\n\n    var point = Point();\n    point[axis] = -(nodeBBox[axis] + delta);\n    return point;\n  };\n}\n\nfunction shapeWrapper(shapeConstructor, opt) {\n  var cacheName = 'joint-shape';\n  var resetOffset = opt && opt.resetOffset;\n  return function (value, refBBox, node) {\n    var $node = $(node);\n    var cache = $node.data(cacheName);\n\n    if (!cache || cache.value !== value) {\n      // only recalculate if value has changed\n      var cachedShape = shapeConstructor(value);\n      cache = {\n        value: value,\n        shape: cachedShape,\n        shapeBBox: cachedShape.bbox()\n      };\n      $node.data(cacheName, cache);\n    }\n\n    var shape = cache.shape.clone();\n    var shapeBBox = cache.shapeBBox.clone();\n    var shapeOrigin = shapeBBox.origin();\n    var refOrigin = refBBox.origin();\n    shapeBBox.x = refOrigin.x;\n    shapeBBox.y = refOrigin.y;\n    var fitScale = refBBox.maxRectScaleToFit(shapeBBox, refOrigin); // `maxRectScaleToFit` can give Infinity if width or height is 0\n\n    var sx = shapeBBox.width === 0 || refBBox.width === 0 ? 1 : fitScale.sx;\n    var sy = shapeBBox.height === 0 || refBBox.height === 0 ? 1 : fitScale.sy;\n    shape.scale(sx, sy, shapeOrigin);\n\n    if (resetOffset) {\n      shape.translate(-shapeOrigin.x, -shapeOrigin.y);\n    }\n\n    return shape;\n  };\n} // `d` attribute for SVGPaths\n\n\nfunction dWrapper(opt) {\n  function pathConstructor(value) {\n    return new Path(V.normalizePathData(value));\n  }\n\n  var shape = shapeWrapper(pathConstructor, opt);\n  return function (value, refBBox, node) {\n    var path = shape(value, refBBox, node);\n    return {\n      d: path.serialize()\n    };\n  };\n} // `points` attribute for SVGPolylines and SVGPolygons\n\n\nfunction pointsWrapper(opt) {\n  var shape = shapeWrapper(Polyline, opt);\n  return function (value, refBBox, node) {\n    var polyline = shape(value, refBBox, node);\n    return {\n      points: polyline.serialize()\n    };\n  };\n}\n\nfunction atConnectionWrapper(method, opt) {\n  var zeroVector = new Point(1, 0);\n  return function (value) {\n    var p, angle;\n    var tangent = this[method](value);\n\n    if (tangent) {\n      angle = opt.rotate ? tangent.vector().vectorAngle(zeroVector) : 0;\n      p = tangent.start;\n    } else {\n      p = this.path.start;\n      angle = 0;\n    }\n\n    if (angle === 0) return {\n      transform: 'translate(' + p.x + ',' + p.y + ')'\n    };\n    return {\n      transform: 'translate(' + p.x + ',' + p.y + ') rotate(' + angle + ')'\n    };\n  };\n}\n\nfunction setIfChangedWrapper(attribute) {\n  return function setIfChanged(value, _, node) {\n    const vel = V(node);\n    if (vel.attr(attribute) === value) return;\n    vel.attr(attribute, value);\n  };\n}\n\nfunction isTextInUse(_value, _node, attrs) {\n  return attrs.text !== undefined;\n}\n\nfunction isLinkView() {\n  return this.model.isLink();\n}\n\nfunction contextMarker(context) {\n  var marker = {}; // Stroke\n  // The context 'fill' is disregared here. The usual case is to use the marker with a connection\n  // (for which 'fill' attribute is set to 'none').\n\n  var stroke = context.stroke;\n\n  if (typeof stroke === 'string') {\n    marker['stroke'] = stroke;\n    marker['fill'] = stroke;\n  } // Opacity\n  // Again the context 'fill-opacity' is ignored.\n\n\n  var strokeOpacity = context.strokeOpacity;\n  if (strokeOpacity === undefined) strokeOpacity = context['stroke-opacity'];\n  if (strokeOpacity === undefined) strokeOpacity = context.opacity;\n\n  if (strokeOpacity !== undefined) {\n    marker['stroke-opacity'] = strokeOpacity;\n    marker['fill-opacity'] = strokeOpacity;\n  }\n\n  return marker;\n}\n\nfunction setPaintURL(def) {\n  const {\n    paper\n  } = this;\n  const url = def.type === 'pattern' ? paper.definePattern(def) : paper.defineGradient(def);\n  return `url(#${url})`;\n}\n\nconst attributesNS = {\n  xlinkShow: {\n    set: 'xlink:show'\n  },\n  xlinkRole: {\n    set: 'xlink:role'\n  },\n  xlinkType: {\n    set: 'xlink:type'\n  },\n  xlinkArcrole: {\n    set: 'xlink:arcrole'\n  },\n  xlinkTitle: {\n    set: 'xlink:title'\n  },\n  xlinkActuate: {\n    set: 'xlink:actuate'\n  },\n  xmlSpace: {\n    set: 'xml:space'\n  },\n  xmlBase: {\n    set: 'xml:base'\n  },\n  xmlLang: {\n    set: 'xml:lang'\n  },\n  preserveAspectRatio: {\n    set: 'preserveAspectRatio'\n  },\n  requiredExtension: {\n    set: 'requiredExtension'\n  },\n  requiredFeatures: {\n    set: 'requiredFeatures'\n  },\n  systemLanguage: {\n    set: 'systemLanguage'\n  },\n  externalResourcesRequired: {\n    set: 'externalResourceRequired'\n  },\n  href: {\n    set: setIfChangedWrapper('href')\n  },\n  xlinkHref: {\n    set: setIfChangedWrapper('xlink:href')\n  },\n  filter: {\n    qualify: isPlainObject,\n    set: function (filter) {\n      return 'url(#' + this.paper.defineFilter(filter) + ')';\n    }\n  },\n  fill: {\n    qualify: isPlainObject,\n    set: setPaintURL\n  },\n  stroke: {\n    qualify: isPlainObject,\n    set: setPaintURL\n  },\n  sourceMarker: {\n    qualify: isPlainObject,\n    set: function (marker, refBBox, node, attrs) {\n      marker = assign(contextMarker(attrs), marker);\n      return {\n        'marker-start': 'url(#' + this.paper.defineMarker(marker) + ')'\n      };\n    }\n  },\n  targetMarker: {\n    qualify: isPlainObject,\n    set: function (marker, refBBox, node, attrs) {\n      marker = assign(contextMarker(attrs), {\n        'transform': 'rotate(180)'\n      }, marker);\n      return {\n        'marker-end': 'url(#' + this.paper.defineMarker(marker) + ')'\n      };\n    }\n  },\n  vertexMarker: {\n    qualify: isPlainObject,\n    set: function (marker, refBBox, node, attrs) {\n      marker = assign(contextMarker(attrs), marker);\n      return {\n        'marker-mid': 'url(#' + this.paper.defineMarker(marker) + ')'\n      };\n    }\n  },\n  text: {\n    qualify: function (_text, _node, attrs) {\n      return !attrs.textWrap || !isPlainObject(attrs.textWrap);\n    },\n    set: function (text, refBBox, node, attrs) {\n      var $node = $(node);\n      var cacheName = 'joint-text';\n      var cache = $node.data(cacheName);\n      var textAttrs = pick(attrs, 'lineHeight', 'annotations', 'textPath', 'x', 'textVerticalAnchor', 'eol', 'displayEmpty'); // eval `x` if using calc()\n\n      const {\n        x\n      } = textAttrs;\n\n      if (isCalcAttribute(x)) {\n        textAttrs.x = evalCalcAttribute(x, refBBox);\n      }\n\n      var fontSize = textAttrs.fontSize = attrs['font-size'] || attrs['fontSize'];\n      var textHash = JSON.stringify([text, textAttrs]); // Update the text only if there was a change in the string\n      // or any of its attributes.\n\n      if (cache === undefined || cache !== textHash) {\n        // Chrome bug:\n        // Tspans positions defined as `em` are not updated\n        // when container `font-size` change.\n        if (fontSize) node.setAttribute('font-size', fontSize); // Text Along Path Selector\n\n        var textPath = textAttrs.textPath;\n\n        if (isObject(textPath)) {\n          var pathSelector = textPath.selector;\n\n          if (typeof pathSelector === 'string') {\n            var pathNode = this.findBySelector(pathSelector)[0];\n\n            if (pathNode instanceof SVGPathElement) {\n              textAttrs.textPath = assign({\n                'xlink:href': '#' + pathNode.id\n              }, textPath);\n            }\n          }\n        }\n\n        V(node).text('' + text, textAttrs);\n        $node.data(cacheName, textHash);\n      }\n    }\n  },\n  textWrap: {\n    qualify: isPlainObject,\n    set: function (value, refBBox, node, attrs) {\n      // option `width`\n      var width = value.width || 0;\n      var size = {};\n\n      if (isPercentage(width)) {\n        size.width = refBBox.width * parseFloat(width) / 100;\n      } else if (width <= 0) {\n        size.width = refBBox.width + width;\n      } else {\n        size.width = width;\n      } // option `height`\n\n\n      var height = value.height || 0;\n\n      if (isPercentage(height)) {\n        size.height = refBBox.height * parseFloat(height) / 100;\n      } else if (height <= 0) {\n        size.height = refBBox.height + height;\n      } else {\n        size.height = height;\n      } // option `text`\n\n\n      var wrappedText;\n      var text = value.text;\n      if (text === undefined) text = attrs.text;\n\n      if (text !== undefined) {\n        wrappedText = breakText('' + text, size, {\n          'font-weight': attrs['font-weight'] || attrs.fontWeight,\n          'font-size': attrs['font-size'] || attrs.fontSize,\n          'font-family': attrs['font-family'] || attrs.fontFamily,\n          'lineHeight': attrs.lineHeight,\n          'letter-spacing': 'letter-spacing' in attrs ? attrs['letter-spacing'] : attrs.letterSpacing\n        }, {\n          // Provide an existing SVG Document here\n          // instead of creating a temporary one over again.\n          svgDocument: this.paper.svg,\n          ellipsis: value.ellipsis,\n          hyphen: value.hyphen,\n          maxLineCount: value.maxLineCount\n        });\n      } else {\n        wrappedText = '';\n      }\n\n      attributesNS.text.set.call(this, wrappedText, refBBox, node, attrs);\n    }\n  },\n  title: {\n    qualify: function (title, node) {\n      // HTMLElement title is specified via an attribute (i.e. not an element)\n      return node instanceof SVGElement;\n    },\n    set: function (title, refBBox, node) {\n      var $node = $(node);\n      var cacheName = 'joint-title';\n      var cache = $node.data(cacheName);\n\n      if (cache === undefined || cache !== title) {\n        $node.data(cacheName, title); // Generally <title> element should be the first child element of its parent.\n\n        var firstChild = node.firstChild;\n\n        if (firstChild && firstChild.tagName.toUpperCase() === 'TITLE') {\n          // Update an existing title\n          firstChild.textContent = title;\n        } else {\n          // Create a new title\n          var titleNode = document.createElementNS(node.namespaceURI, 'title');\n          titleNode.textContent = title;\n          node.insertBefore(titleNode, firstChild);\n        }\n      }\n    }\n  },\n  lineHeight: {\n    qualify: isTextInUse\n  },\n  textVerticalAnchor: {\n    qualify: isTextInUse\n  },\n  textPath: {\n    qualify: isTextInUse\n  },\n  annotations: {\n    qualify: isTextInUse\n  },\n  eol: {\n    qualify: isTextInUse\n  },\n  displayEmpty: {\n    qualify: isTextInUse\n  },\n  // `port` attribute contains the `id` of the port that the underlying magnet represents.\n  port: {\n    set: function (port) {\n      return port === null || port.id === undefined ? port : port.id;\n    }\n  },\n  // `style` attribute is special in the sense that it sets the CSS style of the subelement.\n  style: {\n    qualify: isPlainObject,\n    set: function (styles, refBBox, node) {\n      $(node).css(styles);\n    }\n  },\n  html: {\n    set: function (html, refBBox, node) {\n      $(node).html(html + '');\n    }\n  },\n  ref: {// We do not set `ref` attribute directly on an element.\n    // The attribute itself does not qualify for relative positioning.\n  },\n  // if `refX` is in [0, 1] then `refX` is a fraction of bounding box width\n  // if `refX` is < 0 then `refX`'s absolute values is the right coordinate of the bounding box\n  // otherwise, `refX` is the left coordinate of the bounding box\n  refX: {\n    position: positionWrapper('x', 'width', 'origin')\n  },\n  refY: {\n    position: positionWrapper('y', 'height', 'origin')\n  },\n  // `ref-dx` and `ref-dy` define the offset of the subelement relative to the right and/or bottom\n  // coordinate of the reference element.\n  refDx: {\n    position: positionWrapper('x', 'width', 'corner')\n  },\n  refDy: {\n    position: positionWrapper('y', 'height', 'corner')\n  },\n  // 'ref-width'/'ref-height' defines the width/height of the subelement relatively to\n  // the reference element size\n  // val in 0..1         ref-width = 0.75 sets the width to 75% of the ref. el. width\n  // val < 0 || val > 1  ref-height = -20 sets the height to the ref. el. height shorter by 20\n  refWidth: {\n    set: setWrapper('width', 'width')\n  },\n  refHeight: {\n    set: setWrapper('height', 'height')\n  },\n  refRx: {\n    set: setWrapper('rx', 'width')\n  },\n  refRy: {\n    set: setWrapper('ry', 'height')\n  },\n  refRInscribed: {\n    set: function (attrName) {\n      var widthFn = setWrapper(attrName, 'width');\n      var heightFn = setWrapper(attrName, 'height');\n      return function (value, refBBox) {\n        var fn = refBBox.height > refBBox.width ? widthFn : heightFn;\n        return fn(value, refBBox);\n      };\n    }('r')\n  },\n  refRCircumscribed: {\n    set: function (value, refBBox) {\n      var isValuePercentage = isPercentage(value);\n      value = parseFloat(value);\n\n      if (isValuePercentage) {\n        value /= 100;\n      }\n\n      var diagonalLength = Math.sqrt(refBBox.height * refBBox.height + refBBox.width * refBBox.width);\n      var rValue;\n\n      if (isFinite(value)) {\n        if (isValuePercentage || value >= 0 && value <= 1) rValue = value * diagonalLength;else rValue = Math.max(value + diagonalLength, 0);\n      }\n\n      return {\n        r: rValue\n      };\n    }\n  },\n  refCx: {\n    set: setWrapper('cx', 'width')\n  },\n  refCy: {\n    set: setWrapper('cy', 'height')\n  },\n  // `x-alignment` when set to `middle` causes centering of the subelement around its new x coordinate.\n  // `x-alignment` when set to `right` uses the x coordinate as referenced to the right of the bbox.\n  xAlignment: {\n    offset: offsetWrapper('x', 'width', 'right')\n  },\n  // `y-alignment` when set to `middle` causes centering of the subelement around its new y coordinate.\n  // `y-alignment` when set to `bottom` uses the y coordinate as referenced to the bottom of the bbox.\n  yAlignment: {\n    offset: offsetWrapper('y', 'height', 'bottom')\n  },\n  resetOffset: {\n    offset: function (val, nodeBBox) {\n      return val ? {\n        x: -nodeBBox.x,\n        y: -nodeBBox.y\n      } : {\n        x: 0,\n        y: 0\n      };\n    }\n  },\n  refDResetOffset: {\n    set: dWrapper({\n      resetOffset: true\n    })\n  },\n  refDKeepOffset: {\n    set: dWrapper({\n      resetOffset: false\n    })\n  },\n  refPointsResetOffset: {\n    set: pointsWrapper({\n      resetOffset: true\n    })\n  },\n  refPointsKeepOffset: {\n    set: pointsWrapper({\n      resetOffset: false\n    })\n  },\n  // LinkView Attributes\n  connection: {\n    qualify: isLinkView,\n    set: function ({\n      stubs = 0\n    }) {\n      let d;\n\n      if (isFinite(stubs) && stubs !== 0) {\n        let offset;\n\n        if (stubs < 0) {\n          offset = (this.getConnectionLength() + stubs) / 2;\n        } else {\n          offset = stubs;\n        }\n\n        const path = this.getConnection();\n        const sourceParts = path.divideAtLength(offset);\n        const targetParts = path.divideAtLength(-offset);\n\n        if (sourceParts && targetParts) {\n          d = `${sourceParts[0].serialize()} ${targetParts[1].serialize()}`;\n        }\n      }\n\n      return {\n        d: d || this.getSerializedConnection()\n      };\n    }\n  },\n  atConnectionLengthKeepGradient: {\n    qualify: isLinkView,\n    set: atConnectionWrapper('getTangentAtLength', {\n      rotate: true\n    })\n  },\n  atConnectionLengthIgnoreGradient: {\n    qualify: isLinkView,\n    set: atConnectionWrapper('getTangentAtLength', {\n      rotate: false\n    })\n  },\n  atConnectionRatioKeepGradient: {\n    qualify: isLinkView,\n    set: atConnectionWrapper('getTangentAtRatio', {\n      rotate: true\n    })\n  },\n  atConnectionRatioIgnoreGradient: {\n    qualify: isLinkView,\n    set: atConnectionWrapper('getTangentAtRatio', {\n      rotate: false\n    })\n  }\n};\nattributesNS['xlink:href'] = attributesNS.xlinkHref; // Support `calc()` with the following SVG attributes\n\n['transform', // g\n'd', // path\n'points', // polyline / polygon\n'width', 'height', // rect / image\n'cx', 'cy', // circle / ellipse\n'r', // circle\n'rx', 'ry', // rect / ellipse\n'x1', 'x2', 'y1', 'y2', // line\n'x', 'y', // rect / text / image\n'dx', 'dy' // text\n].forEach(attribute => {\n  attributesNS[attribute] = {\n    qualify: isCalcAttribute,\n    set: function setCalcAttribute(value, refBBox) {\n      return {\n        [attribute]: evalCalcAttribute(value, refBBox)\n      };\n    }\n  };\n}); // Aliases\n\nattributesNS.refR = attributesNS.refRInscribed;\nattributesNS.refD = attributesNS.refDResetOffset;\nattributesNS.refPoints = attributesNS.refPointsResetOffset;\nattributesNS.atConnectionLength = attributesNS.atConnectionLengthKeepGradient;\nattributesNS.atConnectionRatio = attributesNS.atConnectionRatioKeepGradient; // This allows to combine both absolute and relative positioning\n// refX: 50%, refX2: 20\n\nattributesNS.refX2 = attributesNS.refX;\nattributesNS.refY2 = attributesNS.refY;\nattributesNS.refWidth2 = attributesNS.refWidth;\nattributesNS.refHeight2 = attributesNS.refHeight; // Aliases for backwards compatibility\n\nattributesNS['ref-x'] = attributesNS.refX;\nattributesNS['ref-y'] = attributesNS.refY;\nattributesNS['ref-dy'] = attributesNS.refDy;\nattributesNS['ref-dx'] = attributesNS.refDx;\nattributesNS['ref-width'] = attributesNS.refWidth;\nattributesNS['ref-height'] = attributesNS.refHeight;\nattributesNS['x-alignment'] = attributesNS.xAlignment;\nattributesNS['y-alignment'] = attributesNS.yAlignment;\nexport const attributes = attributesNS;","map":{"version":3,"names":["Point","Path","Polyline","assign","isPlainObject","pick","isObject","isPercentage","breakText","isCalcAttribute","evalCalcAttribute","$","V","setWrapper","attrName","dimension","value","refBBox","isValuePercentage","parseFloat","attrs","isFinite","attrValue","Math","max","positionWrapper","axis","origin","valuePercentage","delta","refOrigin","point","offsetWrapper","corner","nodeBBox","shapeWrapper","shapeConstructor","opt","cacheName","resetOffset","node","$node","cache","data","cachedShape","shape","shapeBBox","bbox","clone","shapeOrigin","x","y","fitScale","maxRectScaleToFit","sx","width","sy","height","scale","translate","dWrapper","pathConstructor","normalizePathData","path","d","serialize","pointsWrapper","polyline","points","atConnectionWrapper","method","zeroVector","p","angle","tangent","rotate","vector","vectorAngle","start","transform","setIfChangedWrapper","attribute","setIfChanged","_","vel","attr","isTextInUse","_value","_node","text","undefined","isLinkView","model","isLink","contextMarker","context","marker","stroke","strokeOpacity","opacity","setPaintURL","def","paper","url","type","definePattern","defineGradient","attributesNS","xlinkShow","set","xlinkRole","xlinkType","xlinkArcrole","xlinkTitle","xlinkActuate","xmlSpace","xmlBase","xmlLang","preserveAspectRatio","requiredExtension","requiredFeatures","systemLanguage","externalResourcesRequired","href","xlinkHref","filter","qualify","defineFilter","fill","sourceMarker","defineMarker","targetMarker","vertexMarker","_text","textWrap","textAttrs","fontSize","textHash","JSON","stringify","setAttribute","textPath","pathSelector","selector","pathNode","findBySelector","SVGPathElement","id","size","wrappedText","fontWeight","fontFamily","lineHeight","letterSpacing","svgDocument","svg","ellipsis","hyphen","maxLineCount","call","title","SVGElement","firstChild","tagName","toUpperCase","textContent","titleNode","document","createElementNS","namespaceURI","insertBefore","textVerticalAnchor","annotations","eol","displayEmpty","port","style","styles","css","html","ref","refX","position","refY","refDx","refDy","refWidth","refHeight","refRx","refRy","refRInscribed","widthFn","heightFn","fn","refRCircumscribed","diagonalLength","sqrt","rValue","r","refCx","refCy","xAlignment","offset","yAlignment","val","refDResetOffset","refDKeepOffset","refPointsResetOffset","refPointsKeepOffset","connection","stubs","getConnectionLength","getConnection","sourceParts","divideAtLength","targetParts","getSerializedConnection","atConnectionLengthKeepGradient","atConnectionLengthIgnoreGradient","atConnectionRatioKeepGradient","atConnectionRatioIgnoreGradient","forEach","setCalcAttribute","refR","refD","refPoints","atConnectionLength","atConnectionRatio","refX2","refY2","refWidth2","refHeight2","attributes"],"sources":["C:/Users/Admin/dataflow-test/node_modules/jointjs/src/dia/attributes/index.mjs"],"sourcesContent":["import { Point, Path, Polyline } from '../../g/index.mjs';\nimport { assign, isPlainObject, pick, isObject, isPercentage, breakText } from '../../util/util.mjs';\nimport { isCalcAttribute, evalCalcAttribute } from './calc.mjs';\nimport $ from 'jquery';\nimport V from '../../V/index.mjs';\n\nfunction setWrapper(attrName, dimension) {\n    return function(value, refBBox) {\n        var isValuePercentage = isPercentage(value);\n        value = parseFloat(value);\n        if (isValuePercentage) {\n            value /= 100;\n        }\n\n        var attrs = {};\n        if (isFinite(value)) {\n            var attrValue = (isValuePercentage || value >= 0 && value <= 1)\n                ? value * refBBox[dimension]\n                : Math.max(value + refBBox[dimension], 0);\n            attrs[attrName] = attrValue;\n        }\n\n        return attrs;\n    };\n}\n\nfunction positionWrapper(axis, dimension, origin) {\n    return function(value, refBBox) {\n        var valuePercentage = isPercentage(value);\n        value = parseFloat(value);\n        if (valuePercentage) {\n            value /= 100;\n        }\n\n        var delta;\n        if (isFinite(value)) {\n            var refOrigin = refBBox[origin]();\n            if (valuePercentage || value > 0 && value < 1) {\n                delta = refOrigin[axis] + refBBox[dimension] * value;\n            } else {\n                delta = refOrigin[axis] + value;\n            }\n        }\n\n        var point = Point();\n        point[axis] = delta || 0;\n        return point;\n    };\n}\n\nfunction offsetWrapper(axis, dimension, corner) {\n    return function(value, nodeBBox) {\n        var delta;\n        if (value === 'middle') {\n            delta = nodeBBox[dimension] / 2;\n        } else if (value === corner) {\n            delta = nodeBBox[dimension];\n        } else if (isFinite(value)) {\n            // TODO: or not to do a breaking change?\n            delta = (value > -1 && value < 1) ? (-nodeBBox[dimension] * value) : -value;\n        } else if (isPercentage(value)) {\n            delta = nodeBBox[dimension] * parseFloat(value) / 100;\n        } else {\n            delta = 0;\n        }\n\n        var point = Point();\n        point[axis] = -(nodeBBox[axis] + delta);\n        return point;\n    };\n}\n\nfunction shapeWrapper(shapeConstructor, opt) {\n    var cacheName = 'joint-shape';\n    var resetOffset = opt && opt.resetOffset;\n    return function(value, refBBox, node) {\n        var $node = $(node);\n        var cache = $node.data(cacheName);\n        if (!cache || cache.value !== value) {\n            // only recalculate if value has changed\n            var cachedShape = shapeConstructor(value);\n            cache = {\n                value: value,\n                shape: cachedShape,\n                shapeBBox: cachedShape.bbox()\n            };\n            $node.data(cacheName, cache);\n        }\n\n        var shape = cache.shape.clone();\n        var shapeBBox = cache.shapeBBox.clone();\n        var shapeOrigin = shapeBBox.origin();\n        var refOrigin = refBBox.origin();\n\n        shapeBBox.x = refOrigin.x;\n        shapeBBox.y = refOrigin.y;\n\n        var fitScale = refBBox.maxRectScaleToFit(shapeBBox, refOrigin);\n        // `maxRectScaleToFit` can give Infinity if width or height is 0\n        var sx = (shapeBBox.width === 0 || refBBox.width === 0) ? 1 : fitScale.sx;\n        var sy = (shapeBBox.height === 0 || refBBox.height === 0) ? 1 : fitScale.sy;\n\n        shape.scale(sx, sy, shapeOrigin);\n        if (resetOffset) {\n            shape.translate(-shapeOrigin.x, -shapeOrigin.y);\n        }\n\n        return shape;\n    };\n}\n\n// `d` attribute for SVGPaths\nfunction dWrapper(opt) {\n    function pathConstructor(value) {\n        return new Path(V.normalizePathData(value));\n    }\n\n    var shape = shapeWrapper(pathConstructor, opt);\n    return function(value, refBBox, node) {\n        var path = shape(value, refBBox, node);\n        return {\n            d: path.serialize()\n        };\n    };\n}\n\n// `points` attribute for SVGPolylines and SVGPolygons\nfunction pointsWrapper(opt) {\n    var shape = shapeWrapper(Polyline, opt);\n    return function(value, refBBox, node) {\n        var polyline = shape(value, refBBox, node);\n        return {\n            points: polyline.serialize()\n        };\n    };\n}\n\nfunction atConnectionWrapper(method, opt) {\n    var zeroVector = new Point(1, 0);\n    return function(value) {\n        var p, angle;\n        var tangent = this[method](value);\n        if (tangent) {\n            angle = (opt.rotate) ? tangent.vector().vectorAngle(zeroVector) : 0;\n            p = tangent.start;\n        } else {\n            p = this.path.start;\n            angle = 0;\n        }\n        if (angle === 0) return { transform: 'translate(' + p.x + ',' + p.y + ')' };\n        return { transform: 'translate(' + p.x + ',' + p.y + ') rotate(' + angle + ')' };\n    };\n}\n\nfunction setIfChangedWrapper(attribute) {\n    return function setIfChanged(value, _, node) {\n        const vel = V(node);\n        if (vel.attr(attribute) === value) return;\n        vel.attr(attribute, value);\n    };\n}\n\nfunction isTextInUse(_value, _node, attrs) {\n    return (attrs.text !== undefined);\n}\n\nfunction isLinkView() {\n    return this.model.isLink();\n}\n\nfunction contextMarker(context) {\n    var marker = {};\n    // Stroke\n    // The context 'fill' is disregared here. The usual case is to use the marker with a connection\n    // (for which 'fill' attribute is set to 'none').\n    var stroke = context.stroke;\n    if (typeof stroke === 'string') {\n        marker['stroke'] = stroke;\n        marker['fill'] = stroke;\n    }\n    // Opacity\n    // Again the context 'fill-opacity' is ignored.\n    var strokeOpacity = context.strokeOpacity;\n    if (strokeOpacity === undefined) strokeOpacity = context['stroke-opacity'];\n    if (strokeOpacity === undefined) strokeOpacity = context.opacity;\n    if (strokeOpacity !== undefined) {\n        marker['stroke-opacity'] = strokeOpacity;\n        marker['fill-opacity'] = strokeOpacity;\n    }\n    return marker;\n}\n\nfunction setPaintURL(def) {\n    const { paper } = this;\n    const url = (def.type === 'pattern')\n        ? paper.definePattern(def)\n        : paper.defineGradient(def);\n    return `url(#${url})`;\n}\n\nconst attributesNS = {\n\n    xlinkShow: {\n        set: 'xlink:show'\n    },\n\n    xlinkRole: {\n        set: 'xlink:role'\n    },\n\n    xlinkType: {\n        set: 'xlink:type'\n    },\n\n    xlinkArcrole: {\n        set: 'xlink:arcrole'\n    },\n\n    xlinkTitle: {\n        set: 'xlink:title'\n    },\n\n    xlinkActuate: {\n        set: 'xlink:actuate'\n    },\n\n    xmlSpace: {\n        set: 'xml:space'\n    },\n\n    xmlBase: {\n        set: 'xml:base'\n    },\n\n    xmlLang: {\n        set: 'xml:lang'\n    },\n\n    preserveAspectRatio: {\n        set: 'preserveAspectRatio'\n    },\n\n    requiredExtension: {\n        set: 'requiredExtension'\n    },\n\n    requiredFeatures: {\n        set: 'requiredFeatures'\n    },\n\n    systemLanguage: {\n        set: 'systemLanguage'\n    },\n\n    externalResourcesRequired: {\n        set: 'externalResourceRequired'\n    },\n\n    href: {\n        set: setIfChangedWrapper('href')\n    },\n\n    xlinkHref: {\n        set: setIfChangedWrapper('xlink:href')\n    },\n\n    filter: {\n        qualify: isPlainObject,\n        set: function(filter) {\n            return 'url(#' + this.paper.defineFilter(filter) + ')';\n        }\n    },\n\n    fill: {\n        qualify: isPlainObject,\n        set: setPaintURL\n    },\n\n    stroke: {\n        qualify: isPlainObject,\n        set: setPaintURL\n    },\n\n    sourceMarker: {\n        qualify: isPlainObject,\n        set: function(marker, refBBox, node, attrs) {\n            marker = assign(contextMarker(attrs), marker);\n            return { 'marker-start': 'url(#' + this.paper.defineMarker(marker) + ')' };\n        }\n    },\n\n    targetMarker: {\n        qualify: isPlainObject,\n        set: function(marker, refBBox, node, attrs) {\n            marker = assign(contextMarker(attrs), { 'transform': 'rotate(180)' }, marker);\n            return { 'marker-end': 'url(#' + this.paper.defineMarker(marker) + ')' };\n        }\n    },\n\n    vertexMarker: {\n        qualify: isPlainObject,\n        set: function(marker, refBBox, node, attrs) {\n            marker = assign(contextMarker(attrs), marker);\n            return { 'marker-mid': 'url(#' + this.paper.defineMarker(marker) + ')' };\n        }\n    },\n\n    text: {\n        qualify: function(_text, _node, attrs) {\n            return !attrs.textWrap || !isPlainObject(attrs.textWrap);\n        },\n        set: function(text, refBBox, node, attrs) {\n            var $node = $(node);\n            var cacheName = 'joint-text';\n            var cache = $node.data(cacheName);\n            var textAttrs = pick(attrs, 'lineHeight', 'annotations', 'textPath', 'x', 'textVerticalAnchor', 'eol', 'displayEmpty');\n            // eval `x` if using calc()\n            const { x } = textAttrs;\n            if (isCalcAttribute(x)) {\n                textAttrs.x = evalCalcAttribute(x, refBBox);\n            }\n            var fontSize = textAttrs.fontSize = attrs['font-size'] || attrs['fontSize'];\n            var textHash = JSON.stringify([text, textAttrs]);\n            // Update the text only if there was a change in the string\n            // or any of its attributes.\n            if (cache === undefined || cache !== textHash) {\n                // Chrome bug:\n                // Tspans positions defined as `em` are not updated\n                // when container `font-size` change.\n                if (fontSize) node.setAttribute('font-size', fontSize);\n                // Text Along Path Selector\n                var textPath = textAttrs.textPath;\n                if (isObject(textPath)) {\n                    var pathSelector = textPath.selector;\n                    if (typeof pathSelector === 'string') {\n                        var pathNode = this.findBySelector(pathSelector)[0];\n                        if (pathNode instanceof SVGPathElement) {\n                            textAttrs.textPath = assign({ 'xlink:href': '#' + pathNode.id }, textPath);\n                        }\n                    }\n                }\n                V(node).text('' + text, textAttrs);\n                $node.data(cacheName, textHash);\n            }\n        }\n    },\n\n    textWrap: {\n        qualify: isPlainObject,\n        set: function(value, refBBox, node, attrs) {\n            // option `width`\n            var width = value.width || 0;\n            var size = {};\n            if (isPercentage(width)) {\n                size.width = refBBox.width * parseFloat(width) / 100;\n            } else if (width <= 0) {\n                size.width = refBBox.width + width;\n            } else {\n                size.width = width;\n            }\n            // option `height`\n            var height = value.height || 0;\n            if (isPercentage(height)) {\n                size.height = refBBox.height * parseFloat(height) / 100;\n            } else if (height <= 0) {\n                size.height = refBBox.height + height;\n            } else {\n                size.height = height;\n            }\n            // option `text`\n            var wrappedText;\n            var text = value.text;\n            if (text === undefined) text = attrs.text;\n            if (text !== undefined) {\n                wrappedText = breakText('' + text, size, {\n                    'font-weight': attrs['font-weight'] || attrs.fontWeight,\n                    'font-size': attrs['font-size'] || attrs.fontSize,\n                    'font-family': attrs['font-family'] || attrs.fontFamily,\n                    'lineHeight': attrs.lineHeight,\n                    'letter-spacing': 'letter-spacing' in attrs ? attrs['letter-spacing'] : attrs.letterSpacing\n                }, {\n                    // Provide an existing SVG Document here\n                    // instead of creating a temporary one over again.\n                    svgDocument: this.paper.svg,\n                    ellipsis: value.ellipsis,\n                    hyphen: value.hyphen,\n                    maxLineCount: value.maxLineCount\n                });\n            } else {\n                wrappedText = '';\n            }\n            attributesNS.text.set.call(this, wrappedText, refBBox, node, attrs);\n        }\n    },\n\n    title: {\n        qualify: function(title, node) {\n            // HTMLElement title is specified via an attribute (i.e. not an element)\n            return node instanceof SVGElement;\n        },\n        set: function(title, refBBox, node) {\n            var $node = $(node);\n            var cacheName = 'joint-title';\n            var cache = $node.data(cacheName);\n            if (cache === undefined || cache !== title) {\n                $node.data(cacheName, title);\n                // Generally <title> element should be the first child element of its parent.\n                var firstChild = node.firstChild;\n                if (firstChild && firstChild.tagName.toUpperCase() === 'TITLE') {\n                    // Update an existing title\n                    firstChild.textContent = title;\n                } else {\n                    // Create a new title\n                    var titleNode = document.createElementNS(node.namespaceURI, 'title');\n                    titleNode.textContent = title;\n                    node.insertBefore(titleNode, firstChild);\n                }\n            }\n        }\n    },\n\n    lineHeight: {\n        qualify: isTextInUse\n    },\n\n    textVerticalAnchor: {\n        qualify: isTextInUse\n    },\n\n    textPath: {\n        qualify: isTextInUse\n    },\n\n    annotations: {\n        qualify: isTextInUse\n    },\n\n    eol: {\n        qualify: isTextInUse\n    },\n\n    displayEmpty: {\n        qualify: isTextInUse\n    },\n\n    // `port` attribute contains the `id` of the port that the underlying magnet represents.\n    port: {\n        set: function(port) {\n            return (port === null || port.id === undefined) ? port : port.id;\n        }\n    },\n\n    // `style` attribute is special in the sense that it sets the CSS style of the subelement.\n    style: {\n        qualify: isPlainObject,\n        set: function(styles, refBBox, node) {\n            $(node).css(styles);\n        }\n    },\n\n    html: {\n        set: function(html, refBBox, node) {\n            $(node).html(html + '');\n        }\n    },\n\n    ref: {\n        // We do not set `ref` attribute directly on an element.\n        // The attribute itself does not qualify for relative positioning.\n    },\n\n    // if `refX` is in [0, 1] then `refX` is a fraction of bounding box width\n    // if `refX` is < 0 then `refX`'s absolute values is the right coordinate of the bounding box\n    // otherwise, `refX` is the left coordinate of the bounding box\n\n    refX: {\n        position: positionWrapper('x', 'width', 'origin')\n    },\n\n    refY: {\n        position: positionWrapper('y', 'height', 'origin')\n    },\n\n    // `ref-dx` and `ref-dy` define the offset of the subelement relative to the right and/or bottom\n    // coordinate of the reference element.\n\n    refDx: {\n        position: positionWrapper('x', 'width', 'corner')\n    },\n\n    refDy: {\n        position: positionWrapper('y', 'height', 'corner')\n    },\n\n    // 'ref-width'/'ref-height' defines the width/height of the subelement relatively to\n    // the reference element size\n    // val in 0..1         ref-width = 0.75 sets the width to 75% of the ref. el. width\n    // val < 0 || val > 1  ref-height = -20 sets the height to the ref. el. height shorter by 20\n\n    refWidth: {\n        set: setWrapper('width', 'width')\n    },\n\n    refHeight: {\n        set: setWrapper('height', 'height')\n    },\n\n    refRx: {\n        set: setWrapper('rx', 'width')\n    },\n\n    refRy: {\n        set: setWrapper('ry', 'height')\n    },\n\n    refRInscribed: {\n        set: (function(attrName) {\n            var widthFn = setWrapper(attrName, 'width');\n            var heightFn = setWrapper(attrName, 'height');\n            return function(value, refBBox) {\n                var fn = (refBBox.height > refBBox.width) ? widthFn : heightFn;\n                return fn(value, refBBox);\n            };\n        })('r')\n    },\n\n    refRCircumscribed: {\n        set: function(value, refBBox) {\n            var isValuePercentage = isPercentage(value);\n            value = parseFloat(value);\n            if (isValuePercentage) {\n                value /= 100;\n            }\n\n            var diagonalLength = Math.sqrt((refBBox.height * refBBox.height) + (refBBox.width * refBBox.width));\n\n            var rValue;\n            if (isFinite(value)) {\n                if (isValuePercentage || value >= 0 && value <= 1) rValue = value * diagonalLength;\n                else rValue = Math.max(value + diagonalLength, 0);\n            }\n\n            return { r: rValue };\n        }\n    },\n\n    refCx: {\n        set: setWrapper('cx', 'width')\n    },\n\n    refCy: {\n        set: setWrapper('cy', 'height')\n    },\n\n    // `x-alignment` when set to `middle` causes centering of the subelement around its new x coordinate.\n    // `x-alignment` when set to `right` uses the x coordinate as referenced to the right of the bbox.\n\n    xAlignment: {\n        offset: offsetWrapper('x', 'width', 'right')\n    },\n\n    // `y-alignment` when set to `middle` causes centering of the subelement around its new y coordinate.\n    // `y-alignment` when set to `bottom` uses the y coordinate as referenced to the bottom of the bbox.\n\n    yAlignment: {\n        offset: offsetWrapper('y', 'height', 'bottom')\n    },\n\n    resetOffset: {\n        offset: function(val, nodeBBox) {\n            return (val)\n                ? { x: -nodeBBox.x, y: -nodeBBox.y }\n                : { x: 0, y: 0 };\n        }\n\n    },\n\n    refDResetOffset: {\n        set: dWrapper({ resetOffset: true })\n    },\n\n    refDKeepOffset: {\n        set: dWrapper({ resetOffset: false })\n    },\n\n    refPointsResetOffset: {\n        set: pointsWrapper({ resetOffset: true })\n    },\n\n    refPointsKeepOffset: {\n        set: pointsWrapper({ resetOffset: false })\n    },\n\n    // LinkView Attributes\n\n    connection: {\n        qualify: isLinkView,\n        set: function({ stubs = 0 }) {\n            let d;\n            if (isFinite(stubs) && stubs !== 0) {\n                let offset;\n                if (stubs < 0) {\n                    offset = (this.getConnectionLength() + stubs) / 2;\n                } else {\n                    offset = stubs;\n                }\n                const path = this.getConnection();\n                const sourceParts = path.divideAtLength(offset);\n                const targetParts = path.divideAtLength(-offset);\n                if (sourceParts && targetParts) {\n                    d = `${sourceParts[0].serialize()} ${targetParts[1].serialize()}`;\n                }\n            }\n\n            return { d: d || this.getSerializedConnection() };\n        }\n    },\n\n    atConnectionLengthKeepGradient: {\n        qualify: isLinkView,\n        set: atConnectionWrapper('getTangentAtLength', { rotate: true })\n    },\n\n    atConnectionLengthIgnoreGradient: {\n        qualify: isLinkView,\n        set: atConnectionWrapper('getTangentAtLength', { rotate: false })\n    },\n\n    atConnectionRatioKeepGradient: {\n        qualify: isLinkView,\n        set: atConnectionWrapper('getTangentAtRatio', { rotate: true })\n    },\n\n    atConnectionRatioIgnoreGradient: {\n        qualify: isLinkView,\n        set: atConnectionWrapper('getTangentAtRatio', { rotate: false })\n    }\n};\n\nattributesNS['xlink:href'] = attributesNS.xlinkHref;\n\n// Support `calc()` with the following SVG attributes\n[\n    'transform', // g\n    'd', // path\n    'points', // polyline / polygon\n    'width', 'height', // rect / image\n    'cx', 'cy', // circle / ellipse\n    'r', // circle\n    'rx', 'ry', // rect / ellipse\n    'x1', 'x2', 'y1', 'y2', // line\n    'x', 'y', // rect / text / image\n    'dx', 'dy' // text\n].forEach(attribute => {\n    attributesNS[attribute] = {\n        qualify: isCalcAttribute,\n        set: function setCalcAttribute(value, refBBox) {\n            return { [attribute]: evalCalcAttribute(value, refBBox) };\n        }\n    };\n});\n\n// Aliases\nattributesNS.refR = attributesNS.refRInscribed;\nattributesNS.refD = attributesNS.refDResetOffset;\nattributesNS.refPoints = attributesNS.refPointsResetOffset;\nattributesNS.atConnectionLength = attributesNS.atConnectionLengthKeepGradient;\nattributesNS.atConnectionRatio = attributesNS.atConnectionRatioKeepGradient;\n\n// This allows to combine both absolute and relative positioning\n// refX: 50%, refX2: 20\nattributesNS.refX2 = attributesNS.refX;\nattributesNS.refY2 = attributesNS.refY;\nattributesNS.refWidth2 = attributesNS.refWidth;\nattributesNS.refHeight2 = attributesNS.refHeight;\n\n// Aliases for backwards compatibility\nattributesNS['ref-x'] = attributesNS.refX;\nattributesNS['ref-y'] = attributesNS.refY;\nattributesNS['ref-dy'] = attributesNS.refDy;\nattributesNS['ref-dx'] = attributesNS.refDx;\nattributesNS['ref-width'] = attributesNS.refWidth;\nattributesNS['ref-height'] = attributesNS.refHeight;\nattributesNS['x-alignment'] = attributesNS.xAlignment;\nattributesNS['y-alignment'] = attributesNS.yAlignment;\n\nexport const attributes = attributesNS;\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}