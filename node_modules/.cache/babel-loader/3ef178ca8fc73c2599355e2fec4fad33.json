{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\n// Accepts path data string, array of segments, array of Curves and/or Lines, or a Polyline.\n// Path created is not guaranteed to be a valid (serializable) path (might not start with an M).\nimport { Polyline } from './polyline.mjs';\nimport { Rect } from './rect.mjs';\nimport { Point } from './point.mjs';\nimport { Line } from './line.mjs';\nimport { Curve } from './curve.mjs';\nimport { types } from './types.mjs';\nimport { extend } from './extend.mjs';\nexport const Path = function (arg) {\n  if (!(this instanceof Path)) {\n    return new Path(arg);\n  }\n\n  if (typeof arg === 'string') {\n    // create from a path data string\n    return new Path.parse(arg);\n  }\n\n  this.segments = [];\n  var i;\n  var n;\n\n  if (!arg) {// don't do anything\n  } else if (Array.isArray(arg) && arg.length !== 0) {\n    // if arg is a non-empty array\n    // flatten one level deep\n    // so we can chain arbitrary Path.createSegment results\n    arg = arg.reduce(function (acc, val) {\n      return acc.concat(val);\n    }, []);\n    n = arg.length;\n\n    if (arg[0].isSegment) {\n      // create from an array of segments\n      for (i = 0; i < n; i++) {\n        var segment = arg[i];\n        this.appendSegment(segment);\n      }\n    } else {\n      // create from an array of Curves and/or Lines\n      var previousObj = null;\n\n      for (i = 0; i < n; i++) {\n        var obj = arg[i];\n\n        if (!(obj instanceof Line || obj instanceof Curve)) {\n          throw new Error('Cannot construct a path segment from the provided object.');\n        }\n\n        if (i === 0) this.appendSegment(Path.createSegment('M', obj.start)); // if objects do not link up, moveto segments are inserted to cover the gaps\n\n        if (previousObj && !previousObj.end.equals(obj.start)) this.appendSegment(Path.createSegment('M', obj.start));\n\n        if (obj instanceof Line) {\n          this.appendSegment(Path.createSegment('L', obj.end));\n        } else if (obj instanceof Curve) {\n          this.appendSegment(Path.createSegment('C', obj.controlPoint1, obj.controlPoint2, obj.end));\n        }\n\n        previousObj = obj;\n      }\n    }\n  } else if (arg.isSegment) {\n    // create from a single segment\n    this.appendSegment(arg);\n  } else if (arg instanceof Line) {\n    // create from a single Line\n    this.appendSegment(Path.createSegment('M', arg.start));\n    this.appendSegment(Path.createSegment('L', arg.end));\n  } else if (arg instanceof Curve) {\n    // create from a single Curve\n    this.appendSegment(Path.createSegment('M', arg.start));\n    this.appendSegment(Path.createSegment('C', arg.controlPoint1, arg.controlPoint2, arg.end));\n  } else if (arg instanceof Polyline) {\n    // create from a Polyline\n    if (!(arg.points && arg.points.length !== 0)) return; // if Polyline has no points, leave Path empty\n\n    n = arg.points.length;\n\n    for (i = 0; i < n; i++) {\n      var point = arg.points[i];\n      if (i === 0) this.appendSegment(Path.createSegment('M', point));else this.appendSegment(Path.createSegment('L', point));\n    }\n  } else {\n    // unknown object\n    throw new Error('Cannot construct a path from the provided object.');\n  }\n}; // More permissive than V.normalizePathData and Path.prototype.serialize.\n// Allows path data strings that do not start with a Moveto command (unlike SVG specification).\n// Does not require spaces between elements; commas are allowed, separators may be omitted when unambiguous (e.g. 'ZM10,10', 'L1.6.8', 'M100-200').\n// Allows for command argument chaining.\n// Throws an error if wrong number of arguments is provided with a command.\n// Throws an error if an unrecognized path command is provided (according to Path.segmentTypes). Only a subset of SVG commands is currently supported (L, C, M, Z).\n\nPath.parse = function (pathData) {\n  if (!pathData) return new Path();\n  var path = new Path();\n  var commandRe = /(?:[a-zA-Z] *)(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)? *,? *)|(?:-?\\.\\d+ *,? *))+|(?:[a-zA-Z] *)(?! |\\d|-|\\.)/g;\n  var commands = pathData.match(commandRe);\n  var numCommands = commands.length;\n\n  for (var i = 0; i < numCommands; i++) {\n    var command = commands[i];\n    var argRe = /(?:[a-zA-Z])|(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)?))|(?:(?:-?\\.\\d+))/g;\n    var args = command.match(argRe);\n    var segment = Path.createSegment.apply(this, args); // args = [type, coordinate1, coordinate2...]\n\n    path.appendSegment(segment);\n  }\n\n  return path;\n}; // Create a segment or an array of segments.\n// Accepts unlimited points/coords arguments after `type`.\n\n\nPath.createSegment = function (type) {\n  if (!type) throw new Error('Type must be provided.');\n  var segmentConstructor = Path.segmentTypes[type];\n  if (!segmentConstructor) throw new Error(type + ' is not a recognized path segment type.');\n  var args = [];\n  var n = arguments.length;\n\n  for (var i = 1; i < n; i++) {\n    // do not add first element (`type`) to args array\n    args.push(arguments[i]);\n  }\n\n  return applyToNew(segmentConstructor, args);\n};\n\nPath.prototype = {\n  type: types.Path,\n  // Accepts one segment or an array of segments as argument.\n  // Throws an error if argument is not a segment or an array of segments.\n  appendSegment: function (arg) {\n    var segments = this.segments;\n    var numSegments = segments.length; // works even if path has no segments\n\n    var currentSegment;\n    var previousSegment = numSegments !== 0 ? segments[numSegments - 1] : null; // if we are appending to an empty path, previousSegment is null\n\n    var nextSegment = null;\n\n    if (!Array.isArray(arg)) {\n      // arg is a segment\n      if (!arg || !arg.isSegment) throw new Error('Segment required.');\n      currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);\n      segments.push(currentSegment);\n    } else {\n      // arg is an array of segments\n      // flatten one level deep\n      // so we can chain arbitrary Path.createSegment results\n      arg = arg.reduce(function (acc, val) {\n        return acc.concat(val);\n      }, []);\n      if (!arg[0].isSegment) throw new Error('Segments required.');\n      var n = arg.length;\n\n      for (var i = 0; i < n; i++) {\n        var currentArg = arg[i];\n        currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);\n        segments.push(currentSegment);\n        previousSegment = currentSegment;\n      }\n    }\n  },\n  // Returns the bbox of the path.\n  // If path has no segments, returns null.\n  // If path has only invisible segments, returns bbox of the end point of last segment.\n  bbox: function () {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) return null; // if segments is an empty array\n\n    var bbox;\n\n    for (var i = 0; i < numSegments; i++) {\n      var segment = segments[i];\n\n      if (segment.isVisible) {\n        var segmentBBox = segment.bbox();\n        bbox = bbox ? bbox.union(segmentBBox) : segmentBBox;\n      }\n    }\n\n    if (bbox) return bbox; // if the path has only invisible elements, return end point of last segment\n\n    var lastSegment = segments[numSegments - 1];\n    return new Rect(lastSegment.end.x, lastSegment.end.y, 0, 0);\n  },\n  // Returns a new path that is a clone of this path.\n  clone: function () {\n    var segments = this.segments;\n    var numSegments = segments.length; // works even if path has no segments\n\n    var path = new Path();\n\n    for (var i = 0; i < numSegments; i++) {\n      var segment = segments[i].clone();\n      path.appendSegment(segment);\n    }\n\n    return path;\n  },\n  closestPoint: function (p, opt) {\n    var t = this.closestPointT(p, opt);\n    if (!t) return null;\n    return this.pointAtT(t);\n  },\n  closestPointLength: function (p, opt) {\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n      precision: precision\n    }) : opt.segmentSubdivisions;\n    var localOpt = {\n      precision: precision,\n      segmentSubdivisions: segmentSubdivisions\n    };\n    var t = this.closestPointT(p, localOpt);\n    if (!t) return 0;\n    return this.lengthAtT(t, localOpt);\n  },\n  closestPointNormalizedLength: function (p, opt) {\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n      precision: precision\n    }) : opt.segmentSubdivisions;\n    var localOpt = {\n      precision: precision,\n      segmentSubdivisions: segmentSubdivisions\n    };\n    var cpLength = this.closestPointLength(p, localOpt);\n    if (cpLength === 0) return 0; // shortcut\n\n    var length = this.length(localOpt);\n    if (length === 0) return 0; // prevents division by zero\n\n    return cpLength / length;\n  },\n  // Private function.\n  closestPointT: function (p, opt) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) return null; // if segments is an empty array\n\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n      precision: precision\n    }) : opt.segmentSubdivisions; // not using localOpt\n\n    var closestPointT;\n    var minSquaredDistance = Infinity;\n\n    for (var i = 0; i < numSegments; i++) {\n      var segment = segments[i];\n      var subdivisions = segmentSubdivisions[i];\n\n      if (segment.isVisible) {\n        var segmentClosestPointT = segment.closestPointT(p, {\n          precision: precision,\n          subdivisions: subdivisions\n        });\n        var segmentClosestPoint = segment.pointAtT(segmentClosestPointT);\n        var squaredDistance = new Line(segmentClosestPoint, p).squaredLength();\n\n        if (squaredDistance < minSquaredDistance) {\n          closestPointT = {\n            segmentIndex: i,\n            value: segmentClosestPointT\n          };\n          minSquaredDistance = squaredDistance;\n        }\n      }\n    }\n\n    if (closestPointT) return closestPointT; // if no visible segment, return end of last segment\n\n    return {\n      segmentIndex: numSegments - 1,\n      value: 1\n    };\n  },\n  closestPointTangent: function (p, opt) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) return null; // if segments is an empty array\n\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n      precision: precision\n    }) : opt.segmentSubdivisions; // not using localOpt\n\n    var closestPointTangent;\n    var minSquaredDistance = Infinity;\n\n    for (var i = 0; i < numSegments; i++) {\n      var segment = segments[i];\n      var subdivisions = segmentSubdivisions[i];\n\n      if (segment.isDifferentiable()) {\n        var segmentClosestPointT = segment.closestPointT(p, {\n          precision: precision,\n          subdivisions: subdivisions\n        });\n        var segmentClosestPoint = segment.pointAtT(segmentClosestPointT);\n        var squaredDistance = new Line(segmentClosestPoint, p).squaredLength();\n\n        if (squaredDistance < minSquaredDistance) {\n          closestPointTangent = segment.tangentAtT(segmentClosestPointT);\n          minSquaredDistance = squaredDistance;\n        }\n      }\n    }\n\n    if (closestPointTangent) return closestPointTangent; // if no valid segment, return null\n\n    return null;\n  },\n  // Returns `true` if the area surrounded by the path contains the point `p`.\n  // Implements the even-odd algorithm (self-intersections are \"outside\").\n  // Closes open paths (always imagines a final closing segment).\n  // Precision may be adjusted by passing an `opt` object.\n  containsPoint: function (p, opt) {\n    var polylines = this.toPolylines(opt);\n    if (!polylines) return false; // shortcut (this path has no polylines)\n\n    var numPolylines = polylines.length; // how many component polylines does `p` lie within?\n\n    var numIntersections = 0;\n\n    for (var i = 0; i < numPolylines; i++) {\n      var polyline = polylines[i];\n\n      if (polyline.containsPoint(p)) {\n        // `p` lies within this polyline\n        numIntersections++;\n      }\n    } // returns `true` for odd numbers of intersections (even-odd algorithm)\n\n\n    return numIntersections % 2 === 1;\n  },\n  // Divides the path into two at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.\n  divideAt: function (ratio, opt) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) return null; // if segments is an empty array\n\n    if (ratio < 0) ratio = 0;\n    if (ratio > 1) ratio = 1;\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n      precision: precision\n    }) : opt.segmentSubdivisions;\n    var localOpt = {\n      precision: precision,\n      segmentSubdivisions: segmentSubdivisions\n    };\n    var pathLength = this.length(localOpt);\n    var length = pathLength * ratio;\n    return this.divideAtLength(length, localOpt);\n  },\n  // Divides the path into two at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n  divideAtLength: function (length, opt) {\n    var numSegments = this.segments.length;\n    if (numSegments === 0) return null; // if segments is an empty array\n\n    var fromStart = true;\n\n    if (length < 0) {\n      fromStart = false; // negative lengths mean start calculation from end point\n\n      length = -length; // absolute value\n    }\n\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n      precision: precision\n    }) : opt.segmentSubdivisions; // not using localOpt\n\n    var i;\n    var segment; // identify the segment to divide:\n\n    var l = 0; // length so far\n\n    var divided;\n    var dividedSegmentIndex;\n    var lastValidSegment; // visible AND differentiable\n\n    var lastValidSegmentIndex;\n    var t;\n\n    for (i = 0; i < numSegments; i++) {\n      var index = fromStart ? i : numSegments - 1 - i;\n      segment = this.getSegment(index);\n      var subdivisions = segmentSubdivisions[index];\n      var d = segment.length({\n        precision: precision,\n        subdivisions: subdivisions\n      });\n\n      if (segment.isDifferentiable()) {\n        // segment is not just a point\n        lastValidSegment = segment;\n        lastValidSegmentIndex = index;\n\n        if (length <= l + d) {\n          dividedSegmentIndex = index;\n          divided = segment.divideAtLength((fromStart ? 1 : -1) * (length - l), {\n            precision: precision,\n            subdivisions: subdivisions\n          });\n          break;\n        }\n      }\n\n      l += d;\n    }\n\n    if (!lastValidSegment) {\n      // no valid segment found\n      return null;\n    } // else: the path contains at least one valid segment\n\n\n    if (!divided) {\n      // the desired length is greater than the length of the path\n      dividedSegmentIndex = lastValidSegmentIndex;\n      t = fromStart ? 1 : 0;\n      divided = lastValidSegment.divideAtT(t);\n    } // create a copy of this path and replace the identified segment with its two divided parts:\n\n\n    var pathCopy = this.clone();\n    pathCopy.replaceSegment(dividedSegmentIndex, divided);\n    var divisionStartIndex = dividedSegmentIndex;\n    var divisionMidIndex = dividedSegmentIndex + 1;\n    var divisionEndIndex = dividedSegmentIndex + 2; // do not insert the part if it looks like a point\n\n    if (!divided[0].isDifferentiable()) {\n      pathCopy.removeSegment(divisionStartIndex);\n      divisionMidIndex -= 1;\n      divisionEndIndex -= 1;\n    } // insert a Moveto segment to ensure secondPath will be valid:\n\n\n    var movetoEnd = pathCopy.getSegment(divisionMidIndex).start;\n    pathCopy.insertSegment(divisionMidIndex, Path.createSegment('M', movetoEnd));\n    divisionEndIndex += 1; // do not insert the part if it looks like a point\n\n    if (!divided[1].isDifferentiable()) {\n      pathCopy.removeSegment(divisionEndIndex - 1);\n      divisionEndIndex -= 1;\n    } // ensure that Closepath segments in secondPath will be assigned correct subpathStartSegment:\n\n\n    var secondPathSegmentIndexConversion = divisionEndIndex - divisionStartIndex - 1;\n\n    for (i = divisionEndIndex; i < pathCopy.segments.length; i++) {\n      var originalSegment = this.getSegment(i - secondPathSegmentIndexConversion);\n      segment = pathCopy.getSegment(i);\n\n      if (segment.type === 'Z' && !originalSegment.subpathStartSegment.end.equals(segment.subpathStartSegment.end)) {\n        // pathCopy segment's subpathStartSegment is different from original segment's one\n        // convert this Closepath segment to a Lineto and replace it in pathCopy\n        var convertedSegment = Path.createSegment('L', originalSegment.end);\n        pathCopy.replaceSegment(i, convertedSegment);\n      }\n    } // distribute pathCopy segments into two paths and return those:\n\n\n    var firstPath = new Path(pathCopy.segments.slice(0, divisionMidIndex));\n    var secondPath = new Path(pathCopy.segments.slice(divisionMidIndex));\n    return [firstPath, secondPath];\n  },\n  // Checks whether two paths are exactly the same.\n  // If `p` is undefined or null, returns false.\n  equals: function (p) {\n    if (!p) return false;\n    var segments = this.segments;\n    var otherSegments = p.segments;\n    var numSegments = segments.length;\n    if (otherSegments.length !== numSegments) return false; // if the two paths have different number of segments, they cannot be equal\n\n    for (var i = 0; i < numSegments; i++) {\n      var segment = segments[i];\n      var otherSegment = otherSegments[i]; // as soon as an inequality is found in segments, return false\n\n      if (segment.type !== otherSegment.type || !segment.equals(otherSegment)) return false;\n    } // if no inequality found in segments, return true\n\n\n    return true;\n  },\n  // Accepts negative indices.\n  // Throws an error if path has no segments.\n  // Throws an error if index is out of range.\n  getSegment: function (index) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) throw new Error('Path has no segments.');\n    if (index < 0) index = numSegments + index; // convert negative indices to positive\n\n    if (index >= numSegments || index < 0) throw new Error('Index out of range.');\n    return segments[index];\n  },\n  // Returns an array of segment subdivisions, with precision better than requested `opt.precision`.\n  getSegmentSubdivisions: function (opt) {\n    var segments = this.segments;\n    var numSegments = segments.length; // works even if path has no segments\n\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision; // not using opt.segmentSubdivisions\n    // not using localOpt\n\n    var segmentSubdivisions = [];\n\n    for (var i = 0; i < numSegments; i++) {\n      var segment = segments[i];\n      var subdivisions = segment.getSubdivisions({\n        precision: precision\n      });\n      segmentSubdivisions.push(subdivisions);\n    }\n\n    return segmentSubdivisions;\n  },\n  // Returns an array of subpaths of this path.\n  // Invalid paths are validated first.\n  // Returns `[]` if path has no segments.\n  getSubpaths: function () {\n    const validatedPath = this.clone().validate();\n    const segments = validatedPath.segments;\n    const numSegments = segments.length;\n    const subpaths = [];\n\n    for (let i = 0; i < numSegments; i++) {\n      const segment = segments[i];\n\n      if (segment.isSubpathStart) {\n        // we encountered a subpath start segment\n        // create a new path for segment, and push it to list of subpaths\n        subpaths.push(new Path(segment));\n      } else {\n        // append current segment to the last subpath\n        subpaths[subpaths.length - 1].appendSegment(segment);\n      }\n    }\n\n    return subpaths;\n  },\n  // Insert `arg` at given `index`.\n  // `index = 0` means insert at the beginning.\n  // `index = segments.length` means insert at the end.\n  // Accepts negative indices, from `-1` to `-(segments.length + 1)`.\n  // Accepts one segment or an array of segments as argument.\n  // Throws an error if index is out of range.\n  // Throws an error if argument is not a segment or an array of segments.\n  insertSegment: function (index, arg) {\n    var segments = this.segments;\n    var numSegments = segments.length; // works even if path has no segments\n    // note that these are incremented compared to getSegments()\n    // we can insert after last element (note that this changes the meaning of index -1)\n\n    if (index < 0) index = numSegments + index + 1; // convert negative indices to positive\n\n    if (index > numSegments || index < 0) throw new Error('Index out of range.');\n    var currentSegment;\n    var previousSegment = null;\n    var nextSegment = null;\n\n    if (numSegments !== 0) {\n      if (index >= 1) {\n        previousSegment = segments[index - 1];\n        nextSegment = previousSegment.nextSegment; // if we are inserting at end, nextSegment is null\n      } else {\n        // if index === 0\n        // previousSegment is null\n        nextSegment = segments[0];\n      }\n    }\n\n    if (!Array.isArray(arg)) {\n      if (!arg || !arg.isSegment) throw new Error('Segment required.');\n      currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);\n      segments.splice(index, 0, currentSegment);\n    } else {\n      // flatten one level deep\n      // so we can chain arbitrary Path.createSegment results\n      arg = arg.reduce(function (acc, val) {\n        return acc.concat(val);\n      }, []);\n      if (!arg[0].isSegment) throw new Error('Segments required.');\n      var n = arg.length;\n\n      for (var i = 0; i < n; i++) {\n        var currentArg = arg[i];\n        currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);\n        segments.splice(index + i, 0, currentSegment); // incrementing index to insert subsequent segments after inserted segments\n\n        previousSegment = currentSegment;\n      }\n    }\n  },\n  intersectionWithLine: function (line, opt) {\n    var intersection = null;\n    var polylines = this.toPolylines(opt);\n    if (!polylines) return null;\n\n    for (var i = 0, n = polylines.length; i < n; i++) {\n      var polyline = polylines[i];\n      var polylineIntersection = line.intersect(polyline);\n\n      if (polylineIntersection) {\n        intersection || (intersection = []);\n\n        if (Array.isArray(polylineIntersection)) {\n          Array.prototype.push.apply(intersection, polylineIntersection);\n        } else {\n          intersection.push(polylineIntersection);\n        }\n      }\n    }\n\n    return intersection;\n  },\n  isDifferentiable: function () {\n    var segments = this.segments;\n    var numSegments = segments.length;\n\n    for (var i = 0; i < numSegments; i++) {\n      var segment = segments[i]; // as soon as a differentiable segment is found in segments, return true\n\n      if (segment.isDifferentiable()) return true;\n    } // if no differentiable segment is found in segments, return false\n\n\n    return false;\n  },\n  // Checks whether current path segments are valid.\n  // Note that d is allowed to be empty - should disable rendering of the path.\n  isValid: function () {\n    var segments = this.segments;\n    var isValid = segments.length === 0 || segments[0].type === 'M'; // either empty or first segment is a Moveto\n\n    return isValid;\n  },\n  // Returns length of the path, with precision better than requested `opt.precision`; or using `opt.segmentSubdivisions` provided.\n  // If path has no segments, returns 0.\n  length: function (opt) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) return 0; // if segments is an empty array\n\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision; // opt.precision only used in getSegmentSubdivisions() call\n\n    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n      precision: precision\n    }) : opt.segmentSubdivisions; // not using localOpt\n\n    var length = 0;\n\n    for (var i = 0; i < numSegments; i++) {\n      var segment = segments[i];\n      var subdivisions = segmentSubdivisions[i];\n      length += segment.length({\n        subdivisions: subdivisions\n      });\n    }\n\n    return length;\n  },\n  // Private function.\n  lengthAtT: function (t, opt) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) return 0; // if segments is an empty array\n\n    var segmentIndex = t.segmentIndex;\n    if (segmentIndex < 0) return 0; // regardless of t.value\n\n    var tValue = t.value;\n\n    if (segmentIndex >= numSegments) {\n      segmentIndex = numSegments - 1;\n      tValue = 1;\n    } else if (tValue < 0) tValue = 0;else if (tValue > 1) tValue = 1;\n\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n      precision: precision\n    }) : opt.segmentSubdivisions; // not using localOpt\n\n    var subdivisions;\n    var length = 0;\n\n    for (var i = 0; i < segmentIndex; i++) {\n      var segment = segments[i];\n      subdivisions = segmentSubdivisions[i];\n      length += segment.length({\n        precisison: precision,\n        subdivisions: subdivisions\n      });\n    }\n\n    segment = segments[segmentIndex];\n    subdivisions = segmentSubdivisions[segmentIndex];\n    length += segment.lengthAtT(tValue, {\n      precisison: precision,\n      subdivisions: subdivisions\n    });\n    return length;\n  },\n  // Returns point at requested `ratio` between 0 and 1, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n  pointAt: function (ratio, opt) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) return null; // if segments is an empty array\n\n    if (ratio <= 0) return this.start.clone();\n    if (ratio >= 1) return this.end.clone();\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n      precision: precision\n    }) : opt.segmentSubdivisions;\n    var localOpt = {\n      precision: precision,\n      segmentSubdivisions: segmentSubdivisions\n    };\n    var pathLength = this.length(localOpt);\n    var length = pathLength * ratio;\n    return this.pointAtLength(length, localOpt);\n  },\n  // Returns point at requested `length`, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n  // Accepts negative length.\n  pointAtLength: function (length, opt) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) return null; // if segments is an empty array\n\n    if (length === 0) return this.start.clone();\n    var fromStart = true;\n\n    if (length < 0) {\n      fromStart = false; // negative lengths mean start calculation from end point\n\n      length = -length; // absolute value\n    }\n\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n      precision: precision\n    }) : opt.segmentSubdivisions; // not using localOpt\n\n    var lastVisibleSegment;\n    var l = 0; // length so far\n\n    for (var i = 0; i < numSegments; i++) {\n      var index = fromStart ? i : numSegments - 1 - i;\n      var segment = segments[index];\n      var subdivisions = segmentSubdivisions[index];\n      var d = segment.length({\n        precision: precision,\n        subdivisions: subdivisions\n      });\n\n      if (segment.isVisible) {\n        if (length <= l + d) {\n          return segment.pointAtLength((fromStart ? 1 : -1) * (length - l), {\n            precision: precision,\n            subdivisions: subdivisions\n          });\n        }\n\n        lastVisibleSegment = segment;\n      }\n\n      l += d;\n    } // if length requested is higher than the length of the path, return last visible segment endpoint\n\n\n    if (lastVisibleSegment) return fromStart ? lastVisibleSegment.end : lastVisibleSegment.start; // if no visible segment, return last segment end point (no matter if fromStart or no)\n\n    var lastSegment = segments[numSegments - 1];\n    return lastSegment.end.clone();\n  },\n  // Private function.\n  pointAtT: function (t) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) return null; // if segments is an empty array\n\n    var segmentIndex = t.segmentIndex;\n    if (segmentIndex < 0) return segments[0].pointAtT(0);\n    if (segmentIndex >= numSegments) return segments[numSegments - 1].pointAtT(1);\n    var tValue = t.value;\n    if (tValue < 0) tValue = 0;else if (tValue > 1) tValue = 1;\n    return segments[segmentIndex].pointAtT(tValue);\n  },\n  // Default precision\n  PRECISION: 3,\n  // Helper method for adding segments.\n  prepareSegment: function (segment, previousSegment, nextSegment) {\n    // insert after previous segment and before previous segment's next segment\n    segment.previousSegment = previousSegment;\n    segment.nextSegment = nextSegment;\n    if (previousSegment) previousSegment.nextSegment = segment;\n    if (nextSegment) nextSegment.previousSegment = segment;\n    var updateSubpathStart = segment;\n\n    if (segment.isSubpathStart) {\n      segment.subpathStartSegment = segment; // assign self as subpath start segment\n\n      updateSubpathStart = nextSegment; // start updating from next segment\n    } // assign previous segment's subpath start (or self if it is a subpath start) to subsequent segments\n\n\n    if (updateSubpathStart) this.updateSubpathStartSegment(updateSubpathStart);\n    return segment;\n  },\n  // Remove the segment at `index`.\n  // Accepts negative indices, from `-1` to `-segments.length`.\n  // Throws an error if path has no segments.\n  // Throws an error if index is out of range.\n  removeSegment: function (index) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) throw new Error('Path has no segments.');\n    if (index < 0) index = numSegments + index; // convert negative indices to positive\n\n    if (index >= numSegments || index < 0) throw new Error('Index out of range.');\n    var removedSegment = segments.splice(index, 1)[0];\n    var previousSegment = removedSegment.previousSegment;\n    var nextSegment = removedSegment.nextSegment; // link the previous and next segments together (if present)\n\n    if (previousSegment) previousSegment.nextSegment = nextSegment; // may be null\n\n    if (nextSegment) nextSegment.previousSegment = previousSegment; // may be null\n    // if removed segment used to start a subpath, update all subsequent segments until another subpath start segment is reached\n\n    if (removedSegment.isSubpathStart && nextSegment) this.updateSubpathStartSegment(nextSegment);\n  },\n  // Replace the segment at `index` with `arg`.\n  // Accepts negative indices, from `-1` to `-segments.length`.\n  // Accepts one segment or an array of segments as argument.\n  // Throws an error if path has no segments.\n  // Throws an error if index is out of range.\n  // Throws an error if argument is not a segment or an array of segments.\n  replaceSegment: function (index, arg) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) throw new Error('Path has no segments.');\n    if (index < 0) index = numSegments + index; // convert negative indices to positive\n\n    if (index >= numSegments || index < 0) throw new Error('Index out of range.');\n    var currentSegment;\n    var replacedSegment = segments[index];\n    var previousSegment = replacedSegment.previousSegment;\n    var nextSegment = replacedSegment.nextSegment;\n    var updateSubpathStart = replacedSegment.isSubpathStart; // boolean: is an update of subpath starts necessary?\n\n    if (!Array.isArray(arg)) {\n      if (!arg || !arg.isSegment) throw new Error('Segment required.');\n      currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);\n      segments.splice(index, 1, currentSegment); // directly replace\n\n      if (updateSubpathStart && currentSegment.isSubpathStart) updateSubpathStart = false; // already updated by `prepareSegment`\n    } else {\n      // flatten one level deep\n      // so we can chain arbitrary Path.createSegment results\n      arg = arg.reduce(function (acc, val) {\n        return acc.concat(val);\n      }, []);\n      if (!arg[0].isSegment) throw new Error('Segments required.');\n      segments.splice(index, 1);\n      var n = arg.length;\n\n      for (var i = 0; i < n; i++) {\n        var currentArg = arg[i];\n        currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);\n        segments.splice(index + i, 0, currentSegment); // incrementing index to insert subsequent segments after inserted segments\n\n        previousSegment = currentSegment;\n        if (updateSubpathStart && currentSegment.isSubpathStart) updateSubpathStart = false; // already updated by `prepareSegment`\n      }\n    } // if replaced segment used to start a subpath and no new subpath start was added, update all subsequent segments until another subpath start segment is reached\n\n\n    if (updateSubpathStart && nextSegment) this.updateSubpathStartSegment(nextSegment);\n  },\n  round: function (precision) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n\n    for (var i = 0; i < numSegments; i++) {\n      var segment = segments[i];\n      segment.round(precision);\n    }\n\n    return this;\n  },\n  scale: function (sx, sy, origin) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n\n    for (var i = 0; i < numSegments; i++) {\n      var segment = segments[i];\n      segment.scale(sx, sy, origin);\n    }\n\n    return this;\n  },\n  segmentAt: function (ratio, opt) {\n    var index = this.segmentIndexAt(ratio, opt);\n    if (!index) return null;\n    return this.getSegment(index);\n  },\n  // Accepts negative length.\n  segmentAtLength: function (length, opt) {\n    var index = this.segmentIndexAtLength(length, opt);\n    if (!index) return null;\n    return this.getSegment(index);\n  },\n  segmentIndexAt: function (ratio, opt) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) return null; // if segments is an empty array\n\n    if (ratio < 0) ratio = 0;\n    if (ratio > 1) ratio = 1;\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n      precision: precision\n    }) : opt.segmentSubdivisions;\n    var localOpt = {\n      precision: precision,\n      segmentSubdivisions: segmentSubdivisions\n    };\n    var pathLength = this.length(localOpt);\n    var length = pathLength * ratio;\n    return this.segmentIndexAtLength(length, localOpt);\n  },\n  // Accepts negative length.\n  segmentIndexAtLength: function (length, opt) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) return null; // if segments is an empty array\n\n    var fromStart = true;\n\n    if (length < 0) {\n      fromStart = false; // negative lengths mean start calculation from end point\n\n      length = -length; // absolute value\n    }\n\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n      precision: precision\n    }) : opt.segmentSubdivisions; // not using localOpt\n\n    var lastVisibleSegmentIndex = null;\n    var l = 0; // length so far\n\n    for (var i = 0; i < numSegments; i++) {\n      var index = fromStart ? i : numSegments - 1 - i;\n      var segment = segments[index];\n      var subdivisions = segmentSubdivisions[index];\n      var d = segment.length({\n        precision: precision,\n        subdivisions: subdivisions\n      });\n\n      if (segment.isVisible) {\n        if (length <= l + d) return index;\n        lastVisibleSegmentIndex = index;\n      }\n\n      l += d;\n    } // if length requested is higher than the length of the path, return last visible segment index\n    // if no visible segment, return null\n\n\n    return lastVisibleSegmentIndex;\n  },\n  // Returns a string that can be used to reconstruct the path.\n  // Additional error checking compared to toString (must start with M segment).\n  serialize: function () {\n    if (!this.isValid()) throw new Error('Invalid path segments.');\n    return this.toString();\n  },\n  // Returns tangent line at requested `ratio` between 0 and 1, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n  tangentAt: function (ratio, opt) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) return null; // if segments is an empty array\n\n    if (ratio < 0) ratio = 0;\n    if (ratio > 1) ratio = 1;\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n      precision: precision\n    }) : opt.segmentSubdivisions;\n    var localOpt = {\n      precision: precision,\n      segmentSubdivisions: segmentSubdivisions\n    };\n    var pathLength = this.length(localOpt);\n    var length = pathLength * ratio;\n    return this.tangentAtLength(length, localOpt);\n  },\n  // Returns tangent line at requested `length`, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n  // Accepts negative length.\n  tangentAtLength: function (length, opt) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) return null; // if segments is an empty array\n\n    var fromStart = true;\n\n    if (length < 0) {\n      fromStart = false; // negative lengths mean start calculation from end point\n\n      length = -length; // absolute value\n    }\n\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n      precision: precision\n    }) : opt.segmentSubdivisions; // not using localOpt\n\n    var lastValidSegment; // visible AND differentiable (with a tangent)\n\n    var l = 0; // length so far\n\n    for (var i = 0; i < numSegments; i++) {\n      var index = fromStart ? i : numSegments - 1 - i;\n      var segment = segments[index];\n      var subdivisions = segmentSubdivisions[index];\n      var d = segment.length({\n        precision: precision,\n        subdivisions: subdivisions\n      });\n\n      if (segment.isDifferentiable()) {\n        if (length <= l + d) {\n          return segment.tangentAtLength((fromStart ? 1 : -1) * (length - l), {\n            precision: precision,\n            subdivisions: subdivisions\n          });\n        }\n\n        lastValidSegment = segment;\n      }\n\n      l += d;\n    } // if length requested is higher than the length of the path, return tangent of endpoint of last valid segment\n\n\n    if (lastValidSegment) {\n      var t = fromStart ? 1 : 0;\n      return lastValidSegment.tangentAtT(t);\n    } // if no valid segment, return null\n\n\n    return null;\n  },\n  // Private function.\n  tangentAtT: function (t) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) return null; // if segments is an empty array\n\n    var segmentIndex = t.segmentIndex;\n    if (segmentIndex < 0) return segments[0].tangentAtT(0);\n    if (segmentIndex >= numSegments) return segments[numSegments - 1].tangentAtT(1);\n    var tValue = t.value;\n    if (tValue < 0) tValue = 0;else if (tValue > 1) tValue = 1;\n    return segments[segmentIndex].tangentAtT(tValue);\n  },\n  toPoints: function (opt) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) return null; // if segments is an empty array\n\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n      precision: precision\n    }) : opt.segmentSubdivisions;\n    var points = [];\n    var partialPoints = [];\n\n    for (var i = 0; i < numSegments; i++) {\n      var segment = segments[i];\n\n      if (segment.isVisible) {\n        var currentSegmentSubdivisions = segmentSubdivisions[i];\n\n        if (currentSegmentSubdivisions.length > 0) {\n          var subdivisionPoints = currentSegmentSubdivisions.map(function (curve) {\n            return curve.start;\n          });\n          Array.prototype.push.apply(partialPoints, subdivisionPoints);\n        } else {\n          partialPoints.push(segment.start);\n        }\n      } else if (partialPoints.length > 0) {\n        partialPoints.push(segments[i - 1].end);\n        points.push(partialPoints);\n        partialPoints = [];\n      }\n    }\n\n    if (partialPoints.length > 0) {\n      partialPoints.push(this.end);\n      points.push(partialPoints);\n    }\n\n    return points;\n  },\n  toPolylines: function (opt) {\n    var polylines = [];\n    var points = this.toPoints(opt);\n    if (!points) return null;\n\n    for (var i = 0, n = points.length; i < n; i++) {\n      polylines.push(new Polyline(points[i]));\n    }\n\n    return polylines;\n  },\n  toString: function () {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    var pathData = '';\n\n    for (var i = 0; i < numSegments; i++) {\n      var segment = segments[i];\n      pathData += segment.serialize() + ' ';\n    }\n\n    return pathData.trim();\n  },\n  translate: function (tx, ty) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n\n    for (var i = 0; i < numSegments; i++) {\n      var segment = segments[i];\n      segment.translate(tx, ty);\n    }\n\n    return this;\n  },\n  // Helper method for updating subpath start of segments, starting with the one provided.\n  updateSubpathStartSegment: function (segment) {\n    var previousSegment = segment.previousSegment; // may be null\n\n    while (segment && !segment.isSubpathStart) {\n      // assign previous segment's subpath start segment to this segment\n      if (previousSegment) segment.subpathStartSegment = previousSegment.subpathStartSegment; // may be null\n      else segment.subpathStartSegment = null; // if segment had no previous segment, assign null - creates an invalid path!\n\n      previousSegment = segment;\n      segment = segment.nextSegment; // move on to the segment after etc.\n    }\n  },\n  // If the path is not valid, insert M 0 0 at the beginning.\n  // Path with no segments is considered valid, so nothing is inserted.\n  validate: function () {\n    if (!this.isValid()) this.insertSegment(0, Path.createSegment('M', 0, 0));\n    return this;\n  }\n};\nObject.defineProperty(Path.prototype, 'start', {\n  // Getter for the first visible endpoint of the path.\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) return null;\n\n    for (var i = 0; i < numSegments; i++) {\n      var segment = segments[i];\n      if (segment.isVisible) return segment.start;\n    } // if no visible segment, return last segment end point\n\n\n    return segments[numSegments - 1].end;\n  }\n});\nObject.defineProperty(Path.prototype, 'end', {\n  // Getter for the last visible endpoint of the path.\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) return null;\n\n    for (var i = numSegments - 1; i >= 0; i--) {\n      var segment = segments[i];\n      if (segment.isVisible) return segment.end;\n    } // if no visible segment, return last segment end point\n\n\n    return segments[numSegments - 1].end;\n  }\n}); // Local helper function.\n// Use an array of arguments to call a constructor (function called with `new`).\n// Adapted from https://stackoverflow.com/a/8843181/2263595\n// It is not necessary to use this function if the arguments can be passed separately (i.e. if the number of arguments is limited).\n// - If that is the case, use `new constructor(arg1, arg2)`, for example.\n// It is not necessary to use this function if the function that needs an array of arguments is not supposed to be used as a constructor.\n// - If that is the case, use `f.apply(thisArg, [arg1, arg2...])`, for example.\n\nfunction applyToNew(constructor, argsArray) {\n  // The `new` keyword can only be applied to functions that take a limited number of arguments.\n  // - We can fake that with .bind().\n  // - It calls a function (`constructor`, here) with the arguments that were provided to it - effectively transforming an unlimited number of arguments into limited.\n  // - So `new (constructor.bind(thisArg, arg1, arg2...))`\n  // - `thisArg` can be anything (e.g. null) because `new` keyword resets context to the constructor object.\n  // We need to pass in a variable number of arguments to the bind() call.\n  // - We can use .apply().\n  // - So `new (constructor.bind.apply(constructor, [thisArg, arg1, arg2...]))`\n  // - `thisArg` can still be anything because `new` overwrites it.\n  // Finally, to make sure that constructor.bind overwriting is not a problem, we switch to `Function.prototype.bind`.\n  // - So, the final version is `new (Function.prototype.bind.apply(constructor, [thisArg, arg1, arg2...]))`\n  // The function expects `argsArray[0]` to be `thisArg`.\n  // - This means that whatever is sent as the first element will be ignored.\n  // - The constructor will only see arguments starting from argsArray[1].\n  // - So, a new dummy element is inserted at the start of the array.\n  argsArray.unshift(null);\n  return new (Function.prototype.bind.apply(constructor, argsArray))();\n} // Path segment interface:\n\n\nvar segmentPrototype = {\n  // virtual\n  bbox: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // virtual\n  clone: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // virtual\n  closestPoint: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // virtual\n  closestPointLength: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // virtual\n  closestPointNormalizedLength: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // Redirect calls to closestPointNormalizedLength() function if closestPointT() is not defined for segment.\n  closestPointT: function (p) {\n    if (this.closestPointNormalizedLength) return this.closestPointNormalizedLength(p);\n    throw new Error('Neither closestPointT() nor closestPointNormalizedLength() function is implemented.');\n  },\n  // virtual\n  closestPointTangent: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // virtual\n  divideAt: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // virtual\n  divideAtLength: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // Redirect calls to divideAt() function if divideAtT() is not defined for segment.\n  divideAtT: function (t) {\n    if (this.divideAt) return this.divideAt(t);\n    throw new Error('Neither divideAtT() nor divideAt() function is implemented.');\n  },\n  // virtual\n  equals: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // virtual\n  getSubdivisions: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // virtual\n  isDifferentiable: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  isSegment: true,\n  isSubpathStart: false,\n  // true for Moveto segments\n  isVisible: true,\n  // false for Moveto segments\n  // virtual\n  length: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // Return a fraction of result of length() function if lengthAtT() is not defined for segment.\n  lengthAtT: function (t) {\n    if (t <= 0) return 0;\n    var length = this.length();\n    if (t >= 1) return length;\n    return length * t;\n  },\n  nextSegment: null,\n  // needed for subpath start segment updating\n  // virtual\n  pointAt: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // virtual\n  pointAtLength: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // Redirect calls to pointAt() function if pointAtT() is not defined for segment.\n  pointAtT: function (t) {\n    if (this.pointAt) return this.pointAt(t);\n    throw new Error('Neither pointAtT() nor pointAt() function is implemented.');\n  },\n  previousSegment: null,\n  // needed to get segment start property\n  // virtual\n  round: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  subpathStartSegment: null,\n  // needed to get Closepath segment end property\n  // virtual\n  scale: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // virtual\n  serialize: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // virtual\n  tangentAt: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // virtual\n  tangentAtLength: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // Redirect calls to tangentAt() function if tangentAtT() is not defined for segment.\n  tangentAtT: function (t) {\n    if (this.tangentAt) return this.tangentAt(t);\n    throw new Error('Neither tangentAtT() nor tangentAt() function is implemented.');\n  },\n  // virtual\n  toString: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // virtual\n  translate: function () {\n    throw new Error('Declaration missing for virtual function.');\n  }\n}; // usually directly assigned\n// getter for Closepath\n\nObject.defineProperty(segmentPrototype, 'end', {\n  configurable: true,\n  enumerable: true,\n  writable: true\n}); // always a getter\n// always throws error for Moveto\n\nObject.defineProperty(segmentPrototype, 'start', {\n  // get a reference to the end point of previous segment\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    if (!this.previousSegment) throw new Error('Missing previous segment. (This segment cannot be the first segment of a path; OR segment has not yet been added to a path.)');\n    return this.previousSegment.end;\n  }\n}); // virtual\n\nObject.defineProperty(segmentPrototype, 'type', {\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    throw new Error('Bad segment declaration. No type specified.');\n  }\n}); // Path segment implementations:\n\nvar Lineto = function () {\n  var args = [];\n  var n = arguments.length;\n\n  for (var i = 0; i < n; i++) {\n    args.push(arguments[i]);\n  }\n\n  if (!(this instanceof Lineto)) {\n    // switching context of `this` to Lineto when called without `new`\n    return applyToNew(Lineto, args);\n  }\n\n  if (n === 0) {\n    throw new Error('Lineto constructor expects a line, 1 point, or 2 coordinates (none provided).');\n  }\n\n  var outputArray;\n\n  if (args[0] instanceof Line) {\n    // lines provided\n    if (n === 1) {\n      this.end = args[0].end.clone();\n      return this;\n    } else {\n      throw new Error('Lineto constructor expects a line, 1 point, or 2 coordinates (' + n + ' lines provided).');\n    }\n  } else if (typeof args[0] === 'string' || typeof args[0] === 'number') {\n    // coordinates provided\n    if (n === 2) {\n      this.end = new Point(+args[0], +args[1]);\n      return this;\n    } else if (n < 2) {\n      throw new Error('Lineto constructor expects a line, 1 point, or 2 coordinates (' + n + ' coordinates provided).');\n    } else {\n      // this is a poly-line segment\n      var segmentCoords;\n      outputArray = [];\n\n      for (i = 0; i < n; i += 2) {\n        // coords come in groups of two\n        segmentCoords = args.slice(i, i + 2); // will send one coord if args.length not divisible by 2\n\n        outputArray.push(applyToNew(Lineto, segmentCoords));\n      }\n\n      return outputArray;\n    }\n  } else {\n    // points provided (needs to be last to also cover plain objects with x and y)\n    if (n === 1) {\n      this.end = new Point(args[0]);\n      return this;\n    } else {\n      // this is a poly-line segment\n      var segmentPoint;\n      outputArray = [];\n\n      for (i = 0; i < n; i += 1) {\n        segmentPoint = args[i];\n        outputArray.push(new Lineto(segmentPoint));\n      }\n\n      return outputArray;\n    }\n  }\n};\n\nvar linetoPrototype = {\n  clone: function () {\n    return new Lineto(this.end);\n  },\n  divideAt: function (ratio) {\n    var line = new Line(this.start, this.end);\n    var divided = line.divideAt(ratio);\n    return [new Lineto(divided[0]), new Lineto(divided[1])];\n  },\n  divideAtLength: function (length) {\n    var line = new Line(this.start, this.end);\n    var divided = line.divideAtLength(length);\n    return [new Lineto(divided[0]), new Lineto(divided[1])];\n  },\n  getSubdivisions: function () {\n    return [];\n  },\n  isDifferentiable: function () {\n    if (!this.previousSegment) return false;\n    return !this.start.equals(this.end);\n  },\n  round: function (precision) {\n    this.end.round(precision);\n    return this;\n  },\n  scale: function (sx, sy, origin) {\n    this.end.scale(sx, sy, origin);\n    return this;\n  },\n  serialize: function () {\n    var end = this.end;\n    return this.type + ' ' + end.x + ' ' + end.y;\n  },\n  toString: function () {\n    return this.type + ' ' + this.start + ' ' + this.end;\n  },\n  translate: function (tx, ty) {\n    this.end.translate(tx, ty);\n    return this;\n  }\n};\nObject.defineProperty(linetoPrototype, 'type', {\n  configurable: true,\n  enumerable: true,\n  value: 'L'\n});\nLineto.prototype = extend(segmentPrototype, Line.prototype, linetoPrototype);\n\nvar Curveto = function () {\n  var args = [];\n  var n = arguments.length;\n\n  for (var i = 0; i < n; i++) {\n    args.push(arguments[i]);\n  }\n\n  if (!(this instanceof Curveto)) {\n    // switching context of `this` to Curveto when called without `new`\n    return applyToNew(Curveto, args);\n  }\n\n  if (n === 0) {\n    throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (none provided).');\n  }\n\n  var outputArray;\n\n  if (args[0] instanceof Curve) {\n    // curves provided\n    if (n === 1) {\n      this.controlPoint1 = args[0].controlPoint1.clone();\n      this.controlPoint2 = args[0].controlPoint2.clone();\n      this.end = args[0].end.clone();\n      return this;\n    } else {\n      throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (' + n + ' curves provided).');\n    }\n  } else if (typeof args[0] === 'string' || typeof args[0] === 'number') {\n    // coordinates provided\n    if (n === 6) {\n      this.controlPoint1 = new Point(+args[0], +args[1]);\n      this.controlPoint2 = new Point(+args[2], +args[3]);\n      this.end = new Point(+args[4], +args[5]);\n      return this;\n    } else if (n < 6) {\n      throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (' + n + ' coordinates provided).');\n    } else {\n      // this is a poly-bezier segment\n      var segmentCoords;\n      outputArray = [];\n\n      for (i = 0; i < n; i += 6) {\n        // coords come in groups of six\n        segmentCoords = args.slice(i, i + 6); // will send fewer than six coords if args.length not divisible by 6\n\n        outputArray.push(applyToNew(Curveto, segmentCoords));\n      }\n\n      return outputArray;\n    }\n  } else {\n    // points provided (needs to be last to also cover plain objects with x and y)\n    if (n === 3) {\n      this.controlPoint1 = new Point(args[0]);\n      this.controlPoint2 = new Point(args[1]);\n      this.end = new Point(args[2]);\n      return this;\n    } else if (n < 3) {\n      throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (' + n + ' points provided).');\n    } else {\n      // this is a poly-bezier segment\n      var segmentPoints;\n      outputArray = [];\n\n      for (i = 0; i < n; i += 3) {\n        // points come in groups of three\n        segmentPoints = args.slice(i, i + 3); // will send fewer than three points if args.length is not divisible by 3\n\n        outputArray.push(applyToNew(Curveto, segmentPoints));\n      }\n\n      return outputArray;\n    }\n  }\n};\n\nvar curvetoPrototype = {\n  clone: function () {\n    return new Curveto(this.controlPoint1, this.controlPoint2, this.end);\n  },\n  divideAt: function (ratio, opt) {\n    var curve = new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n    var divided = curve.divideAt(ratio, opt);\n    return [new Curveto(divided[0]), new Curveto(divided[1])];\n  },\n  divideAtLength: function (length, opt) {\n    var curve = new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n    var divided = curve.divideAtLength(length, opt);\n    return [new Curveto(divided[0]), new Curveto(divided[1])];\n  },\n  divideAtT: function (t) {\n    var curve = new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n    var divided = curve.divideAtT(t);\n    return [new Curveto(divided[0]), new Curveto(divided[1])];\n  },\n  isDifferentiable: function () {\n    if (!this.previousSegment) return false;\n    var start = this.start;\n    var control1 = this.controlPoint1;\n    var control2 = this.controlPoint2;\n    var end = this.end;\n    return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));\n  },\n  round: function (precision) {\n    this.controlPoint1.round(precision);\n    this.controlPoint2.round(precision);\n    this.end.round(precision);\n    return this;\n  },\n  scale: function (sx, sy, origin) {\n    this.controlPoint1.scale(sx, sy, origin);\n    this.controlPoint2.scale(sx, sy, origin);\n    this.end.scale(sx, sy, origin);\n    return this;\n  },\n  serialize: function () {\n    var c1 = this.controlPoint1;\n    var c2 = this.controlPoint2;\n    var end = this.end;\n    return this.type + ' ' + c1.x + ' ' + c1.y + ' ' + c2.x + ' ' + c2.y + ' ' + end.x + ' ' + end.y;\n  },\n  toString: function () {\n    return this.type + ' ' + this.start + ' ' + this.controlPoint1 + ' ' + this.controlPoint2 + ' ' + this.end;\n  },\n  translate: function (tx, ty) {\n    this.controlPoint1.translate(tx, ty);\n    this.controlPoint2.translate(tx, ty);\n    this.end.translate(tx, ty);\n    return this;\n  }\n};\nObject.defineProperty(curvetoPrototype, 'type', {\n  configurable: true,\n  enumerable: true,\n  value: 'C'\n});\nCurveto.prototype = extend(segmentPrototype, Curve.prototype, curvetoPrototype);\n\nvar Moveto = function () {\n  var args = [];\n  var n = arguments.length;\n\n  for (var i = 0; i < n; i++) {\n    args.push(arguments[i]);\n  }\n\n  if (!(this instanceof Moveto)) {\n    // switching context of `this` to Moveto when called without `new`\n    return applyToNew(Moveto, args);\n  }\n\n  if (n === 0) {\n    throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (none provided).');\n  }\n\n  var outputArray;\n\n  if (args[0] instanceof Line) {\n    // lines provided\n    if (n === 1) {\n      this.end = args[0].end.clone();\n      return this;\n    } else {\n      throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (' + n + ' lines provided).');\n    }\n  } else if (args[0] instanceof Curve) {\n    // curves provided\n    if (n === 1) {\n      this.end = args[0].end.clone();\n      return this;\n    } else {\n      throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (' + n + ' curves provided).');\n    }\n  } else if (typeof args[0] === 'string' || typeof args[0] === 'number') {\n    // coordinates provided\n    if (n === 2) {\n      this.end = new Point(+args[0], +args[1]);\n      return this;\n    } else if (n < 2) {\n      throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (' + n + ' coordinates provided).');\n    } else {\n      // this is a moveto-with-subsequent-poly-line segment\n      var segmentCoords;\n      outputArray = [];\n\n      for (i = 0; i < n; i += 2) {\n        // coords come in groups of two\n        segmentCoords = args.slice(i, i + 2); // will send one coord if args.length not divisible by 2\n\n        if (i === 0) outputArray.push(applyToNew(Moveto, segmentCoords));else outputArray.push(applyToNew(Lineto, segmentCoords));\n      }\n\n      return outputArray;\n    }\n  } else {\n    // points provided (needs to be last to also cover plain objects with x and y)\n    if (n === 1) {\n      this.end = new Point(args[0]);\n      return this;\n    } else {\n      // this is a moveto-with-subsequent-poly-line segment\n      var segmentPoint;\n      outputArray = [];\n\n      for (i = 0; i < n; i += 1) {\n        // points come one by one\n        segmentPoint = args[i];\n        if (i === 0) outputArray.push(new Moveto(segmentPoint));else outputArray.push(new Lineto(segmentPoint));\n      }\n\n      return outputArray;\n    }\n  }\n};\n\nvar movetoPrototype = {\n  bbox: function () {\n    return null;\n  },\n  clone: function () {\n    return new Moveto(this.end);\n  },\n  closestPoint: function () {\n    return this.end.clone();\n  },\n  closestPointNormalizedLength: function () {\n    return 0;\n  },\n  closestPointLength: function () {\n    return 0;\n  },\n  closestPointT: function () {\n    return 1;\n  },\n  closestPointTangent: function () {\n    return null;\n  },\n  divideAt: function () {\n    return [this.clone(), this.clone()];\n  },\n  divideAtLength: function () {\n    return [this.clone(), this.clone()];\n  },\n  equals: function (m) {\n    return this.end.equals(m.end);\n  },\n  getSubdivisions: function () {\n    return [];\n  },\n  isDifferentiable: function () {\n    return false;\n  },\n  isSubpathStart: true,\n  isVisible: false,\n  length: function () {\n    return 0;\n  },\n  lengthAtT: function () {\n    return 0;\n  },\n  pointAt: function () {\n    return this.end.clone();\n  },\n  pointAtLength: function () {\n    return this.end.clone();\n  },\n  pointAtT: function () {\n    return this.end.clone();\n  },\n  round: function (precision) {\n    this.end.round(precision);\n    return this;\n  },\n  scale: function (sx, sy, origin) {\n    this.end.scale(sx, sy, origin);\n    return this;\n  },\n  serialize: function () {\n    var end = this.end;\n    return this.type + ' ' + end.x + ' ' + end.y;\n  },\n  tangentAt: function () {\n    return null;\n  },\n  tangentAtLength: function () {\n    return null;\n  },\n  tangentAtT: function () {\n    return null;\n  },\n  toString: function () {\n    return this.type + ' ' + this.end;\n  },\n  translate: function (tx, ty) {\n    this.end.translate(tx, ty);\n    return this;\n  }\n};\nObject.defineProperty(movetoPrototype, 'start', {\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    throw new Error('Illegal access. Moveto segments should not need a start property.');\n  }\n});\nObject.defineProperty(movetoPrototype, 'type', {\n  configurable: true,\n  enumerable: true,\n  value: 'M'\n});\nMoveto.prototype = extend(segmentPrototype, movetoPrototype); // does not inherit from any other geometry object\n\nvar Closepath = function () {\n  var args = [];\n  var n = arguments.length;\n\n  for (var i = 0; i < n; i++) {\n    args.push(arguments[i]);\n  }\n\n  if (!(this instanceof Closepath)) {\n    // switching context of `this` to Closepath when called without `new`\n    return applyToNew(Closepath, args);\n  }\n\n  if (n > 0) {\n    throw new Error('Closepath constructor expects no arguments.');\n  }\n\n  return this;\n};\n\nvar closepathPrototype = {\n  clone: function () {\n    return new Closepath();\n  },\n  divideAt: function (ratio) {\n    var line = new Line(this.start, this.end);\n    var divided = line.divideAt(ratio);\n    return [// if we didn't actually cut into the segment, first divided part can stay as Z\n    divided[1].isDifferentiable() ? new Lineto(divided[0]) : this.clone(), new Lineto(divided[1])];\n  },\n  divideAtLength: function (length) {\n    var line = new Line(this.start, this.end);\n    var divided = line.divideAtLength(length);\n    return [// if we didn't actually cut into the segment, first divided part can stay as Z\n    divided[1].isDifferentiable() ? new Lineto(divided[0]) : this.clone(), new Lineto(divided[1])];\n  },\n  getSubdivisions: function () {\n    return [];\n  },\n  isDifferentiable: function () {\n    if (!this.previousSegment || !this.subpathStartSegment) return false;\n    return !this.start.equals(this.end);\n  },\n  round: function () {\n    return this;\n  },\n  scale: function () {\n    return this;\n  },\n  serialize: function () {\n    return this.type;\n  },\n  toString: function () {\n    return this.type + ' ' + this.start + ' ' + this.end;\n  },\n  translate: function () {\n    return this;\n  }\n};\nObject.defineProperty(closepathPrototype, 'end', {\n  // get a reference to the end point of subpath start segment\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    if (!this.subpathStartSegment) throw new Error('Missing subpath start segment. (This segment needs a subpath start segment (e.g. Moveto); OR segment has not yet been added to a path.)');\n    return this.subpathStartSegment.end;\n  }\n});\nObject.defineProperty(closepathPrototype, 'type', {\n  configurable: true,\n  enumerable: true,\n  value: 'Z'\n});\nClosepath.prototype = extend(segmentPrototype, Line.prototype, closepathPrototype);\nvar segmentTypes = Path.segmentTypes = {\n  L: Lineto,\n  C: Curveto,\n  M: Moveto,\n  Z: Closepath,\n  z: Closepath\n};\nPath.regexSupportedData = new RegExp('^[\\\\s\\\\d' + Object.keys(segmentTypes).join('') + ',.]*$');\n\nPath.isDataSupported = function (data) {\n  if (typeof data !== 'string') return false;\n  return this.regexSupportedData.test(data);\n};","map":{"version":3,"names":["Polyline","Rect","Point","Line","Curve","types","extend","Path","arg","parse","segments","i","n","Array","isArray","length","reduce","acc","val","concat","isSegment","segment","appendSegment","previousObj","obj","Error","createSegment","start","end","equals","controlPoint1","controlPoint2","points","point","pathData","path","commandRe","commands","match","numCommands","command","argRe","args","apply","type","segmentConstructor","segmentTypes","arguments","push","applyToNew","prototype","numSegments","currentSegment","previousSegment","nextSegment","prepareSegment","currentArg","bbox","isVisible","segmentBBox","union","lastSegment","x","y","clone","closestPoint","p","opt","t","closestPointT","pointAtT","closestPointLength","precision","undefined","PRECISION","segmentSubdivisions","getSegmentSubdivisions","localOpt","lengthAtT","closestPointNormalizedLength","cpLength","minSquaredDistance","Infinity","subdivisions","segmentClosestPointT","segmentClosestPoint","squaredDistance","squaredLength","segmentIndex","value","closestPointTangent","isDifferentiable","tangentAtT","containsPoint","polylines","toPolylines","numPolylines","numIntersections","polyline","divideAt","ratio","pathLength","divideAtLength","fromStart","l","divided","dividedSegmentIndex","lastValidSegment","lastValidSegmentIndex","index","getSegment","d","divideAtT","pathCopy","replaceSegment","divisionStartIndex","divisionMidIndex","divisionEndIndex","removeSegment","movetoEnd","insertSegment","secondPathSegmentIndexConversion","originalSegment","subpathStartSegment","convertedSegment","firstPath","slice","secondPath","otherSegments","otherSegment","getSubdivisions","getSubpaths","validatedPath","validate","subpaths","isSubpathStart","splice","intersectionWithLine","line","intersection","polylineIntersection","intersect","isValid","tValue","precisison","pointAt","pointAtLength","lastVisibleSegment","updateSubpathStart","updateSubpathStartSegment","removedSegment","replacedSegment","round","scale","sx","sy","origin","segmentAt","segmentIndexAt","segmentAtLength","segmentIndexAtLength","lastVisibleSegmentIndex","serialize","toString","tangentAt","tangentAtLength","toPoints","partialPoints","currentSegmentSubdivisions","subdivisionPoints","map","curve","trim","translate","tx","ty","Object","defineProperty","configurable","enumerable","get","constructor","argsArray","unshift","Function","bind","segmentPrototype","writable","Lineto","outputArray","segmentCoords","segmentPoint","linetoPrototype","Curveto","segmentPoints","curvetoPrototype","control1","control2","c1","c2","Moveto","movetoPrototype","m","Closepath","closepathPrototype","L","C","M","Z","z","regexSupportedData","RegExp","keys","join","isDataSupported","data","test"],"sources":["C:/Users/Admin/dataflow-test/node_modules/jointjs/src/g/path.mjs"],"sourcesContent":["// Accepts path data string, array of segments, array of Curves and/or Lines, or a Polyline.\n// Path created is not guaranteed to be a valid (serializable) path (might not start with an M).\nimport { Polyline } from './polyline.mjs';\nimport { Rect } from './rect.mjs';\nimport { Point } from './point.mjs';\nimport { Line } from './line.mjs';\nimport { Curve } from './curve.mjs';\nimport { types } from './types.mjs';\nimport { extend } from './extend.mjs';\nexport const Path = function(arg) {\n\n    if (!(this instanceof Path)) {\n        return new Path(arg);\n    }\n\n    if (typeof arg === 'string') { // create from a path data string\n        return new Path.parse(arg);\n    }\n\n    this.segments = [];\n\n    var i;\n    var n;\n\n    if (!arg) {\n        // don't do anything\n\n    } else if (Array.isArray(arg) && arg.length !== 0) { // if arg is a non-empty array\n        // flatten one level deep\n        // so we can chain arbitrary Path.createSegment results\n        arg = arg.reduce(function(acc, val) {\n            return acc.concat(val);\n        }, []);\n\n        n = arg.length;\n        if (arg[0].isSegment) { // create from an array of segments\n            for (i = 0; i < n; i++) {\n\n                var segment = arg[i];\n\n                this.appendSegment(segment);\n            }\n\n        } else { // create from an array of Curves and/or Lines\n            var previousObj = null;\n            for (i = 0; i < n; i++) {\n\n                var obj = arg[i];\n\n                if (!((obj instanceof Line) || (obj instanceof Curve))) {\n                    throw new Error('Cannot construct a path segment from the provided object.');\n                }\n\n                if (i === 0) this.appendSegment(Path.createSegment('M', obj.start));\n\n                // if objects do not link up, moveto segments are inserted to cover the gaps\n                if (previousObj && !previousObj.end.equals(obj.start)) this.appendSegment(Path.createSegment('M', obj.start));\n\n                if (obj instanceof Line) {\n                    this.appendSegment(Path.createSegment('L', obj.end));\n\n                } else if (obj instanceof Curve) {\n                    this.appendSegment(Path.createSegment('C', obj.controlPoint1, obj.controlPoint2, obj.end));\n                }\n\n                previousObj = obj;\n            }\n        }\n\n    } else if (arg.isSegment) { // create from a single segment\n        this.appendSegment(arg);\n\n    } else if (arg instanceof Line) { // create from a single Line\n        this.appendSegment(Path.createSegment('M', arg.start));\n        this.appendSegment(Path.createSegment('L', arg.end));\n\n    } else if (arg instanceof Curve) { // create from a single Curve\n        this.appendSegment(Path.createSegment('M', arg.start));\n        this.appendSegment(Path.createSegment('C', arg.controlPoint1, arg.controlPoint2, arg.end));\n\n    } else if (arg instanceof Polyline) { // create from a Polyline\n        if (!(arg.points && (arg.points.length !== 0))) return; // if Polyline has no points, leave Path empty\n\n        n = arg.points.length;\n        for (i = 0; i < n; i++) {\n\n            var point = arg.points[i];\n\n            if (i === 0) this.appendSegment(Path.createSegment('M', point));\n            else this.appendSegment(Path.createSegment('L', point));\n        }\n\n    } else { // unknown object\n        throw new Error('Cannot construct a path from the provided object.');\n    }\n};\n\n// More permissive than V.normalizePathData and Path.prototype.serialize.\n// Allows path data strings that do not start with a Moveto command (unlike SVG specification).\n// Does not require spaces between elements; commas are allowed, separators may be omitted when unambiguous (e.g. 'ZM10,10', 'L1.6.8', 'M100-200').\n// Allows for command argument chaining.\n// Throws an error if wrong number of arguments is provided with a command.\n// Throws an error if an unrecognized path command is provided (according to Path.segmentTypes). Only a subset of SVG commands is currently supported (L, C, M, Z).\nPath.parse = function(pathData) {\n\n    if (!pathData) return new Path();\n\n    var path = new Path();\n\n    var commandRe = /(?:[a-zA-Z] *)(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)? *,? *)|(?:-?\\.\\d+ *,? *))+|(?:[a-zA-Z] *)(?! |\\d|-|\\.)/g;\n    var commands = pathData.match(commandRe);\n\n    var numCommands = commands.length;\n    for (var i = 0; i < numCommands; i++) {\n\n        var command = commands[i];\n        var argRe = /(?:[a-zA-Z])|(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)?))|(?:(?:-?\\.\\d+))/g;\n        var args = command.match(argRe);\n\n        var segment = Path.createSegment.apply(this, args); // args = [type, coordinate1, coordinate2...]\n        path.appendSegment(segment);\n    }\n\n    return path;\n};\n\n// Create a segment or an array of segments.\n// Accepts unlimited points/coords arguments after `type`.\nPath.createSegment = function(type) {\n\n    if (!type) throw new Error('Type must be provided.');\n\n    var segmentConstructor = Path.segmentTypes[type];\n    if (!segmentConstructor) throw new Error(type + ' is not a recognized path segment type.');\n\n    var args = [];\n    var n = arguments.length;\n    for (var i = 1; i < n; i++) { // do not add first element (`type`) to args array\n        args.push(arguments[i]);\n    }\n\n    return applyToNew(segmentConstructor, args);\n};\n\nPath.prototype = {\n\n    type: types.Path,\n\n    // Accepts one segment or an array of segments as argument.\n    // Throws an error if argument is not a segment or an array of segments.\n    appendSegment: function(arg) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        // works even if path has no segments\n\n        var currentSegment;\n\n        var previousSegment = ((numSegments !== 0) ? segments[numSegments - 1] : null); // if we are appending to an empty path, previousSegment is null\n        var nextSegment = null;\n\n        if (!Array.isArray(arg)) { // arg is a segment\n            if (!arg || !arg.isSegment) throw new Error('Segment required.');\n\n            currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);\n            segments.push(currentSegment);\n\n        } else { // arg is an array of segments\n            // flatten one level deep\n            // so we can chain arbitrary Path.createSegment results\n            arg = arg.reduce(function(acc, val) {\n                return acc.concat(val);\n            }, []);\n\n            if (!arg[0].isSegment) throw new Error('Segments required.');\n\n            var n = arg.length;\n            for (var i = 0; i < n; i++) {\n\n                var currentArg = arg[i];\n                currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);\n                segments.push(currentSegment);\n                previousSegment = currentSegment;\n            }\n        }\n    },\n\n    // Returns the bbox of the path.\n    // If path has no segments, returns null.\n    // If path has only invisible segments, returns bbox of the end point of last segment.\n    bbox: function() {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        var bbox;\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            if (segment.isVisible) {\n                var segmentBBox = segment.bbox();\n                bbox = bbox ? bbox.union(segmentBBox) : segmentBBox;\n            }\n        }\n\n        if (bbox) return bbox;\n\n        // if the path has only invisible elements, return end point of last segment\n        var lastSegment = segments[numSegments - 1];\n        return new Rect(lastSegment.end.x, lastSegment.end.y, 0, 0);\n    },\n\n    // Returns a new path that is a clone of this path.\n    clone: function() {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        // works even if path has no segments\n\n        var path = new Path();\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i].clone();\n            path.appendSegment(segment);\n        }\n\n        return path;\n    },\n\n    closestPoint: function(p, opt) {\n\n        var t = this.closestPointT(p, opt);\n        if (!t) return null;\n\n        return this.pointAtT(t);\n    },\n\n    closestPointLength: function(p, opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n        var t = this.closestPointT(p, localOpt);\n        if (!t) return 0;\n\n        return this.lengthAtT(t, localOpt);\n    },\n\n    closestPointNormalizedLength: function(p, opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n        var cpLength = this.closestPointLength(p, localOpt);\n        if (cpLength === 0) return 0; // shortcut\n\n        var length = this.length(localOpt);\n        if (length === 0) return 0; // prevents division by zero\n\n        return cpLength / length;\n    },\n\n    // Private function.\n    closestPointT: function(p, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var closestPointT;\n        var minSquaredDistance = Infinity;\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            var subdivisions = segmentSubdivisions[i];\n\n            if (segment.isVisible) {\n                var segmentClosestPointT = segment.closestPointT(p, {\n                    precision: precision,\n                    subdivisions: subdivisions\n                });\n                var segmentClosestPoint = segment.pointAtT(segmentClosestPointT);\n                var squaredDistance = (new Line(segmentClosestPoint, p)).squaredLength();\n\n                if (squaredDistance < minSquaredDistance) {\n                    closestPointT = { segmentIndex: i, value: segmentClosestPointT };\n                    minSquaredDistance = squaredDistance;\n                }\n            }\n        }\n\n        if (closestPointT) return closestPointT;\n\n        // if no visible segment, return end of last segment\n        return { segmentIndex: numSegments - 1, value: 1 };\n    },\n\n    closestPointTangent: function(p, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var closestPointTangent;\n        var minSquaredDistance = Infinity;\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            var subdivisions = segmentSubdivisions[i];\n\n            if (segment.isDifferentiable()) {\n                var segmentClosestPointT = segment.closestPointT(p, {\n                    precision: precision,\n                    subdivisions: subdivisions\n                });\n                var segmentClosestPoint = segment.pointAtT(segmentClosestPointT);\n                var squaredDistance = (new Line(segmentClosestPoint, p)).squaredLength();\n\n                if (squaredDistance < minSquaredDistance) {\n                    closestPointTangent = segment.tangentAtT(segmentClosestPointT);\n                    minSquaredDistance = squaredDistance;\n                }\n            }\n        }\n\n        if (closestPointTangent) return closestPointTangent;\n\n        // if no valid segment, return null\n        return null;\n    },\n\n    // Returns `true` if the area surrounded by the path contains the point `p`.\n    // Implements the even-odd algorithm (self-intersections are \"outside\").\n    // Closes open paths (always imagines a final closing segment).\n    // Precision may be adjusted by passing an `opt` object.\n    containsPoint: function(p, opt) {\n\n        var polylines = this.toPolylines(opt);\n        if (!polylines) return false; // shortcut (this path has no polylines)\n\n        var numPolylines = polylines.length;\n\n        // how many component polylines does `p` lie within?\n        var numIntersections = 0;\n        for (var i = 0; i < numPolylines; i++) {\n            var polyline = polylines[i];\n            if (polyline.containsPoint(p)) {\n                // `p` lies within this polyline\n                numIntersections++;\n            }\n        }\n\n        // returns `true` for odd numbers of intersections (even-odd algorithm)\n        return ((numIntersections % 2) === 1);\n    },\n\n    // Divides the path into two at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.\n    divideAt: function(ratio, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        if (ratio < 0) ratio = 0;\n        if (ratio > 1) ratio = 1;\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n        var pathLength = this.length(localOpt);\n        var length = pathLength * ratio;\n\n        return this.divideAtLength(length, localOpt);\n    },\n\n    // Divides the path into two at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n    divideAtLength: function(length, opt) {\n\n        var numSegments = this.segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var i;\n        var segment;\n\n        // identify the segment to divide:\n\n        var l = 0; // length so far\n        var divided;\n        var dividedSegmentIndex;\n        var lastValidSegment; // visible AND differentiable\n        var lastValidSegmentIndex;\n        var t;\n        for (i = 0; i < numSegments; i++) {\n            var index = (fromStart ? i : (numSegments - 1 - i));\n\n            segment = this.getSegment(index);\n            var subdivisions = segmentSubdivisions[index];\n            var d = segment.length({ precision: precision, subdivisions: subdivisions });\n\n            if (segment.isDifferentiable()) { // segment is not just a point\n                lastValidSegment = segment;\n                lastValidSegmentIndex = index;\n\n                if (length <= (l + d)) {\n                    dividedSegmentIndex = index;\n                    divided = segment.divideAtLength(((fromStart ? 1 : -1) * (length - l)), {\n                        precision: precision,\n                        subdivisions: subdivisions\n                    });\n                    break;\n                }\n            }\n\n            l += d;\n        }\n\n        if (!lastValidSegment) { // no valid segment found\n            return null;\n        }\n\n        // else: the path contains at least one valid segment\n\n        if (!divided) { // the desired length is greater than the length of the path\n            dividedSegmentIndex = lastValidSegmentIndex;\n            t = (fromStart ? 1 : 0);\n            divided = lastValidSegment.divideAtT(t);\n        }\n\n        // create a copy of this path and replace the identified segment with its two divided parts:\n\n        var pathCopy = this.clone();\n        pathCopy.replaceSegment(dividedSegmentIndex, divided);\n\n        var divisionStartIndex = dividedSegmentIndex;\n        var divisionMidIndex = dividedSegmentIndex + 1;\n        var divisionEndIndex = dividedSegmentIndex + 2;\n\n        // do not insert the part if it looks like a point\n        if (!divided[0].isDifferentiable()) {\n            pathCopy.removeSegment(divisionStartIndex);\n            divisionMidIndex -= 1;\n            divisionEndIndex -= 1;\n        }\n\n        // insert a Moveto segment to ensure secondPath will be valid:\n        var movetoEnd = pathCopy.getSegment(divisionMidIndex).start;\n        pathCopy.insertSegment(divisionMidIndex, Path.createSegment('M', movetoEnd));\n        divisionEndIndex += 1;\n\n        // do not insert the part if it looks like a point\n        if (!divided[1].isDifferentiable()) {\n            pathCopy.removeSegment(divisionEndIndex - 1);\n            divisionEndIndex -= 1;\n        }\n\n        // ensure that Closepath segments in secondPath will be assigned correct subpathStartSegment:\n\n        var secondPathSegmentIndexConversion = divisionEndIndex - divisionStartIndex - 1;\n        for (i = divisionEndIndex; i < pathCopy.segments.length; i++) {\n\n            var originalSegment = this.getSegment(i - secondPathSegmentIndexConversion);\n            segment = pathCopy.getSegment(i);\n\n            if ((segment.type === 'Z') && !originalSegment.subpathStartSegment.end.equals(segment.subpathStartSegment.end)) {\n                // pathCopy segment's subpathStartSegment is different from original segment's one\n                // convert this Closepath segment to a Lineto and replace it in pathCopy\n                var convertedSegment = Path.createSegment('L', originalSegment.end);\n                pathCopy.replaceSegment(i, convertedSegment);\n            }\n        }\n\n        // distribute pathCopy segments into two paths and return those:\n\n        var firstPath = new Path(pathCopy.segments.slice(0, divisionMidIndex));\n        var secondPath = new Path(pathCopy.segments.slice(divisionMidIndex));\n\n        return [firstPath, secondPath];\n    },\n\n    // Checks whether two paths are exactly the same.\n    // If `p` is undefined or null, returns false.\n    equals: function(p) {\n\n        if (!p) return false;\n\n        var segments = this.segments;\n        var otherSegments = p.segments;\n\n        var numSegments = segments.length;\n        if (otherSegments.length !== numSegments) return false; // if the two paths have different number of segments, they cannot be equal\n\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            var otherSegment = otherSegments[i];\n\n            // as soon as an inequality is found in segments, return false\n            if ((segment.type !== otherSegment.type) || (!segment.equals(otherSegment))) return false;\n        }\n\n        // if no inequality found in segments, return true\n        return true;\n    },\n\n    // Accepts negative indices.\n    // Throws an error if path has no segments.\n    // Throws an error if index is out of range.\n    getSegment: function(index) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) throw new Error('Path has no segments.');\n\n        if (index < 0) index = numSegments + index; // convert negative indices to positive\n        if (index >= numSegments || index < 0) throw new Error('Index out of range.');\n\n        return segments[index];\n    },\n\n    // Returns an array of segment subdivisions, with precision better than requested `opt.precision`.\n    getSegmentSubdivisions: function(opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        // works even if path has no segments\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        // not using opt.segmentSubdivisions\n        // not using localOpt\n\n        var segmentSubdivisions = [];\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            var subdivisions = segment.getSubdivisions({ precision: precision });\n            segmentSubdivisions.push(subdivisions);\n        }\n\n        return segmentSubdivisions;\n    },\n\n    // Returns an array of subpaths of this path.\n    // Invalid paths are validated first.\n    // Returns `[]` if path has no segments.\n    getSubpaths: function() {\n\n        const validatedPath = this.clone().validate();\n\n        const segments = validatedPath.segments;\n        const numSegments = segments.length;\n\n        const subpaths = [];\n        for (let i = 0; i < numSegments; i++) {\n\n            const segment = segments[i];\n            if (segment.isSubpathStart) {\n                // we encountered a subpath start segment\n                // create a new path for segment, and push it to list of subpaths\n                subpaths.push(new Path(segment));\n\n            } else {\n                // append current segment to the last subpath\n                subpaths[subpaths.length - 1].appendSegment(segment);\n            }\n        }\n\n        return subpaths;\n    },\n\n    // Insert `arg` at given `index`.\n    // `index = 0` means insert at the beginning.\n    // `index = segments.length` means insert at the end.\n    // Accepts negative indices, from `-1` to `-(segments.length + 1)`.\n    // Accepts one segment or an array of segments as argument.\n    // Throws an error if index is out of range.\n    // Throws an error if argument is not a segment or an array of segments.\n    insertSegment: function(index, arg) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        // works even if path has no segments\n\n        // note that these are incremented compared to getSegments()\n        // we can insert after last element (note that this changes the meaning of index -1)\n        if (index < 0) index = numSegments + index + 1; // convert negative indices to positive\n        if (index > numSegments || index < 0) throw new Error('Index out of range.');\n\n        var currentSegment;\n\n        var previousSegment = null;\n        var nextSegment = null;\n\n        if (numSegments !== 0) {\n            if (index >= 1) {\n                previousSegment = segments[index - 1];\n                nextSegment = previousSegment.nextSegment; // if we are inserting at end, nextSegment is null\n\n            } else { // if index === 0\n                // previousSegment is null\n                nextSegment = segments[0];\n            }\n        }\n\n        if (!Array.isArray(arg)) {\n            if (!arg || !arg.isSegment) throw new Error('Segment required.');\n\n            currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);\n            segments.splice(index, 0, currentSegment);\n\n        } else {\n            // flatten one level deep\n            // so we can chain arbitrary Path.createSegment results\n            arg = arg.reduce(function(acc, val) {\n                return acc.concat(val);\n            }, []);\n\n            if (!arg[0].isSegment) throw new Error('Segments required.');\n\n            var n = arg.length;\n            for (var i = 0; i < n; i++) {\n\n                var currentArg = arg[i];\n                currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);\n                segments.splice((index + i), 0, currentSegment); // incrementing index to insert subsequent segments after inserted segments\n                previousSegment = currentSegment;\n            }\n        }\n    },\n\n    intersectionWithLine: function(line, opt) {\n\n        var intersection = null;\n        var polylines = this.toPolylines(opt);\n        if (!polylines) return null;\n        for (var i = 0, n = polylines.length; i < n; i++) {\n            var polyline = polylines[i];\n            var polylineIntersection = line.intersect(polyline);\n            if (polylineIntersection) {\n                intersection || (intersection = []);\n                if (Array.isArray(polylineIntersection)) {\n                    Array.prototype.push.apply(intersection, polylineIntersection);\n                } else {\n                    intersection.push(polylineIntersection);\n                }\n            }\n        }\n\n        return intersection;\n    },\n\n    isDifferentiable: function() {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            // as soon as a differentiable segment is found in segments, return true\n            if (segment.isDifferentiable()) return true;\n        }\n\n        // if no differentiable segment is found in segments, return false\n        return false;\n    },\n\n    // Checks whether current path segments are valid.\n    // Note that d is allowed to be empty - should disable rendering of the path.\n    isValid: function() {\n\n        var segments = this.segments;\n        var isValid = (segments.length === 0) || (segments[0].type === 'M'); // either empty or first segment is a Moveto\n        return isValid;\n    },\n\n    // Returns length of the path, with precision better than requested `opt.precision`; or using `opt.segmentSubdivisions` provided.\n    // If path has no segments, returns 0.\n    length: function(opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return 0; // if segments is an empty array\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision; // opt.precision only used in getSegmentSubdivisions() call\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var length = 0;\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            var subdivisions = segmentSubdivisions[i];\n            length += segment.length({ subdivisions: subdivisions });\n        }\n\n        return length;\n    },\n\n    // Private function.\n    lengthAtT: function(t, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return 0; // if segments is an empty array\n\n        var segmentIndex = t.segmentIndex;\n        if (segmentIndex < 0) return 0; // regardless of t.value\n\n        var tValue = t.value;\n        if (segmentIndex >= numSegments) {\n            segmentIndex = numSegments - 1;\n            tValue = 1;\n        } else if (tValue < 0) tValue = 0;\n        else if (tValue > 1) tValue = 1;\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var subdivisions;\n        var length = 0;\n        for (var i = 0; i < segmentIndex; i++) {\n\n            var segment = segments[i];\n            subdivisions = segmentSubdivisions[i];\n            length += segment.length({ precisison: precision, subdivisions: subdivisions });\n        }\n\n        segment = segments[segmentIndex];\n        subdivisions = segmentSubdivisions[segmentIndex];\n        length += segment.lengthAtT(tValue, { precisison: precision, subdivisions: subdivisions });\n\n        return length;\n    },\n\n    // Returns point at requested `ratio` between 0 and 1, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n    pointAt: function(ratio, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        if (ratio <= 0) return this.start.clone();\n        if (ratio >= 1) return this.end.clone();\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n        var pathLength = this.length(localOpt);\n        var length = pathLength * ratio;\n\n        return this.pointAtLength(length, localOpt);\n    },\n\n    // Returns point at requested `length`, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n    // Accepts negative length.\n    pointAtLength: function(length, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        if (length === 0) return this.start.clone();\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var lastVisibleSegment;\n        var l = 0; // length so far\n        for (var i = 0; i < numSegments; i++) {\n            var index = (fromStart ? i : (numSegments - 1 - i));\n\n            var segment = segments[index];\n            var subdivisions = segmentSubdivisions[index];\n            var d = segment.length({ precision: precision, subdivisions: subdivisions });\n\n            if (segment.isVisible) {\n                if (length <= (l + d)) {\n                    return segment.pointAtLength(((fromStart ? 1 : -1) * (length - l)), {\n                        precision: precision,\n                        subdivisions: subdivisions\n                    });\n                }\n\n                lastVisibleSegment = segment;\n            }\n\n            l += d;\n        }\n\n        // if length requested is higher than the length of the path, return last visible segment endpoint\n        if (lastVisibleSegment) return (fromStart ? lastVisibleSegment.end : lastVisibleSegment.start);\n\n        // if no visible segment, return last segment end point (no matter if fromStart or no)\n        var lastSegment = segments[numSegments - 1];\n        return lastSegment.end.clone();\n    },\n\n    // Private function.\n    pointAtT: function(t) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        var segmentIndex = t.segmentIndex;\n        if (segmentIndex < 0) return segments[0].pointAtT(0);\n        if (segmentIndex >= numSegments) return segments[numSegments - 1].pointAtT(1);\n\n        var tValue = t.value;\n        if (tValue < 0) tValue = 0;\n        else if (tValue > 1) tValue = 1;\n\n        return segments[segmentIndex].pointAtT(tValue);\n    },\n\n    // Default precision\n    PRECISION: 3,\n\n    // Helper method for adding segments.\n    prepareSegment: function(segment, previousSegment, nextSegment) {\n\n        // insert after previous segment and before previous segment's next segment\n        segment.previousSegment = previousSegment;\n        segment.nextSegment = nextSegment;\n        if (previousSegment) previousSegment.nextSegment = segment;\n        if (nextSegment) nextSegment.previousSegment = segment;\n\n        var updateSubpathStart = segment;\n        if (segment.isSubpathStart) {\n            segment.subpathStartSegment = segment; // assign self as subpath start segment\n            updateSubpathStart = nextSegment; // start updating from next segment\n        }\n\n        // assign previous segment's subpath start (or self if it is a subpath start) to subsequent segments\n        if (updateSubpathStart) this.updateSubpathStartSegment(updateSubpathStart);\n\n        return segment;\n    },\n\n    // Remove the segment at `index`.\n    // Accepts negative indices, from `-1` to `-segments.length`.\n    // Throws an error if path has no segments.\n    // Throws an error if index is out of range.\n    removeSegment: function(index) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) throw new Error('Path has no segments.');\n\n        if (index < 0) index = numSegments + index; // convert negative indices to positive\n        if (index >= numSegments || index < 0) throw new Error('Index out of range.');\n\n        var removedSegment = segments.splice(index, 1)[0];\n        var previousSegment = removedSegment.previousSegment;\n        var nextSegment = removedSegment.nextSegment;\n\n        // link the previous and next segments together (if present)\n        if (previousSegment) previousSegment.nextSegment = nextSegment; // may be null\n        if (nextSegment) nextSegment.previousSegment = previousSegment; // may be null\n\n        // if removed segment used to start a subpath, update all subsequent segments until another subpath start segment is reached\n        if (removedSegment.isSubpathStart && nextSegment) this.updateSubpathStartSegment(nextSegment);\n    },\n\n    // Replace the segment at `index` with `arg`.\n    // Accepts negative indices, from `-1` to `-segments.length`.\n    // Accepts one segment or an array of segments as argument.\n    // Throws an error if path has no segments.\n    // Throws an error if index is out of range.\n    // Throws an error if argument is not a segment or an array of segments.\n    replaceSegment: function(index, arg) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) throw new Error('Path has no segments.');\n\n        if (index < 0) index = numSegments + index; // convert negative indices to positive\n        if (index >= numSegments || index < 0) throw new Error('Index out of range.');\n\n        var currentSegment;\n\n        var replacedSegment = segments[index];\n        var previousSegment = replacedSegment.previousSegment;\n        var nextSegment = replacedSegment.nextSegment;\n\n        var updateSubpathStart = replacedSegment.isSubpathStart; // boolean: is an update of subpath starts necessary?\n\n        if (!Array.isArray(arg)) {\n            if (!arg || !arg.isSegment) throw new Error('Segment required.');\n\n            currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);\n            segments.splice(index, 1, currentSegment); // directly replace\n\n            if (updateSubpathStart && currentSegment.isSubpathStart) updateSubpathStart = false; // already updated by `prepareSegment`\n\n        } else {\n            // flatten one level deep\n            // so we can chain arbitrary Path.createSegment results\n            arg = arg.reduce(function(acc, val) {\n                return acc.concat(val);\n            }, []);\n\n            if (!arg[0].isSegment) throw new Error('Segments required.');\n\n            segments.splice(index, 1);\n\n            var n = arg.length;\n            for (var i = 0; i < n; i++) {\n\n                var currentArg = arg[i];\n                currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);\n                segments.splice((index + i), 0, currentSegment); // incrementing index to insert subsequent segments after inserted segments\n                previousSegment = currentSegment;\n\n                if (updateSubpathStart && currentSegment.isSubpathStart) updateSubpathStart = false; // already updated by `prepareSegment`\n            }\n        }\n\n        // if replaced segment used to start a subpath and no new subpath start was added, update all subsequent segments until another subpath start segment is reached\n        if (updateSubpathStart && nextSegment) this.updateSubpathStartSegment(nextSegment);\n    },\n\n    round: function(precision) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            segment.round(precision);\n        }\n\n        return this;\n    },\n\n    scale: function(sx, sy, origin) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            segment.scale(sx, sy, origin);\n        }\n\n        return this;\n    },\n\n    segmentAt: function(ratio, opt) {\n\n        var index = this.segmentIndexAt(ratio, opt);\n        if (!index) return null;\n\n        return this.getSegment(index);\n    },\n\n    // Accepts negative length.\n    segmentAtLength: function(length, opt) {\n\n        var index = this.segmentIndexAtLength(length, opt);\n        if (!index) return null;\n\n        return this.getSegment(index);\n    },\n\n    segmentIndexAt: function(ratio, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        if (ratio < 0) ratio = 0;\n        if (ratio > 1) ratio = 1;\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n        var pathLength = this.length(localOpt);\n        var length = pathLength * ratio;\n\n        return this.segmentIndexAtLength(length, localOpt);\n    },\n\n    // Accepts negative length.\n    segmentIndexAtLength: function(length, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var lastVisibleSegmentIndex = null;\n        var l = 0; // length so far\n        for (var i = 0; i < numSegments; i++) {\n            var index = (fromStart ? i : (numSegments - 1 - i));\n\n            var segment = segments[index];\n            var subdivisions = segmentSubdivisions[index];\n            var d = segment.length({ precision: precision, subdivisions: subdivisions });\n\n            if (segment.isVisible) {\n                if (length <= (l + d)) return index;\n                lastVisibleSegmentIndex = index;\n            }\n\n            l += d;\n        }\n\n        // if length requested is higher than the length of the path, return last visible segment index\n        // if no visible segment, return null\n        return lastVisibleSegmentIndex;\n    },\n\n    // Returns a string that can be used to reconstruct the path.\n    // Additional error checking compared to toString (must start with M segment).\n    serialize: function() {\n\n        if (!this.isValid()) throw new Error('Invalid path segments.');\n\n        return this.toString();\n    },\n\n    // Returns tangent line at requested `ratio` between 0 and 1, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n    tangentAt: function(ratio, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        if (ratio < 0) ratio = 0;\n        if (ratio > 1) ratio = 1;\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n        var pathLength = this.length(localOpt);\n        var length = pathLength * ratio;\n\n        return this.tangentAtLength(length, localOpt);\n    },\n\n    // Returns tangent line at requested `length`, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n    // Accepts negative length.\n    tangentAtLength: function(length, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var lastValidSegment; // visible AND differentiable (with a tangent)\n        var l = 0; // length so far\n        for (var i = 0; i < numSegments; i++) {\n            var index = (fromStart ? i : (numSegments - 1 - i));\n\n            var segment = segments[index];\n            var subdivisions = segmentSubdivisions[index];\n            var d = segment.length({ precision: precision, subdivisions: subdivisions });\n\n            if (segment.isDifferentiable()) {\n                if (length <= (l + d)) {\n                    return segment.tangentAtLength(((fromStart ? 1 : -1) * (length - l)), {\n                        precision: precision,\n                        subdivisions: subdivisions\n                    });\n                }\n\n                lastValidSegment = segment;\n            }\n\n            l += d;\n        }\n\n        // if length requested is higher than the length of the path, return tangent of endpoint of last valid segment\n        if (lastValidSegment) {\n            var t = (fromStart ? 1 : 0);\n            return lastValidSegment.tangentAtT(t);\n        }\n\n        // if no valid segment, return null\n        return null;\n    },\n\n    // Private function.\n    tangentAtT: function(t) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        var segmentIndex = t.segmentIndex;\n        if (segmentIndex < 0) return segments[0].tangentAtT(0);\n        if (segmentIndex >= numSegments) return segments[numSegments - 1].tangentAtT(1);\n\n        var tValue = t.value;\n        if (tValue < 0) tValue = 0;\n        else if (tValue > 1) tValue = 1;\n\n        return segments[segmentIndex].tangentAtT(tValue);\n    },\n\n    toPoints: function(opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n\n        var points = [];\n        var partialPoints = [];\n        for (var i = 0; i < numSegments; i++) {\n            var segment = segments[i];\n            if (segment.isVisible) {\n                var currentSegmentSubdivisions = segmentSubdivisions[i];\n                if (currentSegmentSubdivisions.length > 0) {\n                    var subdivisionPoints = currentSegmentSubdivisions.map(function(curve) {\n                        return curve.start;\n                    });\n                    Array.prototype.push.apply(partialPoints, subdivisionPoints);\n                } else {\n                    partialPoints.push(segment.start);\n                }\n            } else if (partialPoints.length > 0) {\n                partialPoints.push(segments[i - 1].end);\n                points.push(partialPoints);\n                partialPoints = [];\n            }\n        }\n\n        if (partialPoints.length > 0) {\n            partialPoints.push(this.end);\n            points.push(partialPoints);\n        }\n        return points;\n    },\n\n    toPolylines: function(opt) {\n\n        var polylines = [];\n        var points = this.toPoints(opt);\n        if (!points) return null;\n        for (var i = 0, n = points.length; i < n; i++) {\n            polylines.push(new Polyline(points[i]));\n        }\n\n        return polylines;\n    },\n\n    toString: function() {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n\n        var pathData = '';\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            pathData += segment.serialize() + ' ';\n        }\n\n        return pathData.trim();\n    },\n\n    translate: function(tx, ty) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            segment.translate(tx, ty);\n        }\n\n        return this;\n    },\n\n    // Helper method for updating subpath start of segments, starting with the one provided.\n    updateSubpathStartSegment: function(segment) {\n\n        var previousSegment = segment.previousSegment; // may be null\n        while (segment && !segment.isSubpathStart) {\n\n            // assign previous segment's subpath start segment to this segment\n            if (previousSegment) segment.subpathStartSegment = previousSegment.subpathStartSegment; // may be null\n            else segment.subpathStartSegment = null; // if segment had no previous segment, assign null - creates an invalid path!\n\n            previousSegment = segment;\n            segment = segment.nextSegment; // move on to the segment after etc.\n        }\n    },\n\n    // If the path is not valid, insert M 0 0 at the beginning.\n    // Path with no segments is considered valid, so nothing is inserted.\n    validate: function() {\n\n        if (!this.isValid()) this.insertSegment(0, Path.createSegment('M', 0, 0));\n        return this;\n    }\n};\n\nObject.defineProperty(Path.prototype, 'start', {\n    // Getter for the first visible endpoint of the path.\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null;\n\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            if (segment.isVisible) return segment.start;\n        }\n\n        // if no visible segment, return last segment end point\n        return segments[numSegments - 1].end;\n    }\n});\n\nObject.defineProperty(Path.prototype, 'end', {\n    // Getter for the last visible endpoint of the path.\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null;\n\n        for (var i = numSegments - 1; i >= 0; i--) {\n\n            var segment = segments[i];\n            if (segment.isVisible) return segment.end;\n        }\n\n        // if no visible segment, return last segment end point\n        return segments[numSegments - 1].end;\n    }\n});\n\n\n// Local helper function.\n// Use an array of arguments to call a constructor (function called with `new`).\n// Adapted from https://stackoverflow.com/a/8843181/2263595\n// It is not necessary to use this function if the arguments can be passed separately (i.e. if the number of arguments is limited).\n// - If that is the case, use `new constructor(arg1, arg2)`, for example.\n// It is not necessary to use this function if the function that needs an array of arguments is not supposed to be used as a constructor.\n// - If that is the case, use `f.apply(thisArg, [arg1, arg2...])`, for example.\nfunction applyToNew(constructor, argsArray) {\n    // The `new` keyword can only be applied to functions that take a limited number of arguments.\n    // - We can fake that with .bind().\n    // - It calls a function (`constructor`, here) with the arguments that were provided to it - effectively transforming an unlimited number of arguments into limited.\n    // - So `new (constructor.bind(thisArg, arg1, arg2...))`\n    // - `thisArg` can be anything (e.g. null) because `new` keyword resets context to the constructor object.\n    // We need to pass in a variable number of arguments to the bind() call.\n    // - We can use .apply().\n    // - So `new (constructor.bind.apply(constructor, [thisArg, arg1, arg2...]))`\n    // - `thisArg` can still be anything because `new` overwrites it.\n    // Finally, to make sure that constructor.bind overwriting is not a problem, we switch to `Function.prototype.bind`.\n    // - So, the final version is `new (Function.prototype.bind.apply(constructor, [thisArg, arg1, arg2...]))`\n\n    // The function expects `argsArray[0]` to be `thisArg`.\n    // - This means that whatever is sent as the first element will be ignored.\n    // - The constructor will only see arguments starting from argsArray[1].\n    // - So, a new dummy element is inserted at the start of the array.\n    argsArray.unshift(null);\n\n    return new (Function.prototype.bind.apply(constructor, argsArray));\n}\n\n// Path segment interface:\nvar segmentPrototype = {\n\n    // virtual\n    bbox: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    clone: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    closestPoint: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    closestPointLength: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    closestPointNormalizedLength: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // Redirect calls to closestPointNormalizedLength() function if closestPointT() is not defined for segment.\n    closestPointT: function(p) {\n\n        if (this.closestPointNormalizedLength) return this.closestPointNormalizedLength(p);\n\n        throw new Error('Neither closestPointT() nor closestPointNormalizedLength() function is implemented.');\n    },\n\n    // virtual\n    closestPointTangent: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    divideAt: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    divideAtLength: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // Redirect calls to divideAt() function if divideAtT() is not defined for segment.\n    divideAtT: function(t) {\n\n        if (this.divideAt) return this.divideAt(t);\n\n        throw new Error('Neither divideAtT() nor divideAt() function is implemented.');\n    },\n\n    // virtual\n    equals: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    getSubdivisions: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    isDifferentiable: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    isSegment: true,\n\n    isSubpathStart: false, // true for Moveto segments\n\n    isVisible: true, // false for Moveto segments\n\n    // virtual\n    length: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // Return a fraction of result of length() function if lengthAtT() is not defined for segment.\n    lengthAtT: function(t) {\n\n        if (t <= 0) return 0;\n\n        var length = this.length();\n\n        if (t >= 1) return length;\n\n        return length * t;\n    },\n\n    nextSegment: null, // needed for subpath start segment updating\n\n    // virtual\n    pointAt: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    pointAtLength: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // Redirect calls to pointAt() function if pointAtT() is not defined for segment.\n    pointAtT: function(t) {\n\n        if (this.pointAt) return this.pointAt(t);\n\n        throw new Error('Neither pointAtT() nor pointAt() function is implemented.');\n    },\n\n    previousSegment: null, // needed to get segment start property\n\n    // virtual\n    round: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    subpathStartSegment: null, // needed to get Closepath segment end property\n\n    // virtual\n    scale: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    serialize: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    tangentAt: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    tangentAtLength: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // Redirect calls to tangentAt() function if tangentAtT() is not defined for segment.\n    tangentAtT: function(t) {\n\n        if (this.tangentAt) return this.tangentAt(t);\n\n        throw new Error('Neither tangentAtT() nor tangentAt() function is implemented.');\n    },\n\n    // virtual\n    toString: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    translate: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    }\n};\n\n// usually directly assigned\n// getter for Closepath\nObject.defineProperty(segmentPrototype, 'end', {\n\n    configurable: true,\n\n    enumerable: true,\n\n    writable: true\n});\n\n// always a getter\n// always throws error for Moveto\nObject.defineProperty(segmentPrototype, 'start', {\n    // get a reference to the end point of previous segment\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        if (!this.previousSegment) throw new Error('Missing previous segment. (This segment cannot be the first segment of a path; OR segment has not yet been added to a path.)');\n\n        return this.previousSegment.end;\n    }\n});\n\n// virtual\nObject.defineProperty(segmentPrototype, 'type', {\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        throw new Error('Bad segment declaration. No type specified.');\n    }\n});\n\n// Path segment implementations:\nvar Lineto = function() {\n\n    var args = [];\n    var n = arguments.length;\n    for (var i = 0; i < n; i++) {\n        args.push(arguments[i]);\n    }\n\n    if (!(this instanceof Lineto)) { // switching context of `this` to Lineto when called without `new`\n        return applyToNew(Lineto, args);\n    }\n\n    if (n === 0) {\n        throw new Error('Lineto constructor expects a line, 1 point, or 2 coordinates (none provided).');\n    }\n\n    var outputArray;\n\n    if (args[0] instanceof Line) { // lines provided\n        if (n === 1) {\n            this.end = args[0].end.clone();\n            return this;\n\n        } else {\n            throw new Error('Lineto constructor expects a line, 1 point, or 2 coordinates (' + n + ' lines provided).');\n        }\n\n    } else if (typeof args[0] === 'string' || typeof args[0] === 'number') { // coordinates provided\n        if (n === 2) {\n            this.end = new Point(+args[0], +args[1]);\n            return this;\n\n        } else if (n < 2) {\n            throw new Error('Lineto constructor expects a line, 1 point, or 2 coordinates (' + n + ' coordinates provided).');\n\n        } else { // this is a poly-line segment\n            var segmentCoords;\n            outputArray = [];\n            for (i = 0; i < n; i += 2) { // coords come in groups of two\n\n                segmentCoords = args.slice(i, i + 2); // will send one coord if args.length not divisible by 2\n                outputArray.push(applyToNew(Lineto, segmentCoords));\n            }\n            return outputArray;\n        }\n\n    } else { // points provided (needs to be last to also cover plain objects with x and y)\n        if (n === 1) {\n            this.end = new Point(args[0]);\n            return this;\n\n        } else { // this is a poly-line segment\n            var segmentPoint;\n            outputArray = [];\n            for (i = 0; i < n; i += 1) {\n\n                segmentPoint = args[i];\n                outputArray.push(new Lineto(segmentPoint));\n            }\n            return outputArray;\n        }\n    }\n};\n\nvar linetoPrototype = {\n\n    clone: function() {\n\n        return new Lineto(this.end);\n    },\n\n    divideAt: function(ratio) {\n\n        var line = new Line(this.start, this.end);\n        var divided = line.divideAt(ratio);\n        return [\n            new Lineto(divided[0]),\n            new Lineto(divided[1])\n        ];\n    },\n\n    divideAtLength: function(length) {\n\n        var line = new Line(this.start, this.end);\n        var divided = line.divideAtLength(length);\n        return [\n            new Lineto(divided[0]),\n            new Lineto(divided[1])\n        ];\n    },\n\n    getSubdivisions: function() {\n\n        return [];\n    },\n\n    isDifferentiable: function() {\n\n        if (!this.previousSegment) return false;\n\n        return !this.start.equals(this.end);\n    },\n\n    round: function(precision) {\n\n        this.end.round(precision);\n        return this;\n    },\n\n    scale: function(sx, sy, origin) {\n\n        this.end.scale(sx, sy, origin);\n        return this;\n    },\n\n    serialize: function() {\n\n        var end = this.end;\n        return this.type + ' ' + end.x + ' ' + end.y;\n    },\n\n    toString: function() {\n\n        return this.type + ' ' + this.start + ' ' + this.end;\n    },\n\n    translate: function(tx, ty) {\n\n        this.end.translate(tx, ty);\n        return this;\n    }\n};\n\nObject.defineProperty(linetoPrototype, 'type', {\n\n    configurable: true,\n\n    enumerable: true,\n\n    value: 'L'\n});\n\nLineto.prototype = extend(segmentPrototype, Line.prototype, linetoPrototype);\n\nvar Curveto = function() {\n\n    var args = [];\n    var n = arguments.length;\n    for (var i = 0; i < n; i++) {\n        args.push(arguments[i]);\n    }\n\n    if (!(this instanceof Curveto)) { // switching context of `this` to Curveto when called without `new`\n        return applyToNew(Curveto, args);\n    }\n\n    if (n === 0) {\n        throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (none provided).');\n    }\n\n    var outputArray;\n\n    if (args[0] instanceof Curve) { // curves provided\n        if (n === 1) {\n            this.controlPoint1 = args[0].controlPoint1.clone();\n            this.controlPoint2 = args[0].controlPoint2.clone();\n            this.end = args[0].end.clone();\n            return this;\n\n        } else {\n            throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (' + n + ' curves provided).');\n        }\n\n    } else if (typeof args[0] === 'string' || typeof args[0] === 'number') { // coordinates provided\n        if (n === 6) {\n            this.controlPoint1 = new Point(+args[0], +args[1]);\n            this.controlPoint2 = new Point(+args[2], +args[3]);\n            this.end = new Point(+args[4], +args[5]);\n            return this;\n\n        } else if (n < 6) {\n            throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (' + n + ' coordinates provided).');\n\n        } else { // this is a poly-bezier segment\n            var segmentCoords;\n            outputArray = [];\n            for (i = 0; i < n; i += 6) { // coords come in groups of six\n\n                segmentCoords = args.slice(i, i + 6); // will send fewer than six coords if args.length not divisible by 6\n                outputArray.push(applyToNew(Curveto, segmentCoords));\n            }\n            return outputArray;\n        }\n\n    } else { // points provided (needs to be last to also cover plain objects with x and y)\n        if (n === 3) {\n            this.controlPoint1 = new Point(args[0]);\n            this.controlPoint2 = new Point(args[1]);\n            this.end = new Point(args[2]);\n            return this;\n\n        } else if (n < 3) {\n            throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (' + n + ' points provided).');\n\n        } else { // this is a poly-bezier segment\n            var segmentPoints;\n            outputArray = [];\n            for (i = 0; i < n; i += 3) { // points come in groups of three\n\n                segmentPoints = args.slice(i, i + 3); // will send fewer than three points if args.length is not divisible by 3\n                outputArray.push(applyToNew(Curveto, segmentPoints));\n            }\n            return outputArray;\n        }\n    }\n};\n\nvar curvetoPrototype = {\n\n    clone: function() {\n\n        return new Curveto(this.controlPoint1, this.controlPoint2, this.end);\n    },\n\n    divideAt: function(ratio, opt) {\n\n        var curve = new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n        var divided = curve.divideAt(ratio, opt);\n        return [\n            new Curveto(divided[0]),\n            new Curveto(divided[1])\n        ];\n    },\n\n    divideAtLength: function(length, opt) {\n\n        var curve = new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n        var divided = curve.divideAtLength(length, opt);\n        return [\n            new Curveto(divided[0]),\n            new Curveto(divided[1])\n        ];\n    },\n\n    divideAtT: function(t) {\n\n        var curve = new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n        var divided = curve.divideAtT(t);\n        return [\n            new Curveto(divided[0]),\n            new Curveto(divided[1])\n        ];\n    },\n\n    isDifferentiable: function() {\n\n        if (!this.previousSegment) return false;\n\n        var start = this.start;\n        var control1 = this.controlPoint1;\n        var control2 = this.controlPoint2;\n        var end = this.end;\n\n        return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));\n    },\n\n    round: function(precision) {\n\n        this.controlPoint1.round(precision);\n        this.controlPoint2.round(precision);\n        this.end.round(precision);\n        return this;\n    },\n\n    scale: function(sx, sy, origin) {\n\n        this.controlPoint1.scale(sx, sy, origin);\n        this.controlPoint2.scale(sx, sy, origin);\n        this.end.scale(sx, sy, origin);\n        return this;\n    },\n\n    serialize: function() {\n\n        var c1 = this.controlPoint1;\n        var c2 = this.controlPoint2;\n        var end = this.end;\n        return this.type + ' ' + c1.x + ' ' + c1.y + ' ' + c2.x + ' ' + c2.y + ' ' + end.x + ' ' + end.y;\n    },\n\n    toString: function() {\n\n        return this.type + ' ' + this.start + ' ' + this.controlPoint1 + ' ' + this.controlPoint2 + ' ' + this.end;\n    },\n\n    translate: function(tx, ty) {\n\n        this.controlPoint1.translate(tx, ty);\n        this.controlPoint2.translate(tx, ty);\n        this.end.translate(tx, ty);\n        return this;\n    }\n};\n\nObject.defineProperty(curvetoPrototype, 'type', {\n\n    configurable: true,\n\n    enumerable: true,\n\n    value: 'C'\n});\n\nCurveto.prototype = extend(segmentPrototype, Curve.prototype, curvetoPrototype);\n\nvar Moveto = function() {\n\n    var args = [];\n    var n = arguments.length;\n    for (var i = 0; i < n; i++) {\n        args.push(arguments[i]);\n    }\n\n    if (!(this instanceof Moveto)) { // switching context of `this` to Moveto when called without `new`\n        return applyToNew(Moveto, args);\n    }\n\n    if (n === 0) {\n        throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (none provided).');\n    }\n\n    var outputArray;\n\n    if (args[0] instanceof Line) { // lines provided\n        if (n === 1) {\n            this.end = args[0].end.clone();\n            return this;\n\n        } else {\n            throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (' + n + ' lines provided).');\n        }\n\n    } else if (args[0] instanceof Curve) { // curves provided\n        if (n === 1) {\n            this.end = args[0].end.clone();\n            return this;\n\n        } else {\n            throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (' + n + ' curves provided).');\n        }\n\n    } else if (typeof args[0] === 'string' || typeof args[0] === 'number') { // coordinates provided\n        if (n === 2) {\n            this.end = new Point(+args[0], +args[1]);\n            return this;\n\n        } else if (n < 2) {\n            throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (' + n + ' coordinates provided).');\n\n        } else { // this is a moveto-with-subsequent-poly-line segment\n            var segmentCoords;\n            outputArray = [];\n            for (i = 0; i < n; i += 2) { // coords come in groups of two\n\n                segmentCoords = args.slice(i, i + 2); // will send one coord if args.length not divisible by 2\n                if (i === 0) outputArray.push(applyToNew(Moveto, segmentCoords));\n                else outputArray.push(applyToNew(Lineto, segmentCoords));\n            }\n            return outputArray;\n        }\n\n    } else { // points provided (needs to be last to also cover plain objects with x and y)\n        if (n === 1) {\n            this.end = new Point(args[0]);\n            return this;\n\n        } else { // this is a moveto-with-subsequent-poly-line segment\n            var segmentPoint;\n            outputArray = [];\n            for (i = 0; i < n; i += 1) { // points come one by one\n\n                segmentPoint = args[i];\n                if (i === 0) outputArray.push(new Moveto(segmentPoint));\n                else outputArray.push(new Lineto(segmentPoint));\n            }\n            return outputArray;\n        }\n    }\n};\n\nvar movetoPrototype = {\n\n    bbox: function() {\n\n        return null;\n    },\n\n    clone: function() {\n\n        return new Moveto(this.end);\n    },\n\n    closestPoint: function() {\n\n        return this.end.clone();\n    },\n\n    closestPointNormalizedLength: function() {\n\n        return 0;\n    },\n\n    closestPointLength: function() {\n\n        return 0;\n    },\n\n    closestPointT: function() {\n\n        return 1;\n    },\n\n    closestPointTangent: function() {\n\n        return null;\n    },\n\n    divideAt: function() {\n\n        return [\n            this.clone(),\n            this.clone()\n        ];\n    },\n\n    divideAtLength: function() {\n\n        return [\n            this.clone(),\n            this.clone()\n        ];\n    },\n\n    equals: function(m) {\n\n        return this.end.equals(m.end);\n    },\n\n    getSubdivisions: function() {\n\n        return [];\n    },\n\n    isDifferentiable: function() {\n\n        return false;\n    },\n\n    isSubpathStart: true,\n\n    isVisible: false,\n\n    length: function() {\n\n        return 0;\n    },\n\n    lengthAtT: function() {\n\n        return 0;\n    },\n\n    pointAt: function() {\n\n        return this.end.clone();\n    },\n\n    pointAtLength: function() {\n\n        return this.end.clone();\n    },\n\n    pointAtT: function() {\n\n        return this.end.clone();\n    },\n\n    round: function(precision) {\n\n        this.end.round(precision);\n        return this;\n    },\n\n    scale: function(sx, sy, origin) {\n\n        this.end.scale(sx, sy, origin);\n        return this;\n    },\n\n    serialize: function() {\n\n        var end = this.end;\n        return this.type + ' ' + end.x + ' ' + end.y;\n    },\n\n    tangentAt: function() {\n\n        return null;\n    },\n\n    tangentAtLength: function() {\n\n        return null;\n    },\n\n    tangentAtT: function() {\n\n        return null;\n    },\n\n    toString: function() {\n\n        return this.type + ' ' + this.end;\n    },\n\n    translate: function(tx, ty) {\n\n        this.end.translate(tx, ty);\n        return this;\n    }\n};\n\nObject.defineProperty(movetoPrototype, 'start', {\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        throw new Error('Illegal access. Moveto segments should not need a start property.');\n    }\n});\n\nObject.defineProperty(movetoPrototype, 'type', {\n\n    configurable: true,\n\n    enumerable: true,\n\n    value: 'M'\n});\n\nMoveto.prototype = extend(segmentPrototype, movetoPrototype); // does not inherit from any other geometry object\n\nvar Closepath = function() {\n\n    var args = [];\n    var n = arguments.length;\n    for (var i = 0; i < n; i++) {\n        args.push(arguments[i]);\n    }\n\n    if (!(this instanceof Closepath)) { // switching context of `this` to Closepath when called without `new`\n        return applyToNew(Closepath, args);\n    }\n\n    if (n > 0) {\n        throw new Error('Closepath constructor expects no arguments.');\n    }\n\n    return this;\n};\n\nvar closepathPrototype = {\n\n    clone: function() {\n\n        return new Closepath();\n    },\n\n    divideAt: function(ratio) {\n\n        var line = new Line(this.start, this.end);\n        var divided = line.divideAt(ratio);\n        return [\n            // if we didn't actually cut into the segment, first divided part can stay as Z\n            (divided[1].isDifferentiable() ? new Lineto(divided[0]) : this.clone()),\n            new Lineto(divided[1])\n        ];\n    },\n\n    divideAtLength: function(length) {\n\n        var line = new Line(this.start, this.end);\n        var divided = line.divideAtLength(length);\n        return [\n            // if we didn't actually cut into the segment, first divided part can stay as Z\n            (divided[1].isDifferentiable() ? new Lineto(divided[0]) : this.clone()),\n            new Lineto(divided[1])\n        ];\n    },\n\n    getSubdivisions: function() {\n\n        return [];\n    },\n\n    isDifferentiable: function() {\n\n        if (!this.previousSegment || !this.subpathStartSegment) return false;\n\n        return !this.start.equals(this.end);\n    },\n\n    round: function() {\n\n        return this;\n    },\n\n    scale: function() {\n\n        return this;\n    },\n\n    serialize: function() {\n\n        return this.type;\n    },\n\n    toString: function() {\n\n        return this.type + ' ' + this.start + ' ' + this.end;\n    },\n\n    translate: function() {\n\n        return this;\n    }\n};\n\nObject.defineProperty(closepathPrototype, 'end', {\n    // get a reference to the end point of subpath start segment\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        if (!this.subpathStartSegment) throw new Error('Missing subpath start segment. (This segment needs a subpath start segment (e.g. Moveto); OR segment has not yet been added to a path.)');\n\n        return this.subpathStartSegment.end;\n    }\n});\n\nObject.defineProperty(closepathPrototype, 'type', {\n\n    configurable: true,\n\n    enumerable: true,\n\n    value: 'Z'\n});\n\nClosepath.prototype = extend(segmentPrototype, Line.prototype, closepathPrototype);\n\nvar segmentTypes = Path.segmentTypes = {\n    L: Lineto,\n    C: Curveto,\n    M: Moveto,\n    Z: Closepath,\n    z: Closepath\n};\n\nPath.regexSupportedData = new RegExp('^[\\\\s\\\\d' + Object.keys(segmentTypes).join('') + ',.]*$');\n\nPath.isDataSupported = function(data) {\n\n    if (typeof data !== 'string') return false;\n    return this.regexSupportedData.test(data);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}