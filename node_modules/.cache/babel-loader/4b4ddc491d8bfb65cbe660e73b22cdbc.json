{"ast":null,"code":"import \"core-js/modules/es.array.includes.js\";\nimport V from '../V/index.mjs';\nimport { HighlighterView } from '../dia/HighlighterView.mjs';\nconst MASK_CLIP = 20;\n\nfunction forEachDescendant(vel, fn) {\n  const descendants = vel.children();\n\n  while (descendants.length > 0) {\n    const descendant = descendants.shift();\n\n    if (fn(descendant)) {\n      descendants.push(...descendant.children());\n    }\n  }\n}\n\nexport const mask = HighlighterView.extend({\n  tagName: 'rect',\n  className: 'highlight-mask',\n  attributes: {\n    'pointer-events': 'none'\n  },\n  options: {\n    padding: 3,\n    maskClip: MASK_CLIP,\n    deep: false,\n    attrs: {\n      'stroke': '#FEB663',\n      'stroke-width': 3,\n      'stroke-linecap': 'butt',\n      'stroke-linejoin': 'miter'\n    }\n  },\n  VISIBLE: 'white',\n  INVISIBLE: 'black',\n  MASK_ROOT_ATTRIBUTE_BLACKLIST: ['marker-start', 'marker-end', 'marker-mid', 'transform', 'stroke-dasharray'],\n  MASK_CHILD_ATTRIBUTE_BLACKLIST: ['stroke', 'fill', 'stroke-width', 'stroke-opacity', 'stroke-dasharray', 'fill-opacity', 'marker-start', 'marker-end', 'marker-mid'],\n  // TODO: change the list to a function callback\n  MASK_REPLACE_TAGS: ['FOREIGNOBJECT', 'IMAGE', 'USE', 'TEXT', 'TSPAN', 'TEXTPATH'],\n  // TODO: change the list to a function callback\n  MASK_REMOVE_TAGS: ['TEXT', 'TSPAN', 'TEXTPATH'],\n\n  transformMaskChild(cellView, childEl) {\n    const {\n      MASK_CHILD_ATTRIBUTE_BLACKLIST,\n      MASK_REPLACE_TAGS,\n      MASK_REMOVE_TAGS\n    } = this;\n    const childTagName = childEl.tagName(); // Do not include the element in the mask's image\n\n    if (!V.isSVGGraphicsElement(childEl) || MASK_REMOVE_TAGS.includes(childTagName)) {\n      childEl.remove();\n      return false;\n    } // Replace the element with a rectangle\n\n\n    if (MASK_REPLACE_TAGS.includes(childTagName)) {\n      // Note: clone() method does not change the children ids\n      const originalChild = cellView.vel.findOne(`#${childEl.id}`);\n\n      if (originalChild) {\n        const {\n          node: originalNode\n        } = originalChild;\n        let childBBox = cellView.getNodeBoundingRect(originalNode);\n\n        if (cellView.model.isElement()) {\n          childBBox = V.transformRect(childBBox, cellView.getNodeMatrix(originalNode));\n        }\n\n        const replacement = V('rect', childBBox.toJSON());\n        const {\n          x: ox,\n          y: oy\n        } = childBBox.center();\n        const {\n          angle,\n          cx = ox,\n          cy = oy\n        } = originalChild.rotate();\n        if (angle) replacement.rotate(angle, cx, cy); // Note: it's not important to keep the same sibling index since all subnodes are filled\n\n        childEl.parent().append(replacement);\n      }\n\n      childEl.remove();\n      return false;\n    } // Keep the element, but clean it from certain attributes\n\n\n    MASK_CHILD_ATTRIBUTE_BLACKLIST.forEach(attrName => {\n      if (attrName === 'fill' && childEl.attr('fill') === 'none') return;\n      childEl.removeAttr(attrName);\n    });\n    return true;\n  },\n\n  transformMaskRoot(_cellView, rootEl) {\n    const {\n      MASK_ROOT_ATTRIBUTE_BLACKLIST\n    } = this;\n    MASK_ROOT_ATTRIBUTE_BLACKLIST.forEach(attrName => {\n      rootEl.removeAttr(attrName);\n    });\n  },\n\n  getMaskShape(cellView, vel) {\n    const {\n      options,\n      MASK_REPLACE_TAGS\n    } = this;\n    const {\n      deep\n    } = options;\n    const tagName = vel.tagName();\n    let maskRoot;\n\n    if (tagName === 'G') {\n      if (!deep) return null;\n      maskRoot = vel.clone();\n      forEachDescendant(maskRoot, maskChild => this.transformMaskChild(cellView, maskChild));\n    } else {\n      if (MASK_REPLACE_TAGS.includes(tagName)) return null;\n      maskRoot = vel.clone();\n    }\n\n    this.transformMaskRoot(cellView, maskRoot);\n    return maskRoot;\n  },\n\n  getMaskId() {\n    return `highlight-mask-${this.cid}`;\n  },\n\n  getMask(cellView, vNode) {\n    const {\n      VISIBLE,\n      INVISIBLE,\n      options\n    } = this;\n    const {\n      padding,\n      attrs\n    } = options;\n    const strokeWidth = 'stroke-width' in attrs ? attrs['stroke-width'] : 1;\n    const hasNodeFill = vNode.attr('fill') !== 'none';\n    let magnetStrokeWidth = parseFloat(vNode.attr('stroke-width'));\n    if (isNaN(magnetStrokeWidth)) magnetStrokeWidth = 1; // stroke of the invisible shape\n\n    const minStrokeWidth = magnetStrokeWidth + padding * 2; // stroke of the visible shape\n\n    const maxStrokeWidth = minStrokeWidth + strokeWidth * 2;\n    let maskEl = this.getMaskShape(cellView, vNode);\n\n    if (!maskEl) {\n      const nodeBBox = cellView.getNodeBoundingRect(vNode.node); // Make sure the rect is visible\n\n      nodeBBox.inflate(nodeBBox.width ? 0 : 0.5, nodeBBox.height ? 0 : 0.5);\n      maskEl = V('rect', nodeBBox.toJSON());\n    }\n\n    maskEl.attr(attrs);\n    return V('mask', {\n      'id': this.getMaskId()\n    }).append([maskEl.clone().attr({\n      'fill': hasNodeFill ? VISIBLE : 'none',\n      'stroke': VISIBLE,\n      'stroke-width': maxStrokeWidth\n    }), maskEl.clone().attr({\n      'fill': hasNodeFill ? INVISIBLE : 'none',\n      'stroke': INVISIBLE,\n      'stroke-width': minStrokeWidth\n    })]);\n  },\n\n  removeMask(paper) {\n    const maskNode = paper.svg.getElementById(this.getMaskId());\n\n    if (maskNode) {\n      paper.defs.removeChild(maskNode);\n    }\n  },\n\n  addMask(paper, maskEl) {\n    paper.defs.appendChild(maskEl.node);\n  },\n\n  highlight(cellView, node) {\n    const {\n      options,\n      vel\n    } = this;\n    const {\n      padding,\n      attrs,\n      maskClip = MASK_CLIP,\n      layer\n    } = options;\n    const color = 'stroke' in attrs ? attrs['stroke'] : '#000000';\n\n    if (!layer && node === cellView.el) {\n      // If the highlighter is appended to the cellView\n      // and we measure the size of the cellView wrapping group\n      // it's necessary to remove the highlighter first\n      vel.remove();\n    }\n\n    const highlighterBBox = cellView.getNodeBoundingRect(node).inflate(padding + maskClip);\n    const maskEl = this.getMask(cellView, V(node));\n    this.addMask(cellView.paper, maskEl);\n    vel.attr(highlighterBBox.toJSON());\n    vel.attr({\n      'transform': V.matrixToTransformString(cellView.getNodeMatrix(node)),\n      'mask': `url(#${maskEl.id})`,\n      'fill': color\n    });\n  },\n\n  unhighlight(cellView) {\n    this.removeMask(cellView.paper);\n  }\n\n});","map":{"version":3,"names":["V","HighlighterView","MASK_CLIP","forEachDescendant","vel","fn","descendants","children","length","descendant","shift","push","mask","extend","tagName","className","attributes","options","padding","maskClip","deep","attrs","VISIBLE","INVISIBLE","MASK_ROOT_ATTRIBUTE_BLACKLIST","MASK_CHILD_ATTRIBUTE_BLACKLIST","MASK_REPLACE_TAGS","MASK_REMOVE_TAGS","transformMaskChild","cellView","childEl","childTagName","isSVGGraphicsElement","includes","remove","originalChild","findOne","id","node","originalNode","childBBox","getNodeBoundingRect","model","isElement","transformRect","getNodeMatrix","replacement","toJSON","x","ox","y","oy","center","angle","cx","cy","rotate","parent","append","forEach","attrName","attr","removeAttr","transformMaskRoot","_cellView","rootEl","getMaskShape","maskRoot","clone","maskChild","getMaskId","cid","getMask","vNode","strokeWidth","hasNodeFill","magnetStrokeWidth","parseFloat","isNaN","minStrokeWidth","maxStrokeWidth","maskEl","nodeBBox","inflate","width","height","removeMask","paper","maskNode","svg","getElementById","defs","removeChild","addMask","appendChild","highlight","layer","color","el","highlighterBBox","matrixToTransformString","unhighlight"],"sources":["C:/Users/Admin/dataflow-test/node_modules/jointjs/src/highlighters/mask.mjs"],"sourcesContent":["import V from '../V/index.mjs';\nimport { HighlighterView } from '../dia/HighlighterView.mjs';\n\nconst MASK_CLIP = 20;\n\nfunction forEachDescendant(vel, fn) {\n    const descendants = vel.children();\n    while (descendants.length > 0) {\n        const descendant = descendants.shift();\n        if (fn(descendant)) {\n            descendants.push(...descendant.children());\n        }\n    }\n}\n\nexport const mask = HighlighterView.extend({\n\n    tagName: 'rect',\n    className: 'highlight-mask',\n    attributes: {\n        'pointer-events': 'none'\n    },\n\n    options: {\n        padding: 3,\n        maskClip: MASK_CLIP,\n        deep: false,\n        attrs: {\n            'stroke': '#FEB663',\n            'stroke-width': 3,\n            'stroke-linecap': 'butt',\n            'stroke-linejoin': 'miter',\n        }\n    },\n\n    VISIBLE: 'white',\n    INVISIBLE: 'black',\n\n    MASK_ROOT_ATTRIBUTE_BLACKLIST: [\n        'marker-start',\n        'marker-end',\n        'marker-mid',\n        'transform',\n        'stroke-dasharray'\n    ],\n\n    MASK_CHILD_ATTRIBUTE_BLACKLIST: [\n        'stroke',\n        'fill',\n        'stroke-width',\n        'stroke-opacity',\n        'stroke-dasharray',\n        'fill-opacity',\n        'marker-start',\n        'marker-end',\n        'marker-mid'\n    ],\n\n    // TODO: change the list to a function callback\n    MASK_REPLACE_TAGS: [\n        'FOREIGNOBJECT',\n        'IMAGE',\n        'USE',\n        'TEXT',\n        'TSPAN',\n        'TEXTPATH'\n    ],\n\n    // TODO: change the list to a function callback\n    MASK_REMOVE_TAGS: [\n        'TEXT',\n        'TSPAN',\n        'TEXTPATH'\n    ],\n\n    transformMaskChild(cellView, childEl) {\n        const {\n            MASK_CHILD_ATTRIBUTE_BLACKLIST,\n            MASK_REPLACE_TAGS,\n            MASK_REMOVE_TAGS\n        } = this;\n        const childTagName = childEl.tagName();\n        // Do not include the element in the mask's image\n        if (!V.isSVGGraphicsElement(childEl) || MASK_REMOVE_TAGS.includes(childTagName)) {\n            childEl.remove();\n            return false;\n        }\n        // Replace the element with a rectangle\n        if (MASK_REPLACE_TAGS.includes(childTagName)) {\n            // Note: clone() method does not change the children ids\n            const originalChild = cellView.vel.findOne(`#${childEl.id}`);\n            if (originalChild) {\n                const { node: originalNode } = originalChild;\n                let childBBox = cellView.getNodeBoundingRect(originalNode);\n                if (cellView.model.isElement()) {\n                    childBBox = V.transformRect(childBBox, cellView.getNodeMatrix(originalNode));\n                }\n                const replacement = V('rect', childBBox.toJSON());\n                const { x: ox, y: oy } = childBBox.center();\n                const { angle, cx = ox, cy = oy } = originalChild.rotate();\n                if (angle) replacement.rotate(angle, cx, cy);\n                // Note: it's not important to keep the same sibling index since all subnodes are filled\n                childEl.parent().append(replacement);\n            }\n            childEl.remove();\n            return false;\n        }\n        // Keep the element, but clean it from certain attributes\n        MASK_CHILD_ATTRIBUTE_BLACKLIST.forEach(attrName => {\n            if (attrName === 'fill' && childEl.attr('fill') === 'none') return;\n            childEl.removeAttr(attrName);\n        });\n        return true;\n    },\n\n    transformMaskRoot(_cellView, rootEl) {\n        const { MASK_ROOT_ATTRIBUTE_BLACKLIST } = this;\n        MASK_ROOT_ATTRIBUTE_BLACKLIST.forEach(attrName => {\n            rootEl.removeAttr(attrName);\n        });\n    },\n\n    getMaskShape(cellView, vel) {\n        const { options, MASK_REPLACE_TAGS } = this;\n        const { deep } = options;\n        const tagName = vel.tagName();\n        let maskRoot;\n        if (tagName === 'G') {\n            if (!deep) return null;\n            maskRoot = vel.clone();\n            forEachDescendant(maskRoot, maskChild => this.transformMaskChild(cellView, maskChild));\n        } else {\n            if (MASK_REPLACE_TAGS.includes(tagName)) return null;\n            maskRoot = vel.clone();\n        }\n        this.transformMaskRoot(cellView, maskRoot);\n        return maskRoot;\n    },\n\n    getMaskId() {\n        return `highlight-mask-${this.cid}`;\n    },\n\n    getMask(cellView, vNode) {\n\n        const { VISIBLE, INVISIBLE, options } = this;\n        const { padding, attrs } = options;\n\n        const strokeWidth = ('stroke-width' in attrs) ? attrs['stroke-width'] : 1;\n        const hasNodeFill = vNode.attr('fill') !== 'none';\n        let magnetStrokeWidth = parseFloat(vNode.attr('stroke-width'));\n        if (isNaN(magnetStrokeWidth)) magnetStrokeWidth = 1;\n        // stroke of the invisible shape\n        const minStrokeWidth = magnetStrokeWidth + padding * 2;\n        // stroke of the visible shape\n        const maxStrokeWidth = minStrokeWidth + strokeWidth * 2;\n        let maskEl = this.getMaskShape(cellView, vNode);\n        if (!maskEl) {\n            const nodeBBox = cellView.getNodeBoundingRect(vNode.node);\n            // Make sure the rect is visible\n            nodeBBox.inflate(nodeBBox.width ? 0 : 0.5, nodeBBox.height ? 0 : 0.5);\n            maskEl =  V('rect', nodeBBox.toJSON());\n        }\n        maskEl.attr(attrs);\n        return V('mask', {\n            'id': this.getMaskId()\n        }).append([\n            maskEl.clone().attr({\n                'fill': hasNodeFill ? VISIBLE : 'none',\n                'stroke': VISIBLE,\n                'stroke-width': maxStrokeWidth\n            }),\n            maskEl.clone().attr({\n                'fill': hasNodeFill ? INVISIBLE : 'none',\n                'stroke': INVISIBLE,\n                'stroke-width': minStrokeWidth\n            })\n        ]);\n    },\n\n    removeMask(paper) {\n        const maskNode = paper.svg.getElementById(this.getMaskId());\n        if (maskNode) {\n            paper.defs.removeChild(maskNode);\n        }\n    },\n\n    addMask(paper, maskEl) {\n        paper.defs.appendChild(maskEl.node);\n    },\n\n    highlight(cellView, node) {\n        const { options, vel } = this;\n        const { padding, attrs, maskClip = MASK_CLIP, layer } = options;\n        const color = ('stroke' in attrs) ? attrs['stroke'] : '#000000';\n        if (!layer && node === cellView.el) {\n            // If the highlighter is appended to the cellView\n            // and we measure the size of the cellView wrapping group\n            // it's necessary to remove the highlighter first\n            vel.remove();\n        }\n        const highlighterBBox = cellView.getNodeBoundingRect(node).inflate(padding + maskClip);\n        const maskEl = this.getMask(cellView, V(node));\n        this.addMask(cellView.paper, maskEl);\n        vel.attr(highlighterBBox.toJSON());\n        vel.attr({\n            'transform': V.matrixToTransformString(cellView.getNodeMatrix(node)),\n            'mask': `url(#${maskEl.id})`,\n            'fill': color\n        });\n    },\n\n    unhighlight(cellView) {\n        this.removeMask(cellView.paper);\n    }\n\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}