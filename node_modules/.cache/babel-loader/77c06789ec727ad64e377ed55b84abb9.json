{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport { manhattan } from './manhattan.mjs';\nimport * as util from '../util/index.mjs';\nimport * as g from '../g/index.mjs';\nvar config = {\n  maxAllowedDirectionChange: 45,\n  // cost of a diagonal step\n  diagonalCost: function () {\n    var step = this.step;\n    return Math.ceil(Math.sqrt(step * step << 1));\n  },\n  // an array of directions to find next points on the route\n  // different from start/end directions\n  directions: function () {\n    var step = this.step;\n    var cost = this.cost();\n    var diagonalCost = this.diagonalCost();\n    return [{\n      offsetX: step,\n      offsetY: 0,\n      cost: cost\n    }, {\n      offsetX: step,\n      offsetY: step,\n      cost: diagonalCost\n    }, {\n      offsetX: 0,\n      offsetY: step,\n      cost: cost\n    }, {\n      offsetX: -step,\n      offsetY: step,\n      cost: diagonalCost\n    }, {\n      offsetX: -step,\n      offsetY: 0,\n      cost: cost\n    }, {\n      offsetX: -step,\n      offsetY: -step,\n      cost: diagonalCost\n    }, {\n      offsetX: 0,\n      offsetY: -step,\n      cost: cost\n    }, {\n      offsetX: step,\n      offsetY: -step,\n      cost: diagonalCost\n    }];\n  },\n  // a simple route used in situations when main routing method fails\n  // (exceed max number of loop iterations, inaccessible)\n  fallbackRoute: function (from, to, opt) {\n    // Find a route which breaks by 45 degrees ignoring all obstacles.\n    var theta = from.theta(to);\n    var route = [];\n    var a = {\n      x: to.x,\n      y: from.y\n    };\n    var b = {\n      x: from.x,\n      y: to.y\n    };\n\n    if (theta % 180 > 90) {\n      var t = a;\n      a = b;\n      b = t;\n    }\n\n    var p1 = theta % 90 < 45 ? a : b;\n    var l1 = new g.Line(from, p1);\n    var alpha = 90 * Math.ceil(theta / 90);\n    var p2 = g.Point.fromPolar(l1.squaredLength(), g.toRad(alpha + 135), p1);\n    var l2 = new g.Line(to, p2);\n    var intersectionPoint = l1.intersection(l2);\n    var point = intersectionPoint ? intersectionPoint : to;\n    var directionFrom = intersectionPoint ? point : from;\n    var quadrant = 360 / opt.directions.length;\n    var angleTheta = directionFrom.theta(to);\n    var normalizedAngle = g.normalizeAngle(angleTheta + quadrant / 2);\n    var directionAngle = quadrant * Math.floor(normalizedAngle / quadrant);\n    opt.previousDirectionAngle = directionAngle;\n    if (point) route.push(point.round());\n    route.push(to);\n    return route;\n  }\n}; // public function\n\nexport const metro = function (vertices, opt, linkView) {\n  if (!util.isFunction(manhattan)) {\n    throw new Error('Metro requires the manhattan router.');\n  }\n\n  return manhattan(vertices, util.assign({}, config, opt), linkView);\n};","map":{"version":3,"names":["manhattan","util","g","config","maxAllowedDirectionChange","diagonalCost","step","Math","ceil","sqrt","directions","cost","offsetX","offsetY","fallbackRoute","from","to","opt","theta","route","a","x","y","b","t","p1","l1","Line","alpha","p2","Point","fromPolar","squaredLength","toRad","l2","intersectionPoint","intersection","point","directionFrom","quadrant","length","angleTheta","normalizedAngle","normalizeAngle","directionAngle","floor","previousDirectionAngle","push","round","metro","vertices","linkView","isFunction","Error","assign"],"sources":["C:/Users/Admin/dataflow-test/node_modules/jointjs/src/routers/metro.mjs"],"sourcesContent":["import { manhattan } from './manhattan.mjs';\nimport * as util from '../util/index.mjs';\nimport * as g from '../g/index.mjs';\n\nvar config = {\n\n    maxAllowedDirectionChange: 45,\n\n    // cost of a diagonal step\n    diagonalCost: function() {\n\n        var step = this.step;\n        return Math.ceil(Math.sqrt(step * step << 1));\n    },\n\n    // an array of directions to find next points on the route\n    // different from start/end directions\n    directions: function() {\n\n        var step = this.step;\n        var cost = this.cost();\n        var diagonalCost = this.diagonalCost();\n\n        return [\n            { offsetX: step, offsetY: 0, cost: cost },\n            { offsetX: step, offsetY: step, cost: diagonalCost },\n            { offsetX: 0, offsetY: step, cost: cost },\n            { offsetX: -step, offsetY: step, cost: diagonalCost },\n            { offsetX: -step, offsetY: 0, cost: cost },\n            { offsetX: -step, offsetY: -step, cost: diagonalCost },\n            { offsetX: 0, offsetY: -step, cost: cost },\n            { offsetX: step, offsetY: -step, cost: diagonalCost }\n        ];\n    },\n\n    // a simple route used in situations when main routing method fails\n    // (exceed max number of loop iterations, inaccessible)\n    fallbackRoute: function(from, to, opt) {\n\n        // Find a route which breaks by 45 degrees ignoring all obstacles.\n\n        var theta = from.theta(to);\n\n        var route = [];\n\n        var a = { x: to.x, y: from.y };\n        var b = { x: from.x, y: to.y };\n\n        if (theta % 180 > 90) {\n            var t = a;\n            a = b;\n            b = t;\n        }\n\n        var p1 = (theta % 90) < 45 ? a : b;\n        var l1 = new g.Line(from, p1);\n\n        var alpha = 90 * Math.ceil(theta / 90);\n\n        var p2 = g.Point.fromPolar(l1.squaredLength(), g.toRad(alpha + 135), p1);\n        var l2 = new g.Line(to, p2);\n\n        var intersectionPoint = l1.intersection(l2);\n        var point = intersectionPoint ? intersectionPoint : to;\n\n        var directionFrom = intersectionPoint ? point : from;\n\n        var quadrant = 360 / opt.directions.length;\n        var angleTheta = directionFrom.theta(to);\n        var normalizedAngle = g.normalizeAngle(angleTheta + (quadrant / 2));\n        var directionAngle = quadrant * Math.floor(normalizedAngle / quadrant);\n\n        opt.previousDirectionAngle = directionAngle;\n\n        if (point) route.push(point.round());\n        route.push(to);\n\n        return route;\n    }\n};\n\n// public function\nexport const metro = function(vertices, opt, linkView) {\n\n    if (!util.isFunction(manhattan)) {\n        throw new Error('Metro requires the manhattan router.');\n    }\n\n    return manhattan(vertices, util.assign({}, config, opt), linkView);\n};\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}