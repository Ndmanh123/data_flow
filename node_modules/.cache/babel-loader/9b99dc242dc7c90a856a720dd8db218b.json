{"ast":null,"code":"import { toRad } from './geometry.helpers.mjs';\nimport { Line } from './line.mjs';\nimport { Point } from './point.mjs';\nimport { Ellipse } from './ellipse.mjs';\nimport { types } from './types.mjs';\nconst {\n  abs,\n  cos,\n  sin,\n  min,\n  max,\n  round,\n  pow\n} = Math;\nexport const Rect = function (x, y, w, h) {\n  if (!(this instanceof Rect)) {\n    return new Rect(x, y, w, h);\n  }\n\n  if (Object(x) === x) {\n    y = x.y;\n    w = x.width;\n    h = x.height;\n    x = x.x;\n  }\n\n  this.x = x === undefined ? 0 : x;\n  this.y = y === undefined ? 0 : y;\n  this.width = w === undefined ? 0 : w;\n  this.height = h === undefined ? 0 : h;\n};\n\nRect.fromEllipse = function (e) {\n  e = new Ellipse(e);\n  return new Rect(e.x - e.a, e.y - e.b, 2 * e.a, 2 * e.b);\n};\n\nRect.fromPointUnion = function (...points) {\n  if (points.length === 0) return null;\n  const p = new Point();\n  let minX, minY, maxX, maxY;\n  minX = minY = Infinity;\n  maxX = maxY = -Infinity;\n\n  for (let i = 0; i < points.length; i++) {\n    p.update(points[i]);\n    const x = p.x;\n    const y = p.y;\n    if (x < minX) minX = x;\n    if (x > maxX) maxX = x;\n    if (y < minY) minY = y;\n    if (y > maxY) maxY = y;\n  }\n\n  return new Rect(minX, minY, maxX - minX, maxY - minY);\n};\n\nRect.fromRectUnion = function (...rects) {\n  if (rects.length === 0) return null;\n  const r = new Rect();\n  let minX, minY, maxX, maxY;\n  minX = minY = Infinity;\n  maxX = maxY = -Infinity;\n\n  for (let i = 0; i < rects.length; i++) {\n    r.update(rects[i]);\n    const x = r.x;\n    const y = r.y;\n    const mX = x + r.width;\n    const mY = y + r.height;\n    if (x < minX) minX = x;\n    if (mX > maxX) maxX = mX;\n    if (y < minY) minY = y;\n    if (mY > maxY) maxY = mY;\n  }\n\n  return new Rect(minX, minY, maxX - minX, maxY - minY);\n};\n\nRect.prototype = {\n  type: types.Rect,\n  // Find my bounding box when I'm rotated with the center of rotation in the center of me.\n  // @return r {rectangle} representing a bounding box\n  bbox: function (angle) {\n    return this.clone().rotateAroundCenter(angle);\n  },\n  rotateAroundCenter: function (angle) {\n    if (!angle) return this;\n    const {\n      width,\n      height\n    } = this;\n    const theta = toRad(angle);\n    const st = abs(sin(theta));\n    const ct = abs(cos(theta));\n    const w = width * ct + height * st;\n    const h = width * st + height * ct;\n    this.x += (width - w) / 2;\n    this.y += (height - h) / 2;\n    this.width = w;\n    this.height = h;\n    return this;\n  },\n  bottomLeft: function () {\n    return new Point(this.x, this.y + this.height);\n  },\n  bottomLine: function () {\n    return new Line(this.bottomLeft(), this.bottomRight());\n  },\n  bottomMiddle: function () {\n    return new Point(this.x + this.width / 2, this.y + this.height);\n  },\n  center: function () {\n    return new Point(this.x + this.width / 2, this.y + this.height / 2);\n  },\n  clone: function () {\n    return new Rect(this);\n  },\n  // @return {bool} true if point p is inside me.\n  containsPoint: function (p) {\n    p = new Point(p);\n    return p.x >= this.x && p.x <= this.x + this.width && p.y >= this.y && p.y <= this.y + this.height;\n  },\n  // @return {bool} true if rectangle `r` is inside me.\n  containsRect: function (r) {\n    var r0 = new Rect(this).normalize();\n    var r1 = new Rect(r).normalize();\n    var w0 = r0.width;\n    var h0 = r0.height;\n    var w1 = r1.width;\n    var h1 = r1.height;\n\n    if (!w0 || !h0 || !w1 || !h1) {\n      // At least one of the dimensions is 0\n      return false;\n    }\n\n    var x0 = r0.x;\n    var y0 = r0.y;\n    var x1 = r1.x;\n    var y1 = r1.y;\n    w1 += x1;\n    w0 += x0;\n    h1 += y1;\n    h0 += y0;\n    return x0 <= x1 && w1 <= w0 && y0 <= y1 && h1 <= h0;\n  },\n  corner: function () {\n    return new Point(this.x + this.width, this.y + this.height);\n  },\n  // @return {boolean} true if rectangles are equal.\n  equals: function (r) {\n    var mr = new Rect(this).normalize();\n    var nr = new Rect(r).normalize();\n    return mr.x === nr.x && mr.y === nr.y && mr.width === nr.width && mr.height === nr.height;\n  },\n  // inflate by dx and dy, recompute origin [x, y]\n  // @param dx {delta_x} representing additional size to x\n  // @param dy {delta_y} representing additional size to y -\n  // dy param is not required -> in that case y is sized by dx\n  inflate: function (dx, dy) {\n    if (dx === undefined) {\n      dx = 0;\n    }\n\n    if (dy === undefined) {\n      dy = dx;\n    }\n\n    this.x -= dx;\n    this.y -= dy;\n    this.width += 2 * dx;\n    this.height += 2 * dy;\n    return this;\n  },\n  // @return {rect} if rectangles intersect, {null} if not.\n  intersect: function (r) {\n    var myOrigin = this.origin();\n    var myCorner = this.corner();\n    var rOrigin = r.origin();\n    var rCorner = r.corner(); // No intersection found\n\n    if (rCorner.x <= myOrigin.x || rCorner.y <= myOrigin.y || rOrigin.x >= myCorner.x || rOrigin.y >= myCorner.y) return null;\n    var x = max(myOrigin.x, rOrigin.x);\n    var y = max(myOrigin.y, rOrigin.y);\n    return new Rect(x, y, min(myCorner.x, rCorner.x) - x, min(myCorner.y, rCorner.y) - y);\n  },\n  intersectionWithLine: function (line) {\n    var r = this;\n    var rectLines = [r.topLine(), r.rightLine(), r.bottomLine(), r.leftLine()];\n    var points = [];\n    var dedupeArr = [];\n    var pt, i;\n    var n = rectLines.length;\n\n    for (i = 0; i < n; i++) {\n      pt = line.intersect(rectLines[i]);\n\n      if (pt !== null && dedupeArr.indexOf(pt.toString()) < 0) {\n        points.push(pt);\n        dedupeArr.push(pt.toString());\n      }\n    }\n\n    return points.length > 0 ? points : null;\n  },\n  // Find point on my boundary where line starting\n  // from my center ending in point p intersects me.\n  // @param {number} angle If angle is specified, intersection with rotated rectangle is computed.\n  intersectionWithLineFromCenterToPoint: function (p, angle) {\n    p = new Point(p);\n    var center = new Point(this.x + this.width / 2, this.y + this.height / 2);\n    var result;\n    if (angle) p.rotate(center, angle); // (clockwise, starting from the top side)\n\n    var sides = [this.topLine(), this.rightLine(), this.bottomLine(), this.leftLine()];\n    var connector = new Line(center, p);\n\n    for (var i = sides.length - 1; i >= 0; --i) {\n      var intersection = sides[i].intersection(connector);\n\n      if (intersection !== null) {\n        result = intersection;\n        break;\n      }\n    }\n\n    if (result && angle) result.rotate(center, -angle);\n    return result;\n  },\n  leftLine: function () {\n    return new Line(this.topLeft(), this.bottomLeft());\n  },\n  leftMiddle: function () {\n    return new Point(this.x, this.y + this.height / 2);\n  },\n  maxRectScaleToFit: function (rect, origin) {\n    rect = new Rect(rect);\n    origin || (origin = rect.center());\n    var sx1, sx2, sx3, sx4, sy1, sy2, sy3, sy4;\n    var ox = origin.x;\n    var oy = origin.y; // Here we find the maximal possible scale for all corner points (for x and y axis) of the rectangle,\n    // so when the scale is applied the point is still inside the rectangle.\n\n    sx1 = sx2 = sx3 = sx4 = sy1 = sy2 = sy3 = sy4 = Infinity; // Top Left\n\n    var p1 = rect.topLeft();\n\n    if (p1.x < ox) {\n      sx1 = (this.x - ox) / (p1.x - ox);\n    }\n\n    if (p1.y < oy) {\n      sy1 = (this.y - oy) / (p1.y - oy);\n    } // Bottom Right\n\n\n    var p2 = rect.bottomRight();\n\n    if (p2.x > ox) {\n      sx2 = (this.x + this.width - ox) / (p2.x - ox);\n    }\n\n    if (p2.y > oy) {\n      sy2 = (this.y + this.height - oy) / (p2.y - oy);\n    } // Top Right\n\n\n    var p3 = rect.topRight();\n\n    if (p3.x > ox) {\n      sx3 = (this.x + this.width - ox) / (p3.x - ox);\n    }\n\n    if (p3.y < oy) {\n      sy3 = (this.y - oy) / (p3.y - oy);\n    } // Bottom Left\n\n\n    var p4 = rect.bottomLeft();\n\n    if (p4.x < ox) {\n      sx4 = (this.x - ox) / (p4.x - ox);\n    }\n\n    if (p4.y > oy) {\n      sy4 = (this.y + this.height - oy) / (p4.y - oy);\n    }\n\n    return {\n      sx: min(sx1, sx2, sx3, sx4),\n      sy: min(sy1, sy2, sy3, sy4)\n    };\n  },\n  maxRectUniformScaleToFit: function (rect, origin) {\n    var scale = this.maxRectScaleToFit(rect, origin);\n    return min(scale.sx, scale.sy);\n  },\n  // Move and expand me.\n  // @param r {rectangle} representing deltas\n  moveAndExpand: function (r) {\n    this.x += r.x || 0;\n    this.y += r.y || 0;\n    this.width += r.width || 0;\n    this.height += r.height || 0;\n    return this;\n  },\n  // Normalize the rectangle; i.e., make it so that it has a non-negative width and height.\n  // If width < 0 the function swaps the left and right corners,\n  // and it swaps the top and bottom corners if height < 0\n  // like in http://qt-project.org/doc/qt-4.8/qrectf.html#normalized\n  normalize: function () {\n    var newx = this.x;\n    var newy = this.y;\n    var newwidth = this.width;\n    var newheight = this.height;\n\n    if (this.width < 0) {\n      newx = this.x + this.width;\n      newwidth = -this.width;\n    }\n\n    if (this.height < 0) {\n      newy = this.y + this.height;\n      newheight = -this.height;\n    }\n\n    this.x = newx;\n    this.y = newy;\n    this.width = newwidth;\n    this.height = newheight;\n    return this;\n  },\n  // Offset me by the specified amount.\n  offset: function (dx, dy) {\n    // pretend that this is a point and call offset()\n    // rewrites x and y according to dx and dy\n    return Point.prototype.offset.call(this, dx, dy);\n  },\n  origin: function () {\n    return new Point(this.x, this.y);\n  },\n  // @return {point} a point on my boundary nearest to the given point.\n  // @see Squeak Smalltalk, Rectangle>>pointNearestTo:\n  pointNearestToPoint: function (point) {\n    point = new Point(point);\n\n    if (this.containsPoint(point)) {\n      var side = this.sideNearestToPoint(point);\n\n      switch (side) {\n        case 'right':\n          return new Point(this.x + this.width, point.y);\n\n        case 'left':\n          return new Point(this.x, point.y);\n\n        case 'bottom':\n          return new Point(point.x, this.y + this.height);\n\n        case 'top':\n          return new Point(point.x, this.y);\n      }\n    }\n\n    return point.adhereToRect(this);\n  },\n  rightLine: function () {\n    return new Line(this.topRight(), this.bottomRight());\n  },\n  rightMiddle: function () {\n    return new Point(this.x + this.width, this.y + this.height / 2);\n  },\n  round: function (precision) {\n    let f = 1; // case 0\n\n    if (precision) {\n      switch (precision) {\n        case 1:\n          f = 10;\n          break;\n\n        case 2:\n          f = 100;\n          break;\n\n        case 3:\n          f = 1000;\n          break;\n\n        default:\n          f = pow(10, precision);\n          break;\n      }\n    }\n\n    this.x = round(this.x * f) / f;\n    this.y = round(this.y * f) / f;\n    this.width = round(this.width * f) / f;\n    this.height = round(this.height * f) / f;\n    return this;\n  },\n  // Scale rectangle with origin.\n  scale: function (sx, sy, origin) {\n    origin = this.origin().scale(sx, sy, origin);\n    this.x = origin.x;\n    this.y = origin.y;\n    this.width *= sx;\n    this.height *= sy;\n    return this;\n  },\n  // @return {string} (left|right|top|bottom) side which is nearest to point\n  // @see Squeak Smalltalk, Rectangle>>sideNearestTo:\n  sideNearestToPoint: function (point) {\n    point = new Point(point);\n    var distToLeft = point.x - this.x;\n    var distToRight = this.x + this.width - point.x;\n    var distToTop = point.y - this.y;\n    var distToBottom = this.y + this.height - point.y;\n    var closest = distToLeft;\n    var side = 'left';\n\n    if (distToRight < closest) {\n      closest = distToRight;\n      side = 'right';\n    }\n\n    if (distToTop < closest) {\n      closest = distToTop;\n      side = 'top';\n    }\n\n    if (distToBottom < closest) {\n      // closest = distToBottom;\n      side = 'bottom';\n    }\n\n    return side;\n  },\n  snapToGrid: function (gx, gy) {\n    var origin = this.origin().snapToGrid(gx, gy);\n    var corner = this.corner().snapToGrid(gx, gy);\n    this.x = origin.x;\n    this.y = origin.y;\n    this.width = corner.x - origin.x;\n    this.height = corner.y - origin.y;\n    return this;\n  },\n  toJSON: function () {\n    return {\n      x: this.x,\n      y: this.y,\n      width: this.width,\n      height: this.height\n    };\n  },\n  topLine: function () {\n    return new Line(this.topLeft(), this.topRight());\n  },\n  topMiddle: function () {\n    return new Point(this.x + this.width / 2, this.y);\n  },\n  topRight: function () {\n    return new Point(this.x + this.width, this.y);\n  },\n  toString: function () {\n    return this.origin().toString() + ' ' + this.corner().toString();\n  },\n  // @return {rect} representing the union of both rectangles.\n  union: function (rect) {\n    return Rect.fromRectUnion(this, rect);\n  },\n  update: function (x, y, w, h) {\n    if (Object(x) === x) {\n      y = x.y;\n      w = x.width;\n      h = x.height;\n      x = x.x;\n    }\n\n    this.x = x || 0;\n    this.y = y || 0;\n    this.width = w || 0;\n    this.height = h || 0;\n    return this;\n  }\n};\nRect.prototype.bottomRight = Rect.prototype.corner;\nRect.prototype.topLeft = Rect.prototype.origin;\nRect.prototype.translate = Rect.prototype.offset; // For backwards compatibility:\n\nexport const rect = Rect;","map":{"version":3,"names":["toRad","Line","Point","Ellipse","types","abs","cos","sin","min","max","round","pow","Math","Rect","x","y","w","h","Object","width","height","undefined","fromEllipse","e","a","b","fromPointUnion","points","length","p","minX","minY","maxX","maxY","Infinity","i","update","fromRectUnion","rects","r","mX","mY","prototype","type","bbox","angle","clone","rotateAroundCenter","theta","st","ct","bottomLeft","bottomLine","bottomRight","bottomMiddle","center","containsPoint","containsRect","r0","normalize","r1","w0","h0","w1","h1","x0","y0","x1","y1","corner","equals","mr","nr","inflate","dx","dy","intersect","myOrigin","origin","myCorner","rOrigin","rCorner","intersectionWithLine","line","rectLines","topLine","rightLine","leftLine","dedupeArr","pt","n","indexOf","toString","push","intersectionWithLineFromCenterToPoint","result","rotate","sides","connector","intersection","topLeft","leftMiddle","maxRectScaleToFit","rect","sx1","sx2","sx3","sx4","sy1","sy2","sy3","sy4","ox","oy","p1","p2","p3","topRight","p4","sx","sy","maxRectUniformScaleToFit","scale","moveAndExpand","newx","newy","newwidth","newheight","offset","call","pointNearestToPoint","point","side","sideNearestToPoint","adhereToRect","rightMiddle","precision","f","distToLeft","distToRight","distToTop","distToBottom","closest","snapToGrid","gx","gy","toJSON","topMiddle","union","translate"],"sources":["C:/Users/Admin/dataflow-test/node_modules/jointjs/src/g/rect.mjs"],"sourcesContent":["import { toRad } from './geometry.helpers.mjs';\nimport { Line } from './line.mjs';\nimport { Point } from './point.mjs';\nimport { Ellipse } from './ellipse.mjs';\nimport { types } from './types.mjs';\n\nconst {\n    abs,\n    cos,\n    sin,\n    min,\n    max,\n    round,\n    pow\n} = Math;\n\nexport const Rect = function(x, y, w, h) {\n\n    if (!(this instanceof Rect)) {\n        return new Rect(x, y, w, h);\n    }\n\n    if ((Object(x) === x)) {\n        y = x.y;\n        w = x.width;\n        h = x.height;\n        x = x.x;\n    }\n\n    this.x = x === undefined ? 0 : x;\n    this.y = y === undefined ? 0 : y;\n    this.width = w === undefined ? 0 : w;\n    this.height = h === undefined ? 0 : h;\n};\n\nRect.fromEllipse = function(e) {\n\n    e = new Ellipse(e);\n    return new Rect(e.x - e.a, e.y - e.b, 2 * e.a, 2 * e.b);\n};\n\nRect.fromPointUnion = function(...points) {\n\n    if (points.length === 0) return null;\n\n    const p = new Point();\n    let minX, minY, maxX, maxY;\n    minX = minY = Infinity;\n    maxX = maxY = -Infinity;\n\n    for (let i = 0; i < points.length; i++) {\n        p.update(points[i]);\n        const x = p.x;\n        const y = p.y;\n\n        if (x < minX) minX = x;\n        if (x > maxX) maxX = x;\n        if (y < minY) minY = y;\n        if (y > maxY) maxY = y;\n    }\n\n    return new Rect(minX, minY, maxX - minX, maxY - minY);\n};\n\nRect.fromRectUnion = function(...rects) {\n\n    if (rects.length === 0) return null;\n\n    const r = new Rect();\n    let minX, minY, maxX, maxY;\n    minX = minY = Infinity;\n    maxX = maxY = -Infinity;\n\n    for (let i = 0; i < rects.length; i++) {\n        r.update(rects[i]);\n        const x = r.x;\n        const y = r.y;\n        const mX = x + r.width;\n        const mY = y + r.height;\n\n        if (x < minX) minX = x;\n        if (mX > maxX) maxX = mX;\n        if (y < minY) minY = y;\n        if (mY > maxY) maxY = mY;\n    }\n\n    return new Rect(minX, minY, maxX - minX, maxY - minY);\n};\n\nRect.prototype = {\n\n    type: types.Rect,\n\n    // Find my bounding box when I'm rotated with the center of rotation in the center of me.\n    // @return r {rectangle} representing a bounding box\n    bbox: function(angle) {\n        return this.clone().rotateAroundCenter(angle);\n    },\n\n    rotateAroundCenter: function(angle) {\n        if (!angle) return this;\n        const { width, height } = this;\n        const theta = toRad(angle);\n        const st = abs(sin(theta));\n        const ct = abs(cos(theta));\n        const w = width * ct + height * st;\n        const h = width * st + height * ct;\n        this.x += (width - w) / 2;\n        this.y += (height - h) / 2;\n        this.width = w;\n        this.height = h;\n        return this;\n    },\n\n    bottomLeft: function() {\n\n        return new Point(this.x, this.y + this.height);\n    },\n\n    bottomLine: function() {\n\n        return new Line(this.bottomLeft(), this.bottomRight());\n    },\n\n    bottomMiddle: function() {\n\n        return new Point(this.x + this.width / 2, this.y + this.height);\n    },\n\n    center: function() {\n\n        return new Point(this.x + this.width / 2, this.y + this.height / 2);\n    },\n\n    clone: function() {\n\n        return new Rect(this);\n    },\n\n    // @return {bool} true if point p is inside me.\n    containsPoint: function(p) {\n        p = new Point(p);\n        return p.x >= this.x && p.x <= this.x + this.width && p.y >= this.y && p.y <= this.y + this.height;\n    },\n\n    // @return {bool} true if rectangle `r` is inside me.\n    containsRect: function(r) {\n\n        var r0 = new Rect(this).normalize();\n        var r1 = new Rect(r).normalize();\n        var w0 = r0.width;\n        var h0 = r0.height;\n        var w1 = r1.width;\n        var h1 = r1.height;\n\n        if (!w0 || !h0 || !w1 || !h1) {\n            // At least one of the dimensions is 0\n            return false;\n        }\n\n        var x0 = r0.x;\n        var y0 = r0.y;\n        var x1 = r1.x;\n        var y1 = r1.y;\n\n        w1 += x1;\n        w0 += x0;\n        h1 += y1;\n        h0 += y0;\n\n        return x0 <= x1 && w1 <= w0 && y0 <= y1 && h1 <= h0;\n    },\n\n    corner: function() {\n\n        return new Point(this.x + this.width, this.y + this.height);\n    },\n\n    // @return {boolean} true if rectangles are equal.\n    equals: function(r) {\n\n        var mr = (new Rect(this)).normalize();\n        var nr = (new Rect(r)).normalize();\n        return mr.x === nr.x && mr.y === nr.y && mr.width === nr.width && mr.height === nr.height;\n    },\n\n    // inflate by dx and dy, recompute origin [x, y]\n    // @param dx {delta_x} representing additional size to x\n    // @param dy {delta_y} representing additional size to y -\n    // dy param is not required -> in that case y is sized by dx\n    inflate: function(dx, dy) {\n\n        if (dx === undefined) {\n            dx = 0;\n        }\n\n        if (dy === undefined) {\n            dy = dx;\n        }\n\n        this.x -= dx;\n        this.y -= dy;\n        this.width += 2 * dx;\n        this.height += 2 * dy;\n\n        return this;\n    },\n\n    // @return {rect} if rectangles intersect, {null} if not.\n    intersect: function(r) {\n\n        var myOrigin = this.origin();\n        var myCorner = this.corner();\n        var rOrigin = r.origin();\n        var rCorner = r.corner();\n\n        // No intersection found\n        if (rCorner.x <= myOrigin.x ||\n            rCorner.y <= myOrigin.y ||\n            rOrigin.x >= myCorner.x ||\n            rOrigin.y >= myCorner.y) return null;\n\n        var x = max(myOrigin.x, rOrigin.x);\n        var y = max(myOrigin.y, rOrigin.y);\n\n        return new Rect(x, y, min(myCorner.x, rCorner.x) - x, min(myCorner.y, rCorner.y) - y);\n    },\n\n    intersectionWithLine: function(line) {\n\n        var r = this;\n        var rectLines = [r.topLine(), r.rightLine(), r.bottomLine(), r.leftLine()];\n        var points = [];\n        var dedupeArr = [];\n        var pt, i;\n\n        var n = rectLines.length;\n        for (i = 0; i < n; i++) {\n\n            pt = line.intersect(rectLines[i]);\n            if (pt !== null && dedupeArr.indexOf(pt.toString()) < 0) {\n                points.push(pt);\n                dedupeArr.push(pt.toString());\n            }\n        }\n\n        return points.length > 0 ? points : null;\n    },\n\n    // Find point on my boundary where line starting\n    // from my center ending in point p intersects me.\n    // @param {number} angle If angle is specified, intersection with rotated rectangle is computed.\n    intersectionWithLineFromCenterToPoint: function(p, angle) {\n\n        p = new Point(p);\n        var center = new Point(this.x + this.width / 2, this.y + this.height / 2);\n        var result;\n\n        if (angle) p.rotate(center, angle);\n\n        // (clockwise, starting from the top side)\n        var sides = [\n            this.topLine(),\n            this.rightLine(),\n            this.bottomLine(),\n            this.leftLine()\n        ];\n        var connector = new Line(center, p);\n\n        for (var i = sides.length - 1; i >= 0; --i) {\n            var intersection = sides[i].intersection(connector);\n            if (intersection !== null) {\n                result = intersection;\n                break;\n            }\n        }\n        if (result && angle) result.rotate(center, -angle);\n        return result;\n    },\n\n    leftLine: function() {\n\n        return new Line(this.topLeft(), this.bottomLeft());\n    },\n\n    leftMiddle: function() {\n\n        return new Point(this.x, this.y + this.height / 2);\n    },\n\n    maxRectScaleToFit: function(rect, origin) {\n\n        rect = new Rect(rect);\n        origin || (origin = rect.center());\n\n        var sx1, sx2, sx3, sx4, sy1, sy2, sy3, sy4;\n        var ox = origin.x;\n        var oy = origin.y;\n\n        // Here we find the maximal possible scale for all corner points (for x and y axis) of the rectangle,\n        // so when the scale is applied the point is still inside the rectangle.\n\n        sx1 = sx2 = sx3 = sx4 = sy1 = sy2 = sy3 = sy4 = Infinity;\n\n        // Top Left\n        var p1 = rect.topLeft();\n        if (p1.x < ox) {\n            sx1 = (this.x - ox) / (p1.x - ox);\n        }\n        if (p1.y < oy) {\n            sy1 = (this.y - oy) / (p1.y - oy);\n        }\n        // Bottom Right\n        var p2 = rect.bottomRight();\n        if (p2.x > ox) {\n            sx2 = (this.x + this.width - ox) / (p2.x - ox);\n        }\n        if (p2.y > oy) {\n            sy2 = (this.y + this.height - oy) / (p2.y - oy);\n        }\n        // Top Right\n        var p3 = rect.topRight();\n        if (p3.x > ox) {\n            sx3 = (this.x + this.width - ox) / (p3.x - ox);\n        }\n        if (p3.y < oy) {\n            sy3 = (this.y - oy) / (p3.y - oy);\n        }\n        // Bottom Left\n        var p4 = rect.bottomLeft();\n        if (p4.x < ox) {\n            sx4 = (this.x - ox) / (p4.x - ox);\n        }\n        if (p4.y > oy) {\n            sy4 = (this.y + this.height - oy) / (p4.y - oy);\n        }\n\n        return {\n            sx: min(sx1, sx2, sx3, sx4),\n            sy: min(sy1, sy2, sy3, sy4)\n        };\n    },\n\n    maxRectUniformScaleToFit: function(rect, origin) {\n\n        var scale = this.maxRectScaleToFit(rect, origin);\n        return min(scale.sx, scale.sy);\n    },\n\n    // Move and expand me.\n    // @param r {rectangle} representing deltas\n    moveAndExpand: function(r) {\n\n        this.x += r.x || 0;\n        this.y += r.y || 0;\n        this.width += r.width || 0;\n        this.height += r.height || 0;\n        return this;\n    },\n\n    // Normalize the rectangle; i.e., make it so that it has a non-negative width and height.\n    // If width < 0 the function swaps the left and right corners,\n    // and it swaps the top and bottom corners if height < 0\n    // like in http://qt-project.org/doc/qt-4.8/qrectf.html#normalized\n    normalize: function() {\n\n        var newx = this.x;\n        var newy = this.y;\n        var newwidth = this.width;\n        var newheight = this.height;\n        if (this.width < 0) {\n            newx = this.x + this.width;\n            newwidth = -this.width;\n        }\n        if (this.height < 0) {\n            newy = this.y + this.height;\n            newheight = -this.height;\n        }\n        this.x = newx;\n        this.y = newy;\n        this.width = newwidth;\n        this.height = newheight;\n        return this;\n    },\n\n    // Offset me by the specified amount.\n    offset: function(dx, dy) {\n\n        // pretend that this is a point and call offset()\n        // rewrites x and y according to dx and dy\n        return Point.prototype.offset.call(this, dx, dy);\n    },\n\n    origin: function() {\n\n        return new Point(this.x, this.y);\n    },\n\n    // @return {point} a point on my boundary nearest to the given point.\n    // @see Squeak Smalltalk, Rectangle>>pointNearestTo:\n    pointNearestToPoint: function(point) {\n\n        point = new Point(point);\n        if (this.containsPoint(point)) {\n            var side = this.sideNearestToPoint(point);\n            switch (side) {\n                case 'right':\n                    return new Point(this.x + this.width, point.y);\n                case 'left':\n                    return new Point(this.x, point.y);\n                case 'bottom':\n                    return new Point(point.x, this.y + this.height);\n                case 'top':\n                    return new Point(point.x, this.y);\n            }\n        }\n        return point.adhereToRect(this);\n    },\n\n    rightLine: function() {\n\n        return new Line(this.topRight(), this.bottomRight());\n    },\n\n    rightMiddle: function() {\n\n        return new Point(this.x + this.width, this.y + this.height / 2);\n    },\n\n    round: function(precision) {\n\n        let f = 1; // case 0\n        if (precision) {\n            switch (precision) {\n                case 1: f = 10; break;\n                case 2: f = 100; break;\n                case 3: f = 1000; break;\n                default: f = pow(10, precision); break;\n            }\n        }\n\n        this.x = round(this.x * f) / f;\n        this.y = round(this.y * f) / f;\n        this.width = round(this.width * f) / f;\n        this.height = round(this.height * f) / f;\n        return this;\n    },\n\n    // Scale rectangle with origin.\n    scale: function(sx, sy, origin) {\n\n        origin = this.origin().scale(sx, sy, origin);\n        this.x = origin.x;\n        this.y = origin.y;\n        this.width *= sx;\n        this.height *= sy;\n        return this;\n    },\n\n    // @return {string} (left|right|top|bottom) side which is nearest to point\n    // @see Squeak Smalltalk, Rectangle>>sideNearestTo:\n    sideNearestToPoint: function(point) {\n\n        point = new Point(point);\n        var distToLeft = point.x - this.x;\n        var distToRight = (this.x + this.width) - point.x;\n        var distToTop = point.y - this.y;\n        var distToBottom = (this.y + this.height) - point.y;\n        var closest = distToLeft;\n        var side = 'left';\n\n        if (distToRight < closest) {\n            closest = distToRight;\n            side = 'right';\n        }\n        if (distToTop < closest) {\n            closest = distToTop;\n            side = 'top';\n        }\n        if (distToBottom < closest) {\n            // closest = distToBottom;\n            side = 'bottom';\n        }\n        return side;\n    },\n\n    snapToGrid: function(gx, gy) {\n\n        var origin = this.origin().snapToGrid(gx, gy);\n        var corner = this.corner().snapToGrid(gx, gy);\n        this.x = origin.x;\n        this.y = origin.y;\n        this.width = corner.x - origin.x;\n        this.height = corner.y - origin.y;\n        return this;\n    },\n\n    toJSON: function() {\n\n        return { x: this.x, y: this.y, width: this.width, height: this.height };\n    },\n\n    topLine: function() {\n\n        return new Line(this.topLeft(), this.topRight());\n    },\n\n    topMiddle: function() {\n\n        return new Point(this.x + this.width / 2, this.y);\n    },\n\n    topRight: function() {\n\n        return new Point(this.x + this.width, this.y);\n    },\n\n    toString: function() {\n\n        return this.origin().toString() + ' ' + this.corner().toString();\n    },\n\n    // @return {rect} representing the union of both rectangles.\n    union: function(rect) {\n\n        return Rect.fromRectUnion(this, rect);\n    },\n\n    update: function(x, y, w, h) {\n\n        if ((Object(x) === x)) {\n            y = x.y;\n            w = x.width;\n            h = x.height;\n            x = x.x;\n        }\n\n        this.x = x || 0;\n        this.y = y || 0;\n        this.width = w || 0;\n        this.height = h || 0;\n        return this;\n    }\n};\n\nRect.prototype.bottomRight = Rect.prototype.corner;\n\nRect.prototype.topLeft = Rect.prototype.origin;\n\nRect.prototype.translate = Rect.prototype.offset;\n\n// For backwards compatibility:\nexport const rect = Rect;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}