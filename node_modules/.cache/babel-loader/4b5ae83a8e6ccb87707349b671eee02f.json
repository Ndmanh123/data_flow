{"ast":null,"code":"export function parsePoints(svgString) {\n  svgString = svgString.trim();\n  if (svgString === '') return [];\n  const points = [];\n  const coords = svgString.split(/\\s*,\\s*|\\s+/);\n  const n = coords.length;\n\n  for (let i = 0; i < n; i += 2) {\n    points.push({\n      x: +coords[i],\n      y: +coords[i + 1]\n    });\n  }\n\n  return points;\n}\nexport function clonePoints(points) {\n  const numPoints = points.length;\n  if (numPoints === 0) return [];\n  const newPoints = [];\n\n  for (let i = 0; i < numPoints; i++) {\n    const point = points[i].clone();\n    newPoints.push(point);\n  }\n\n  return newPoints;\n} // Returns a convex-hull polyline from this polyline.\n// Implements the Graham scan (https://en.wikipedia.org/wiki/Graham_scan).\n// Output polyline starts at the first element of the original polyline that is on the hull, then continues clockwise.\n// Minimal polyline is found (only vertices of the hull are reported, no collinear points).\n\nexport function convexHull(points) {\n  const {\n    abs\n  } = Math;\n  var i;\n  var n;\n  var numPoints = points.length;\n  if (numPoints === 0) return []; // if points array is empty\n  // step 1: find the starting point - point with the lowest y (if equality, highest x)\n\n  var startPoint;\n\n  for (i = 0; i < numPoints; i++) {\n    if (startPoint === undefined) {\n      // if this is the first point we see, set it as start point\n      startPoint = points[i];\n    } else if (points[i].y < startPoint.y) {\n      // start point should have lowest y from all points\n      startPoint = points[i];\n    } else if (points[i].y === startPoint.y && points[i].x > startPoint.x) {\n      // if two points have the lowest y, choose the one that has highest x\n      // there are no points to the right of startPoint - no ambiguity about theta 0\n      // if there are several coincident start point candidates, first one is reported\n      startPoint = points[i];\n    }\n  } // step 2: sort the list of points\n  // sorting by angle between line from startPoint to point and the x-axis (theta)\n  // step 2a: create the point records = [point, originalIndex, angle]\n\n\n  var sortedPointRecords = [];\n\n  for (i = 0; i < numPoints; i++) {\n    var angle = startPoint.theta(points[i]);\n\n    if (angle === 0) {\n      angle = 360; // give highest angle to start point\n      // the start point will end up at end of sorted list\n      // the start point will end up at beginning of hull points list\n    }\n\n    var entry = [points[i], i, angle];\n    sortedPointRecords.push(entry);\n  } // step 2b: sort the list in place\n\n\n  sortedPointRecords.sort(function (record1, record2) {\n    // returning a negative number here sorts record1 before record2\n    // if first angle is smaller than second, first angle should come before second\n    var sortOutput = record1[2] - record2[2]; // negative if first angle smaller\n\n    if (sortOutput === 0) {\n      // if the two angles are equal, sort by originalIndex\n      sortOutput = record2[1] - record1[1]; // negative if first index larger\n      // coincident points will be sorted in reverse-numerical order\n      // so the coincident points with lower original index will be considered first\n    }\n\n    return sortOutput;\n  }); // step 2c: duplicate start record from the top of the stack to the bottom of the stack\n\n  if (sortedPointRecords.length > 2) {\n    var startPointRecord = sortedPointRecords[sortedPointRecords.length - 1];\n    sortedPointRecords.unshift(startPointRecord);\n  } // step 3a: go through sorted points in order and find those with right turns\n  // we want to get our results in clockwise order\n\n\n  var insidePoints = {}; // dictionary of points with left turns - cannot be on the hull\n\n  var hullPointRecords = []; // stack of records with right turns - hull point candidates\n\n  var currentPointRecord;\n  var currentPoint;\n  var lastHullPointRecord;\n  var lastHullPoint;\n  var secondLastHullPointRecord;\n  var secondLastHullPoint;\n\n  while (sortedPointRecords.length !== 0) {\n    currentPointRecord = sortedPointRecords.pop();\n    currentPoint = currentPointRecord[0]; // check if point has already been discarded\n    // keys for insidePoints are stored in the form 'point.x@point.y@@originalIndex'\n\n    if (insidePoints.hasOwnProperty(currentPointRecord[0] + '@@' + currentPointRecord[1])) {\n      // this point had an incorrect turn at some previous iteration of this loop\n      // this disqualifies it from possibly being on the hull\n      continue;\n    }\n\n    var correctTurnFound = false;\n\n    while (!correctTurnFound) {\n      if (hullPointRecords.length < 2) {\n        // not enough points for comparison, just add current point\n        hullPointRecords.push(currentPointRecord);\n        correctTurnFound = true;\n      } else {\n        lastHullPointRecord = hullPointRecords.pop();\n        lastHullPoint = lastHullPointRecord[0];\n        secondLastHullPointRecord = hullPointRecords.pop();\n        secondLastHullPoint = secondLastHullPointRecord[0];\n        var crossProduct = secondLastHullPoint.cross(lastHullPoint, currentPoint);\n\n        if (crossProduct < 0) {\n          // found a right turn\n          hullPointRecords.push(secondLastHullPointRecord);\n          hullPointRecords.push(lastHullPointRecord);\n          hullPointRecords.push(currentPointRecord);\n          correctTurnFound = true;\n        } else if (crossProduct === 0) {\n          // the three points are collinear\n          // three options:\n          // there may be a 180 or 0 degree angle at lastHullPoint\n          // or two of the three points are coincident\n          var THRESHOLD = 1e-10; // we have to take rounding errors into account\n\n          var angleBetween = lastHullPoint.angleBetween(secondLastHullPoint, currentPoint);\n\n          if (abs(angleBetween - 180) < THRESHOLD) {\n            // rounding around 180 to 180\n            // if the cross product is 0 because the angle is 180 degrees\n            // discard last hull point (add to insidePoints)\n            //insidePoints.unshift(lastHullPoint);\n            insidePoints[lastHullPointRecord[0] + '@@' + lastHullPointRecord[1]] = lastHullPoint; // reenter second-to-last hull point (will be last at next iter)\n\n            hullPointRecords.push(secondLastHullPointRecord); // do not do anything with current point\n            // correct turn not found\n          } else if (lastHullPoint.equals(currentPoint) || secondLastHullPoint.equals(lastHullPoint)) {\n            // if the cross product is 0 because two points are the same\n            // discard last hull point (add to insidePoints)\n            //insidePoints.unshift(lastHullPoint);\n            insidePoints[lastHullPointRecord[0] + '@@' + lastHullPointRecord[1]] = lastHullPoint; // reenter second-to-last hull point (will be last at next iter)\n\n            hullPointRecords.push(secondLastHullPointRecord); // do not do anything with current point\n            // correct turn not found\n          } else if (abs((angleBetween + 1) % 360 - 1) < THRESHOLD) {\n            // rounding around 0 and 360 to 0\n            // if the cross product is 0 because the angle is 0 degrees\n            // remove last hull point from hull BUT do not discard it\n            // reenter second-to-last hull point (will be last at next iter)\n            hullPointRecords.push(secondLastHullPointRecord); // put last hull point back into the sorted point records list\n\n            sortedPointRecords.push(lastHullPointRecord); // we are switching the order of the 0deg and 180deg points\n            // correct turn not found\n          }\n        } else {\n          // found a left turn\n          // discard last hull point (add to insidePoints)\n          //insidePoints.unshift(lastHullPoint);\n          insidePoints[lastHullPointRecord[0] + '@@' + lastHullPointRecord[1]] = lastHullPoint; // reenter second-to-last hull point (will be last at next iter of loop)\n\n          hullPointRecords.push(secondLastHullPointRecord); // do not do anything with current point\n          // correct turn not found\n        }\n      }\n    }\n  } // at this point, hullPointRecords contains the output points in clockwise order\n  // the points start with lowest-y,highest-x startPoint, and end at the same point\n  // step 3b: remove duplicated startPointRecord from the end of the array\n\n\n  if (hullPointRecords.length > 2) {\n    hullPointRecords.pop();\n  } // step 4: find the lowest originalIndex record and put it at the beginning of hull\n\n\n  var lowestHullIndex; // the lowest originalIndex on the hull\n\n  var indexOfLowestHullIndexRecord = -1; // the index of the record with lowestHullIndex\n\n  n = hullPointRecords.length;\n\n  for (i = 0; i < n; i++) {\n    var currentHullIndex = hullPointRecords[i][1];\n\n    if (lowestHullIndex === undefined || currentHullIndex < lowestHullIndex) {\n      lowestHullIndex = currentHullIndex;\n      indexOfLowestHullIndexRecord = i;\n    }\n  }\n\n  var hullPointRecordsReordered = [];\n\n  if (indexOfLowestHullIndexRecord > 0) {\n    var newFirstChunk = hullPointRecords.slice(indexOfLowestHullIndexRecord);\n    var newSecondChunk = hullPointRecords.slice(0, indexOfLowestHullIndexRecord);\n    hullPointRecordsReordered = newFirstChunk.concat(newSecondChunk);\n  } else {\n    hullPointRecordsReordered = hullPointRecords;\n  }\n\n  var hullPoints = [];\n  n = hullPointRecordsReordered.length;\n\n  for (i = 0; i < n; i++) {\n    hullPoints.push(hullPointRecordsReordered[i][0]);\n  }\n\n  return hullPoints;\n}","map":{"version":3,"names":["parsePoints","svgString","trim","points","coords","split","n","length","i","push","x","y","clonePoints","numPoints","newPoints","point","clone","convexHull","abs","Math","startPoint","undefined","sortedPointRecords","angle","theta","entry","sort","record1","record2","sortOutput","startPointRecord","unshift","insidePoints","hullPointRecords","currentPointRecord","currentPoint","lastHullPointRecord","lastHullPoint","secondLastHullPointRecord","secondLastHullPoint","pop","hasOwnProperty","correctTurnFound","crossProduct","cross","THRESHOLD","angleBetween","equals","lowestHullIndex","indexOfLowestHullIndexRecord","currentHullIndex","hullPointRecordsReordered","newFirstChunk","slice","newSecondChunk","concat","hullPoints"],"sources":["C:/Users/Admin/dataflow-test/node_modules/jointjs/src/g/points.mjs"],"sourcesContent":["export function parsePoints(svgString) {\n    svgString = svgString.trim();\n    if (svgString === '') return [];\n    const points = [];\n    const coords = svgString.split(/\\s*,\\s*|\\s+/);\n    const n = coords.length;\n    for (let i = 0; i < n; i += 2) {\n        points.push({ x: +coords[i], y: +coords[i + 1] });\n    }\n    return points;\n}\n\nexport function clonePoints(points) {\n    const numPoints = points.length;\n    if (numPoints === 0) return [];\n    const newPoints = [];\n    for (let i = 0; i < numPoints; i++) {\n        const point = points[i].clone();\n        newPoints.push(point);\n    }\n    return newPoints;\n}\n\n// Returns a convex-hull polyline from this polyline.\n// Implements the Graham scan (https://en.wikipedia.org/wiki/Graham_scan).\n// Output polyline starts at the first element of the original polyline that is on the hull, then continues clockwise.\n// Minimal polyline is found (only vertices of the hull are reported, no collinear points).\nexport function convexHull(points) {\n\n    const { abs } = Math;\n\n    var i;\n    var n;\n\n    var numPoints = points.length;\n    if (numPoints === 0) return []; // if points array is empty\n\n    // step 1: find the starting point - point with the lowest y (if equality, highest x)\n    var startPoint;\n    for (i = 0; i < numPoints; i++) {\n        if (startPoint === undefined) {\n            // if this is the first point we see, set it as start point\n            startPoint = points[i];\n\n        } else if (points[i].y < startPoint.y) {\n            // start point should have lowest y from all points\n            startPoint = points[i];\n\n        } else if ((points[i].y === startPoint.y) && (points[i].x > startPoint.x)) {\n            // if two points have the lowest y, choose the one that has highest x\n            // there are no points to the right of startPoint - no ambiguity about theta 0\n            // if there are several coincident start point candidates, first one is reported\n            startPoint = points[i];\n        }\n    }\n\n    // step 2: sort the list of points\n    // sorting by angle between line from startPoint to point and the x-axis (theta)\n\n    // step 2a: create the point records = [point, originalIndex, angle]\n    var sortedPointRecords = [];\n    for (i = 0; i < numPoints; i++) {\n\n        var angle = startPoint.theta(points[i]);\n        if (angle === 0) {\n            angle = 360; // give highest angle to start point\n            // the start point will end up at end of sorted list\n            // the start point will end up at beginning of hull points list\n        }\n\n        var entry = [points[i], i, angle];\n        sortedPointRecords.push(entry);\n    }\n\n    // step 2b: sort the list in place\n    sortedPointRecords.sort(function(record1, record2) {\n        // returning a negative number here sorts record1 before record2\n        // if first angle is smaller than second, first angle should come before second\n\n        var sortOutput = record1[2] - record2[2];  // negative if first angle smaller\n        if (sortOutput === 0) {\n            // if the two angles are equal, sort by originalIndex\n            sortOutput = record2[1] - record1[1]; // negative if first index larger\n            // coincident points will be sorted in reverse-numerical order\n            // so the coincident points with lower original index will be considered first\n        }\n\n        return sortOutput;\n    });\n\n    // step 2c: duplicate start record from the top of the stack to the bottom of the stack\n    if (sortedPointRecords.length > 2) {\n        var startPointRecord = sortedPointRecords[sortedPointRecords.length - 1];\n        sortedPointRecords.unshift(startPointRecord);\n    }\n\n    // step 3a: go through sorted points in order and find those with right turns\n    // we want to get our results in clockwise order\n    var insidePoints = {}; // dictionary of points with left turns - cannot be on the hull\n    var hullPointRecords = []; // stack of records with right turns - hull point candidates\n\n    var currentPointRecord;\n    var currentPoint;\n    var lastHullPointRecord;\n    var lastHullPoint;\n    var secondLastHullPointRecord;\n    var secondLastHullPoint;\n    while (sortedPointRecords.length !== 0) {\n\n        currentPointRecord = sortedPointRecords.pop();\n        currentPoint = currentPointRecord[0];\n\n        // check if point has already been discarded\n        // keys for insidePoints are stored in the form 'point.x@point.y@@originalIndex'\n        if (insidePoints.hasOwnProperty(currentPointRecord[0] + '@@' + currentPointRecord[1])) {\n            // this point had an incorrect turn at some previous iteration of this loop\n            // this disqualifies it from possibly being on the hull\n            continue;\n        }\n\n        var correctTurnFound = false;\n        while (!correctTurnFound) {\n\n            if (hullPointRecords.length < 2) {\n                // not enough points for comparison, just add current point\n                hullPointRecords.push(currentPointRecord);\n                correctTurnFound = true;\n\n            } else {\n                lastHullPointRecord = hullPointRecords.pop();\n                lastHullPoint = lastHullPointRecord[0];\n                secondLastHullPointRecord = hullPointRecords.pop();\n                secondLastHullPoint = secondLastHullPointRecord[0];\n\n                var crossProduct = secondLastHullPoint.cross(lastHullPoint, currentPoint);\n\n                if (crossProduct < 0) {\n                    // found a right turn\n                    hullPointRecords.push(secondLastHullPointRecord);\n                    hullPointRecords.push(lastHullPointRecord);\n                    hullPointRecords.push(currentPointRecord);\n                    correctTurnFound = true;\n\n                } else if (crossProduct === 0) {\n                    // the three points are collinear\n                    // three options:\n                    // there may be a 180 or 0 degree angle at lastHullPoint\n                    // or two of the three points are coincident\n                    var THRESHOLD = 1e-10; // we have to take rounding errors into account\n                    var angleBetween = lastHullPoint.angleBetween(secondLastHullPoint, currentPoint);\n                    if (abs(angleBetween - 180) < THRESHOLD) { // rounding around 180 to 180\n                        // if the cross product is 0 because the angle is 180 degrees\n                        // discard last hull point (add to insidePoints)\n                        //insidePoints.unshift(lastHullPoint);\n                        insidePoints[lastHullPointRecord[0] + '@@' + lastHullPointRecord[1]] = lastHullPoint;\n                        // reenter second-to-last hull point (will be last at next iter)\n                        hullPointRecords.push(secondLastHullPointRecord);\n                        // do not do anything with current point\n                        // correct turn not found\n\n                    } else if (lastHullPoint.equals(currentPoint) || secondLastHullPoint.equals(lastHullPoint)) {\n                        // if the cross product is 0 because two points are the same\n                        // discard last hull point (add to insidePoints)\n                        //insidePoints.unshift(lastHullPoint);\n                        insidePoints[lastHullPointRecord[0] + '@@' + lastHullPointRecord[1]] = lastHullPoint;\n                        // reenter second-to-last hull point (will be last at next iter)\n                        hullPointRecords.push(secondLastHullPointRecord);\n                        // do not do anything with current point\n                        // correct turn not found\n\n                    } else if (abs(((angleBetween + 1) % 360) - 1) < THRESHOLD) { // rounding around 0 and 360 to 0\n                        // if the cross product is 0 because the angle is 0 degrees\n                        // remove last hull point from hull BUT do not discard it\n                        // reenter second-to-last hull point (will be last at next iter)\n                        hullPointRecords.push(secondLastHullPointRecord);\n                        // put last hull point back into the sorted point records list\n                        sortedPointRecords.push(lastHullPointRecord);\n                        // we are switching the order of the 0deg and 180deg points\n                        // correct turn not found\n                    }\n\n                } else {\n                    // found a left turn\n                    // discard last hull point (add to insidePoints)\n                    //insidePoints.unshift(lastHullPoint);\n                    insidePoints[lastHullPointRecord[0] + '@@' + lastHullPointRecord[1]] = lastHullPoint;\n                    // reenter second-to-last hull point (will be last at next iter of loop)\n                    hullPointRecords.push(secondLastHullPointRecord);\n                    // do not do anything with current point\n                    // correct turn not found\n                }\n            }\n        }\n    }\n    // at this point, hullPointRecords contains the output points in clockwise order\n    // the points start with lowest-y,highest-x startPoint, and end at the same point\n\n    // step 3b: remove duplicated startPointRecord from the end of the array\n    if (hullPointRecords.length > 2) {\n        hullPointRecords.pop();\n    }\n\n    // step 4: find the lowest originalIndex record and put it at the beginning of hull\n    var lowestHullIndex; // the lowest originalIndex on the hull\n    var indexOfLowestHullIndexRecord = -1; // the index of the record with lowestHullIndex\n    n = hullPointRecords.length;\n    for (i = 0; i < n; i++) {\n\n        var currentHullIndex = hullPointRecords[i][1];\n\n        if (lowestHullIndex === undefined || currentHullIndex < lowestHullIndex) {\n            lowestHullIndex = currentHullIndex;\n            indexOfLowestHullIndexRecord = i;\n        }\n    }\n\n    var hullPointRecordsReordered = [];\n    if (indexOfLowestHullIndexRecord > 0) {\n        var newFirstChunk = hullPointRecords.slice(indexOfLowestHullIndexRecord);\n        var newSecondChunk = hullPointRecords.slice(0, indexOfLowestHullIndexRecord);\n        hullPointRecordsReordered = newFirstChunk.concat(newSecondChunk);\n\n    } else {\n        hullPointRecordsReordered = hullPointRecords;\n    }\n\n    var hullPoints = [];\n    n = hullPointRecordsReordered.length;\n    for (i = 0; i < n; i++) {\n        hullPoints.push(hullPointRecordsReordered[i][0]);\n    }\n\n    return hullPoints;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}