{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport { config } from '../config/index.mjs';\nimport { View } from '../mvc/index.mjs';\nimport { assign, guid, omit, parseDOMJSON, isFunction, isObject, isPlainObject, isBoolean, isEmpty, isString, toKebabCase, result, sortedIndex, merge, uniq } from '../util/index.mjs';\nimport { Point, Rect } from '../g/index.mjs';\nimport V from '../V/index.mjs';\nimport $ from 'jquery';\nimport { HighlighterView } from './HighlighterView.mjs';\nconst HighlightingTypes = {\n  DEFAULT: 'default',\n  EMBEDDING: 'embedding',\n  CONNECTING: 'connecting',\n  MAGNET_AVAILABILITY: 'magnetAvailability',\n  ELEMENT_AVAILABILITY: 'elementAvailability'\n}; // CellView base view and controller.\n// --------------------------------------------\n// This is the base view and controller for `ElementView` and `LinkView`.\n\nexport const CellView = View.extend({\n  tagName: 'g',\n  svgElement: true,\n  selector: 'root',\n  metrics: null,\n  className: function () {\n    var classNames = ['cell'];\n    var type = this.model.get('type');\n\n    if (type) {\n      type.toLowerCase().split('.').forEach(function (value, index, list) {\n        classNames.push('type-' + list.slice(0, index + 1).join('-'));\n      });\n    }\n\n    return classNames.join(' ');\n  },\n  _presentationAttributes: null,\n  _flags: null,\n  setFlags: function () {\n    var flags = {};\n    var attributes = {};\n    var shift = 0;\n    var i, n, label;\n    var presentationAttributes = result(this, 'presentationAttributes');\n\n    for (var attribute in presentationAttributes) {\n      if (!presentationAttributes.hasOwnProperty(attribute)) continue;\n      var labels = presentationAttributes[attribute];\n      if (!Array.isArray(labels)) labels = [labels];\n\n      for (i = 0, n = labels.length; i < n; i++) {\n        label = labels[i];\n        var flag = flags[label];\n\n        if (!flag) {\n          flag = flags[label] = 1 << shift++;\n        }\n\n        attributes[attribute] |= flag;\n      }\n    }\n\n    var initFlag = result(this, 'initFlag');\n    if (!Array.isArray(initFlag)) initFlag = [initFlag];\n\n    for (i = 0, n = initFlag.length; i < n; i++) {\n      label = initFlag[i];\n      if (!flags[label]) flags[label] = 1 << shift++;\n    } // 26 - 30 are reserved for paper flags\n    // 31+ overflows maximal number\n\n\n    if (shift > 25) throw new Error('dia.CellView: Maximum number of flags exceeded.');\n    this._flags = flags;\n    this._presentationAttributes = attributes;\n  },\n  hasFlag: function (flag, label) {\n    return flag & this.getFlag(label);\n  },\n  removeFlag: function (flag, label) {\n    return flag ^ flag & this.getFlag(label);\n  },\n  getFlag: function (label) {\n    var flags = this._flags;\n    if (!flags) return 0;\n    var flag = 0;\n\n    if (Array.isArray(label)) {\n      for (var i = 0, n = label.length; i < n; i++) flag |= flags[label[i]];\n    } else {\n      flag |= flags[label];\n    }\n\n    return flag;\n  },\n  attributes: function () {\n    var cell = this.model;\n    return {\n      'model-id': cell.id,\n      'data-type': cell.attributes.type\n    };\n  },\n  constructor: function (options) {\n    // Make sure a global unique id is assigned to this view. Store this id also to the properties object.\n    // The global unique id makes sure that the same view can be rendered on e.g. different machines and\n    // still be associated to the same object among all those clients. This is necessary for real-time\n    // collaboration mechanism.\n    options.id = options.id || guid(this);\n    View.call(this, options);\n  },\n  initialize: function () {\n    this.setFlags();\n    View.prototype.initialize.apply(this, arguments);\n    this.cleanNodesCache(); // Store reference to this to the <g> DOM element so that the view is accessible through the DOM tree.\n\n    this.$el.data('view', this);\n    this.startListening();\n  },\n\n  onMount() {// To be overridden\n  },\n\n  startListening: function () {\n    this.listenTo(this.model, 'change', this.onAttributesChange);\n  },\n  onAttributesChange: function (model, opt) {\n    var flag = model.getChangeFlag(this._presentationAttributes);\n    if (opt.updateHandled || !flag) return;\n    if (opt.dirty && this.hasFlag(flag, 'UPDATE')) flag |= this.getFlag('RENDER'); // TODO: tool changes does not need to be sync\n    // Fix Segments tools\n\n    if (opt.tool) opt.async = false;\n    this.requestUpdate(flag, opt);\n  },\n  requestUpdate: function (flags, opt) {\n    const {\n      paper\n    } = this;\n\n    if (paper && flags > 0) {\n      paper.requestViewUpdate(this, flags, this.UPDATE_PRIORITY, opt);\n    }\n  },\n  parseDOMJSON: function (markup, root) {\n    var doc = parseDOMJSON(markup);\n    var selectors = doc.selectors;\n    var groups = doc.groupSelectors;\n\n    for (var group in groups) {\n      if (selectors[group]) throw new Error('dia.CellView: ambiguous group selector');\n      selectors[group] = groups[group];\n    }\n\n    if (root) {\n      var rootSelector = this.selector;\n      if (selectors[rootSelector]) throw new Error('dia.CellView: ambiguous root selector.');\n      selectors[rootSelector] = root;\n    }\n\n    return {\n      fragment: doc.fragment,\n      selectors: selectors\n    };\n  },\n  // Return `true` if cell link is allowed to perform a certain UI `feature`.\n  // Example: `can('vertexMove')`, `can('labelMove')`.\n  can: function (feature) {\n    var interactive = isFunction(this.options.interactive) ? this.options.interactive(this) : this.options.interactive;\n    return isObject(interactive) && interactive[feature] !== false || isBoolean(interactive) && interactive !== false;\n  },\n  findBySelector: function (selector, root, selectors) {\n    root || (root = this.el);\n    selectors || (selectors = this.selectors); // These are either descendants of `this.$el` of `this.$el` itself.\n    // `.` is a special selector used to select the wrapping `<g>` element.\n\n    if (!selector || selector === '.') return [root];\n\n    if (selectors) {\n      var nodes = selectors[selector];\n\n      if (nodes) {\n        if (Array.isArray(nodes)) return nodes;\n        return [nodes];\n      }\n    } // Maintaining backwards compatibility\n    // e.g. `circle:first` would fail with querySelector() call\n\n\n    if (config.useCSSSelectors) return $(root).find(selector).toArray();\n    return [];\n  },\n  notify: function (eventName) {\n    if (this.paper) {\n      var args = Array.prototype.slice.call(arguments, 1); // Trigger the event on both the element itself and also on the paper.\n\n      this.trigger.apply(this, [eventName].concat(args)); // Paper event handlers receive the view object as the first argument.\n\n      this.paper.trigger.apply(this.paper, [eventName, this].concat(args));\n    }\n  },\n  getBBox: function (opt) {\n    var bbox;\n\n    if (opt && opt.useModelGeometry) {\n      var model = this.model;\n      bbox = model.getBBox().bbox(model.angle());\n    } else {\n      bbox = this.getNodeBBox(this.el);\n    }\n\n    return this.paper.localToPaperRect(bbox);\n  },\n  getNodeBBox: function (magnet) {\n    var rect = this.getNodeBoundingRect(magnet);\n    var magnetMatrix = this.getNodeMatrix(magnet);\n    var translateMatrix = this.getRootTranslateMatrix();\n    var rotateMatrix = this.getRootRotateMatrix();\n    return V.transformRect(rect, translateMatrix.multiply(rotateMatrix).multiply(magnetMatrix));\n  },\n  getNodeUnrotatedBBox: function (magnet) {\n    var rect = this.getNodeBoundingRect(magnet);\n    var magnetMatrix = this.getNodeMatrix(magnet);\n    var translateMatrix = this.getRootTranslateMatrix();\n    return V.transformRect(rect, translateMatrix.multiply(magnetMatrix));\n  },\n  getRootTranslateMatrix: function () {\n    var model = this.model;\n    var position = model.position();\n    var mt = V.createSVGMatrix().translate(position.x, position.y);\n    return mt;\n  },\n  getRootRotateMatrix: function () {\n    var mr = V.createSVGMatrix();\n    var model = this.model;\n    var angle = model.angle();\n\n    if (angle) {\n      var bbox = model.getBBox();\n      var cx = bbox.width / 2;\n      var cy = bbox.height / 2;\n      mr = mr.translate(cx, cy).rotate(angle).translate(-cx, -cy);\n    }\n\n    return mr;\n  },\n  _notifyHighlight: function (eventName, el, opt = {}) {\n    const {\n      el: rootNode\n    } = this;\n    let node;\n\n    if (typeof el === 'string') {\n      [node = rootNode] = this.findBySelector(el);\n    } else {\n      [node = rootNode] = this.$(el);\n    } // set partial flag if the highlighted element is not the entire view.\n\n\n    opt.partial = node !== rootNode; // translate type flag into a type string\n\n    if (opt.type === undefined) {\n      let type;\n\n      switch (true) {\n        case opt.embedding:\n          type = HighlightingTypes.EMBEDDING;\n          break;\n\n        case opt.connecting:\n          type = HighlightingTypes.CONNECTING;\n          break;\n\n        case opt.magnetAvailability:\n          type = HighlightingTypes.MAGNET_AVAILABILITY;\n          break;\n\n        case opt.elementAvailability:\n          type = HighlightingTypes.ELEMENT_AVAILABILITY;\n          break;\n\n        default:\n          type = HighlightingTypes.DEFAULT;\n          break;\n      }\n\n      opt.type = type;\n    }\n\n    this.notify(eventName, node, opt);\n    return this;\n  },\n  highlight: function (el, opt) {\n    return this._notifyHighlight('cell:highlight', el, opt);\n  },\n  unhighlight: function (el, opt = {}) {\n    return this._notifyHighlight('cell:unhighlight', el, opt);\n  },\n  // Find the closest element that has the `magnet` attribute set to `true`. If there was not such\n  // an element found, return the root element of the cell view.\n  findMagnet: function (el) {\n    const root = this.el;\n    let magnet = this.$(el)[0];\n\n    if (!magnet) {\n      magnet = root;\n    }\n\n    do {\n      const magnetAttribute = magnet.getAttribute('magnet');\n      const isMagnetRoot = magnet === root;\n\n      if ((magnetAttribute || isMagnetRoot) && magnetAttribute !== 'false') {\n        return magnet;\n      }\n\n      if (isMagnetRoot) {\n        // If the overall cell has set `magnet === false`, then return `undefined` to\n        // announce there is no magnet found for this cell.\n        // This is especially useful to set on cells that have 'ports'. In this case,\n        // only the ports have set `magnet === true` and the overall element has `magnet === false`.\n        return undefined;\n      }\n\n      magnet = magnet.parentNode;\n    } while (magnet);\n\n    return undefined;\n  },\n  findProxyNode: function (el, type) {\n    el || (el = this.el);\n    const nodeSelector = el.getAttribute(`${type}-selector`);\n\n    if (nodeSelector) {\n      const [proxyNode] = this.findBySelector(nodeSelector);\n      if (proxyNode) return proxyNode;\n    }\n\n    return el;\n  },\n  // Construct a unique selector for the `el` element within this view.\n  // `prevSelector` is being collected through the recursive call.\n  // No value for `prevSelector` is expected when using this method.\n  getSelector: function (el, prevSelector) {\n    var selector;\n\n    if (el === this.el) {\n      if (typeof prevSelector === 'string') selector = '> ' + prevSelector;\n      return selector;\n    }\n\n    if (el) {\n      var nthChild = V(el).index() + 1;\n      selector = el.tagName + ':nth-child(' + nthChild + ')';\n\n      if (prevSelector) {\n        selector += ' > ' + prevSelector;\n      }\n\n      selector = this.getSelector(el.parentNode, selector);\n    }\n\n    return selector;\n  },\n  addLinkFromMagnet: function (magnet, x, y) {\n    var paper = this.paper;\n    var graph = paper.model;\n    var link = paper.getDefaultLink(this, magnet);\n    link.set({\n      source: this.getLinkEnd(magnet, x, y, link, 'source'),\n      target: {\n        x: x,\n        y: y\n      }\n    }).addTo(graph, {\n      async: false,\n      ui: true\n    });\n    return link.findView(paper);\n  },\n  getLinkEnd: function (magnet, ...args) {\n    var model = this.model;\n    var id = model.id;\n    var port = this.findAttribute('port', magnet); // Find a unique `selector` of the element under pointer that is a magnet.\n\n    var selector = magnet.getAttribute('joint-selector');\n    var end = {\n      id: id\n    };\n    if (selector != null) end.magnet = selector;\n\n    if (port != null) {\n      end.port = port;\n\n      if (!model.hasPort(port) && !selector) {\n        // port created via the `port` attribute (not API)\n        end.selector = this.getSelector(magnet);\n      }\n    } else if (selector == null && this.el !== magnet) {\n      end.selector = this.getSelector(magnet);\n    }\n\n    return this.customizeLinkEnd(end, magnet, ...args);\n  },\n  customizeLinkEnd: function (end, magnet, x, y, link, endType) {\n    const {\n      paper\n    } = this;\n    const {\n      connectionStrategy\n    } = paper.options;\n\n    if (typeof connectionStrategy === 'function') {\n      var strategy = connectionStrategy.call(paper, end, this, magnet, new Point(x, y), link, endType, paper);\n      if (strategy) return strategy;\n    }\n\n    return end;\n  },\n  getMagnetFromLinkEnd: function (end) {\n    var root = this.el;\n    var port = end.port;\n    var selector = end.magnet;\n    var model = this.model;\n    var magnet;\n\n    if (port != null && model.isElement() && model.hasPort(port)) {\n      magnet = this.findPortNode(port, selector) || root;\n    } else {\n      if (!selector) selector = end.selector;\n\n      if (!selector && port != null) {\n        // link end has only `id` and `port` property referencing\n        // a port created via the `port` attribute (not API).\n        selector = '[port=\"' + port + '\"]';\n      }\n\n      magnet = this.findBySelector(selector, root, this.selectors)[0];\n    }\n\n    return this.findProxyNode(magnet, 'magnet');\n  },\n  dragLinkStart: function (evt, magnet, x, y) {\n    this.model.startBatch('add-link');\n    const linkView = this.addLinkFromMagnet(magnet, x, y); // backwards compatibility events\n\n    linkView.notifyPointerdown(evt, x, y);\n    linkView.eventData(evt, linkView.startArrowheadMove('target', {\n      whenNotAllowed: 'remove'\n    }));\n    this.eventData(evt, {\n      linkView\n    });\n  },\n  dragLink: function (evt, x, y) {\n    var data = this.eventData(evt);\n    var linkView = data.linkView;\n\n    if (linkView) {\n      linkView.pointermove(evt, x, y);\n    } else {\n      var paper = this.paper;\n      var magnetThreshold = paper.options.magnetThreshold;\n      var currentTarget = this.getEventTarget(evt);\n      var targetMagnet = data.targetMagnet;\n\n      if (magnetThreshold === 'onleave') {\n        // magnetThreshold when the pointer leaves the magnet\n        if (targetMagnet === currentTarget || V(targetMagnet).contains(currentTarget)) return;\n      } else {\n        // magnetThreshold defined as a number of movements\n        if (paper.eventData(evt).mousemoved <= magnetThreshold) return;\n      }\n\n      this.dragLinkStart(evt, targetMagnet, x, y);\n    }\n  },\n  dragLinkEnd: function (evt, x, y) {\n    var data = this.eventData(evt);\n    var linkView = data.linkView;\n    if (!linkView) return;\n    linkView.pointerup(evt, x, y);\n    this.model.stopBatch('add-link');\n  },\n  getAttributeDefinition: function (attrName) {\n    return this.model.constructor.getAttributeDefinition(attrName);\n  },\n  setNodeAttributes: function (node, attrs) {\n    if (!isEmpty(attrs)) {\n      if (node instanceof SVGElement) {\n        V(node).attr(attrs);\n      } else {\n        $(node).attr(attrs);\n      }\n    }\n  },\n  processNodeAttributes: function (node, attrs) {\n    var attrName, attrVal, def, i, n;\n    var normalAttrs, setAttrs, positionAttrs, offsetAttrs;\n    var relatives = []; // divide the attributes between normal and special\n\n    for (attrName in attrs) {\n      if (!attrs.hasOwnProperty(attrName)) continue;\n      attrVal = attrs[attrName];\n      def = this.getAttributeDefinition(attrName);\n\n      if (def && (!isFunction(def.qualify) || def.qualify.call(this, attrVal, node, attrs))) {\n        if (isString(def.set)) {\n          normalAttrs || (normalAttrs = {});\n          normalAttrs[def.set] = attrVal;\n        }\n\n        if (attrVal !== null) {\n          relatives.push(attrName, def);\n        }\n      } else {\n        normalAttrs || (normalAttrs = {});\n        normalAttrs[toKebabCase(attrName)] = attrVal;\n      }\n    } // handle the rest of attributes via related method\n    // from the special attributes namespace.\n\n\n    for (i = 0, n = relatives.length; i < n; i += 2) {\n      attrName = relatives[i];\n      def = relatives[i + 1];\n      attrVal = attrs[attrName];\n\n      if (isFunction(def.set)) {\n        setAttrs || (setAttrs = {});\n        setAttrs[attrName] = attrVal;\n      }\n\n      if (isFunction(def.position)) {\n        positionAttrs || (positionAttrs = {});\n        positionAttrs[attrName] = attrVal;\n      }\n\n      if (isFunction(def.offset)) {\n        offsetAttrs || (offsetAttrs = {});\n        offsetAttrs[attrName] = attrVal;\n      }\n    }\n\n    return {\n      raw: attrs,\n      normal: normalAttrs,\n      set: setAttrs,\n      position: positionAttrs,\n      offset: offsetAttrs\n    };\n  },\n  updateRelativeAttributes: function (node, attrs, refBBox, opt) {\n    opt || (opt = {});\n    var attrName, attrVal, def;\n    var rawAttrs = attrs.raw || {};\n    var nodeAttrs = attrs.normal || {};\n    var setAttrs = attrs.set;\n    var positionAttrs = attrs.position;\n    var offsetAttrs = attrs.offset;\n\n    for (attrName in setAttrs) {\n      attrVal = setAttrs[attrName];\n      def = this.getAttributeDefinition(attrName); // SET - set function should return attributes to be set on the node,\n      // which will affect the node dimensions based on the reference bounding\n      // box. e.g. `width`, `height`, `d`, `rx`, `ry`, `points\n\n      var setResult = def.set.call(this, attrVal, refBBox.clone(), node, rawAttrs);\n\n      if (isObject(setResult)) {\n        assign(nodeAttrs, setResult);\n      } else if (setResult !== undefined) {\n        nodeAttrs[attrName] = setResult;\n      }\n    }\n\n    if (node instanceof HTMLElement) {\n      // TODO: setting the `transform` attribute on HTMLElements\n      // via `node.style.transform = 'matrix(...)';` would introduce\n      // a breaking change (e.g. basic.TextBlock).\n      this.setNodeAttributes(node, nodeAttrs);\n      return;\n    } // The final translation of the subelement.\n\n\n    var nodeTransform = nodeAttrs.transform;\n    var nodeMatrix = V.transformStringToMatrix(nodeTransform);\n    var nodePosition = Point(nodeMatrix.e, nodeMatrix.f);\n\n    if (nodeTransform) {\n      nodeAttrs = omit(nodeAttrs, 'transform');\n      nodeMatrix.e = nodeMatrix.f = 0;\n    } // Calculate node scale determined by the scalable group\n    // only if later needed.\n\n\n    var sx, sy, translation;\n\n    if (positionAttrs || offsetAttrs) {\n      var nodeScale = this.getNodeScale(node, opt.scalableNode);\n      sx = nodeScale.sx;\n      sy = nodeScale.sy;\n    }\n\n    var positioned = false;\n\n    for (attrName in positionAttrs) {\n      attrVal = positionAttrs[attrName];\n      def = this.getAttributeDefinition(attrName); // POSITION - position function should return a point from the\n      // reference bounding box. The default position of the node is x:0, y:0 of\n      // the reference bounding box or could be further specify by some\n      // SVG attributes e.g. `x`, `y`\n\n      translation = def.position.call(this, attrVal, refBBox.clone(), node, rawAttrs);\n\n      if (translation) {\n        nodePosition.offset(Point(translation).scale(sx, sy));\n        positioned || (positioned = true);\n      }\n    } // The node bounding box could depend on the `size` set from the previous loop.\n    // Here we know, that all the size attributes have been already set.\n\n\n    this.setNodeAttributes(node, nodeAttrs);\n    var offseted = false;\n\n    if (offsetAttrs) {\n      // Check if the node is visible\n      var nodeBoundingRect = this.getNodeBoundingRect(node);\n\n      if (nodeBoundingRect.width > 0 && nodeBoundingRect.height > 0) {\n        var nodeBBox = V.transformRect(nodeBoundingRect, nodeMatrix).scale(1 / sx, 1 / sy);\n\n        for (attrName in offsetAttrs) {\n          attrVal = offsetAttrs[attrName];\n          def = this.getAttributeDefinition(attrName); // OFFSET - offset function should return a point from the element\n          // bounding box. The default offset point is x:0, y:0 (origin) or could be further\n          // specify with some SVG attributes e.g. `text-anchor`, `cx`, `cy`\n\n          translation = def.offset.call(this, attrVal, nodeBBox, node, rawAttrs);\n\n          if (translation) {\n            nodePosition.offset(Point(translation).scale(sx, sy));\n            offseted || (offseted = true);\n          }\n        }\n      }\n    } // Do not touch node's transform attribute if there is no transformation applied.\n\n\n    if (nodeTransform !== undefined || positioned || offseted) {\n      // Round the coordinates to 1 decimal point.\n      nodePosition.round(1);\n      nodeMatrix.e = nodePosition.x;\n      nodeMatrix.f = nodePosition.y;\n      node.setAttribute('transform', V.matrixToTransformString(nodeMatrix)); // TODO: store nodeMatrix metrics?\n    }\n  },\n  getNodeScale: function (node, scalableNode) {\n    // Check if the node is a descendant of the scalable group.\n    var sx, sy;\n\n    if (scalableNode && scalableNode.contains(node)) {\n      var scale = scalableNode.scale();\n      sx = 1 / scale.sx;\n      sy = 1 / scale.sy;\n    } else {\n      sx = 1;\n      sy = 1;\n    }\n\n    return {\n      sx: sx,\n      sy: sy\n    };\n  },\n  cleanNodesCache: function () {\n    this.metrics = {};\n  },\n  nodeCache: function (magnet) {\n    var metrics = this.metrics; // Don't use cache? It most likely a custom view with overridden update.\n\n    if (!metrics) return {};\n    var id = V.ensureId(magnet);\n    var value = metrics[id];\n    if (!value) value = metrics[id] = {};\n    return value;\n  },\n  getNodeData: function (magnet) {\n    var metrics = this.nodeCache(magnet);\n    if (!metrics.data) metrics.data = {};\n    return metrics.data;\n  },\n  getNodeBoundingRect: function (magnet) {\n    var metrics = this.nodeCache(magnet);\n    if (metrics.boundingRect === undefined) metrics.boundingRect = V(magnet).getBBox();\n    return new Rect(metrics.boundingRect);\n  },\n  getNodeMatrix: function (magnet) {\n    var metrics = this.nodeCache(magnet);\n\n    if (metrics.magnetMatrix === undefined) {\n      var target = this.rotatableNode || this.el;\n      metrics.magnetMatrix = V(magnet).getTransformToElement(target);\n    }\n\n    return V.createSVGMatrix(metrics.magnetMatrix);\n  },\n  getNodeShape: function (magnet) {\n    var metrics = this.nodeCache(magnet);\n    if (metrics.geometryShape === undefined) metrics.geometryShape = V(magnet).toGeometryShape();\n    return metrics.geometryShape.clone();\n  },\n  isNodeConnection: function (node) {\n    return this.model.isLink() && (!node || node === this.el);\n  },\n  findNodesAttributes: function (attrs, root, selectorCache, selectors) {\n    var i, n, nodeAttrs, nodeId;\n    var nodesAttrs = {};\n    var mergeIds = [];\n\n    for (var selector in attrs) {\n      if (!attrs.hasOwnProperty(selector)) continue;\n      nodeAttrs = attrs[selector];\n      if (!isPlainObject(nodeAttrs)) continue; // Not a valid selector-attributes pair\n\n      var selected = selectorCache[selector] = this.findBySelector(selector, root, selectors);\n\n      for (i = 0, n = selected.length; i < n; i++) {\n        var node = selected[i];\n        nodeId = V.ensureId(node); // \"unique\" selectors are selectors that referencing a single node (defined by `selector`)\n        // groupSelector referencing a single node is not \"unique\"\n\n        var unique = selectors && selectors[selector] === node;\n        var prevNodeAttrs = nodesAttrs[nodeId];\n\n        if (prevNodeAttrs) {\n          // Note, that nodes referenced by deprecated `CSS selectors` are not taken into account.\n          // e.g. css:`.circle` and selector:`circle` can be applied in a random order\n          if (!prevNodeAttrs.array) {\n            mergeIds.push(nodeId);\n            prevNodeAttrs.array = true;\n            prevNodeAttrs.attributes = [prevNodeAttrs.attributes];\n            prevNodeAttrs.selectedLength = [prevNodeAttrs.selectedLength];\n          }\n\n          var attributes = prevNodeAttrs.attributes;\n          var selectedLength = prevNodeAttrs.selectedLength;\n\n          if (unique) {\n            // node referenced by `selector`\n            attributes.unshift(nodeAttrs);\n            selectedLength.unshift(-1);\n          } else {\n            // node referenced by `groupSelector`\n            var sortIndex = sortedIndex(selectedLength, n);\n            attributes.splice(sortIndex, 0, nodeAttrs);\n            selectedLength.splice(sortIndex, 0, n);\n          }\n        } else {\n          nodesAttrs[nodeId] = {\n            attributes: nodeAttrs,\n            selectedLength: unique ? -1 : n,\n            node: node,\n            array: false\n          };\n        }\n      }\n    }\n\n    for (i = 0, n = mergeIds.length; i < n; i++) {\n      nodeId = mergeIds[i];\n      nodeAttrs = nodesAttrs[nodeId];\n      nodeAttrs.attributes = merge({}, ...nodeAttrs.attributes.reverse());\n    }\n\n    return nodesAttrs;\n  },\n  getEventTarget: function (evt, opt = {}) {\n    // Touchmove/Touchend event's target is not reflecting the element under the coordinates as mousemove does.\n    // It holds the element when a touchstart triggered.\n    const {\n      target,\n      type,\n      clientX = 0,\n      clientY = 0\n    } = evt;\n\n    if (opt.fromPoint || type === 'touchmove' || type === 'touchend') {\n      return document.elementFromPoint(clientX, clientY);\n    }\n\n    return target;\n  },\n  // Default is to process the `model.attributes.attrs` object and set attributes on subelements based on the selectors,\n  // unless `attrs` parameter was passed.\n  updateDOMSubtreeAttributes: function (rootNode, attrs, opt) {\n    opt || (opt = {});\n    opt.rootBBox || (opt.rootBBox = Rect());\n    opt.selectors || (opt.selectors = this.selectors); // selector collection to use\n    // Cache table for query results and bounding box calculation.\n    // Note that `selectorCache` needs to be invalidated for all\n    // `updateAttributes` calls, as the selectors might pointing\n    // to nodes designated by an attribute or elements dynamically\n    // created.\n\n    var selectorCache = {};\n    var bboxCache = {};\n    var relativeItems = [];\n    var relativeRefItems = [];\n    var item, node, nodeAttrs, nodeData, processedAttrs;\n    var roAttrs = opt.roAttributes;\n    var nodesAttrs = this.findNodesAttributes(roAttrs || attrs, rootNode, selectorCache, opt.selectors); // `nodesAttrs` are different from all attributes, when\n    // rendering only  attributes sent to this method.\n\n    var nodesAllAttrs = roAttrs ? this.findNodesAttributes(attrs, rootNode, selectorCache, opt.selectors) : nodesAttrs;\n\n    for (var nodeId in nodesAttrs) {\n      nodeData = nodesAttrs[nodeId];\n      nodeAttrs = nodeData.attributes;\n      node = nodeData.node;\n      processedAttrs = this.processNodeAttributes(node, nodeAttrs);\n\n      if (!processedAttrs.set && !processedAttrs.position && !processedAttrs.offset) {\n        // Set all the normal attributes right on the SVG/HTML element.\n        this.setNodeAttributes(node, processedAttrs.normal);\n      } else {\n        var nodeAllAttrs = nodesAllAttrs[nodeId] && nodesAllAttrs[nodeId].attributes;\n        var refSelector = nodeAllAttrs && nodeAttrs.ref === undefined ? nodeAllAttrs.ref : nodeAttrs.ref;\n        var refNode;\n\n        if (refSelector) {\n          refNode = (selectorCache[refSelector] || this.findBySelector(refSelector, rootNode, opt.selectors))[0];\n\n          if (!refNode) {\n            throw new Error('dia.CellView: \"' + refSelector + '\" reference does not exist.');\n          }\n        } else {\n          refNode = null;\n        }\n\n        item = {\n          node: node,\n          refNode: refNode,\n          processedAttributes: processedAttrs,\n          allAttributes: nodeAllAttrs\n        };\n\n        if (refNode) {\n          // If an element in the list is positioned relative to this one, then\n          // we want to insert this one before it in the list.\n          var itemIndex = relativeRefItems.findIndex(function (item) {\n            return item.refNode === node;\n          });\n\n          if (itemIndex > -1) {\n            relativeRefItems.splice(itemIndex, 0, item);\n          } else {\n            relativeRefItems.push(item);\n          }\n        } else {\n          // A node with no ref attribute. To be updated before the nodes referencing other nodes.\n          // The order of no-ref-items is not specified/important.\n          relativeItems.push(item);\n        }\n      }\n    }\n\n    relativeItems.push(...relativeRefItems);\n    var rotatableMatrix;\n\n    for (var i = 0, n = relativeItems.length; i < n; i++) {\n      item = relativeItems[i];\n      node = item.node;\n      refNode = item.refNode; // Find the reference element bounding box. If no reference was provided, we\n      // use the optional bounding box.\n\n      var vRotatable = V(opt.rotatableNode);\n      var refNodeId = refNode ? V.ensureId(refNode) : '';\n      var isRefNodeRotatable = !!vRotatable && !!refNode && vRotatable.contains(refNode);\n      var unrotatedRefBBox = bboxCache[refNodeId];\n\n      if (!unrotatedRefBBox) {\n        // Get the bounding box of the reference element relative to the `rotatable` `<g>` (without rotation)\n        // or to the root `<g>` element if no rotatable group present if reference node present.\n        // Uses the bounding box provided.\n        var transformationTarget = isRefNodeRotatable ? vRotatable : rootNode;\n        unrotatedRefBBox = bboxCache[refNodeId] = refNode ? V(refNode).getBBox({\n          target: transformationTarget\n        }) : opt.rootBBox;\n      }\n\n      if (roAttrs) {\n        // if there was a special attribute affecting the position amongst passed-in attributes\n        // we have to merge it with the rest of the element's attributes as they are necessary\n        // to update the position relatively (i.e `ref-x` && 'ref-dx')\n        processedAttrs = this.processNodeAttributes(node, item.allAttributes);\n        this.mergeProcessedAttributes(processedAttrs, item.processedAttributes);\n      } else {\n        processedAttrs = item.processedAttributes;\n      }\n\n      var refBBox = unrotatedRefBBox;\n\n      if (isRefNodeRotatable && !vRotatable.contains(node)) {\n        // if the referenced node is inside the rotatable group while the updated node is outside,\n        // we need to take the rotatable node transformation into account\n        if (!rotatableMatrix) rotatableMatrix = V.transformStringToMatrix(vRotatable.attr('transform'));\n        refBBox = V.transformRect(unrotatedRefBBox, rotatableMatrix);\n      }\n\n      this.updateRelativeAttributes(node, processedAttrs, refBBox, opt);\n    }\n  },\n  mergeProcessedAttributes: function (processedAttrs, roProcessedAttrs) {\n    processedAttrs.set || (processedAttrs.set = {});\n    processedAttrs.position || (processedAttrs.position = {});\n    processedAttrs.offset || (processedAttrs.offset = {});\n    assign(processedAttrs.set, roProcessedAttrs.set);\n    assign(processedAttrs.position, roProcessedAttrs.position);\n    assign(processedAttrs.offset, roProcessedAttrs.offset); // Handle also the special transform property.\n\n    var transform = processedAttrs.normal && processedAttrs.normal.transform;\n\n    if (transform !== undefined && roProcessedAttrs.normal) {\n      roProcessedAttrs.normal.transform = transform;\n    }\n\n    processedAttrs.normal = roProcessedAttrs.normal;\n  },\n  onRemove: function () {\n    this.removeTools();\n    this.removeHighlighters();\n  },\n  _toolsView: null,\n  hasTools: function (name) {\n    var toolsView = this._toolsView;\n    if (!toolsView) return false;\n    if (!name) return true;\n    return toolsView.getName() === name;\n  },\n  addTools: function (toolsView) {\n    this.removeTools();\n\n    if (toolsView) {\n      this._toolsView = toolsView;\n      toolsView.configure({\n        relatedView: this\n      });\n      toolsView.listenTo(this.paper, 'tools:event', this.onToolEvent.bind(this));\n    }\n\n    return this;\n  },\n  updateTools: function (opt) {\n    var toolsView = this._toolsView;\n    if (toolsView) toolsView.update(opt);\n    return this;\n  },\n  removeTools: function () {\n    var toolsView = this._toolsView;\n\n    if (toolsView) {\n      toolsView.remove();\n      this._toolsView = null;\n    }\n\n    return this;\n  },\n  hideTools: function () {\n    var toolsView = this._toolsView;\n    if (toolsView) toolsView.hide();\n    return this;\n  },\n  showTools: function () {\n    var toolsView = this._toolsView;\n    if (toolsView) toolsView.show();\n    return this;\n  },\n  onToolEvent: function (event) {\n    switch (event) {\n      case 'remove':\n        this.removeTools();\n        break;\n\n      case 'hide':\n        this.hideTools();\n        break;\n\n      case 'show':\n        this.showTools();\n        break;\n    }\n  },\n  removeHighlighters: function () {\n    HighlighterView.remove(this);\n  },\n  updateHighlighters: function (dirty = false) {\n    HighlighterView.update(this, null, dirty);\n  },\n  transformHighlighters: function () {\n    HighlighterView.transform(this);\n  },\n  // Interaction. The controller part.\n  // ---------------------------------\n  // Interaction is handled by the paper and delegated to the view in interest.\n  // `x` & `y` parameters passed to these functions represent the coordinates already snapped to the paper grid.\n  // If necessary, real coordinates can be obtained from the `evt` event object.\n  // These functions are supposed to be overriden by the views that inherit from `joint.dia.Cell`,\n  // i.e. `joint.dia.Element` and `joint.dia.Link`.\n  pointerdblclick: function (evt, x, y) {\n    this.notify('cell:pointerdblclick', evt, x, y);\n  },\n  pointerclick: function (evt, x, y) {\n    this.notify('cell:pointerclick', evt, x, y);\n  },\n  contextmenu: function (evt, x, y) {\n    this.notify('cell:contextmenu', evt, x, y);\n  },\n  pointerdown: function (evt, x, y) {\n    const {\n      model\n    } = this;\n    const {\n      graph\n    } = model;\n\n    if (graph) {\n      model.startBatch('pointer');\n      this.eventData(evt, {\n        graph\n      });\n    }\n\n    this.notify('cell:pointerdown', evt, x, y);\n  },\n  pointermove: function (evt, x, y) {\n    this.notify('cell:pointermove', evt, x, y);\n  },\n  pointerup: function (evt, x, y) {\n    const {\n      graph\n    } = this.eventData(evt);\n    this.notify('cell:pointerup', evt, x, y);\n\n    if (graph) {\n      // we don't want to trigger event on model as model doesn't\n      // need to be member of collection anymore (remove)\n      graph.stopBatch('pointer', {\n        cell: this.model\n      });\n    }\n  },\n  mouseover: function (evt) {\n    this.notify('cell:mouseover', evt);\n  },\n  mouseout: function (evt) {\n    this.notify('cell:mouseout', evt);\n  },\n  mouseenter: function (evt) {\n    this.notify('cell:mouseenter', evt);\n  },\n  mouseleave: function (evt) {\n    this.notify('cell:mouseleave', evt);\n  },\n  mousewheel: function (evt, x, y, delta) {\n    this.notify('cell:mousewheel', evt, x, y, delta);\n  },\n  onevent: function (evt, eventName, x, y) {\n    this.notify(eventName, evt, x, y);\n  },\n  onmagnet: function () {// noop\n  },\n  magnetpointerdblclick: function () {// noop\n  },\n  magnetcontextmenu: function () {// noop\n  },\n\n  checkMouseleave(evt) {\n    const {\n      paper\n    } = this;\n\n    if (paper.isAsync()) {\n      // Do the updates of the current view synchronously now\n      paper.dumpView(this);\n    }\n\n    const target = this.getEventTarget(evt, {\n      fromPoint: true\n    });\n    const view = paper.findView(target);\n    if (view === this) return; // Leaving the current view\n\n    this.mouseleave(evt);\n    if (!view) return; // Entering another view\n\n    view.mouseenter(evt);\n  },\n\n  setInteractivity: function (value) {\n    this.options.interactive = value;\n  }\n}, {\n  Highlighting: HighlightingTypes,\n  addPresentationAttributes: function (presentationAttributes) {\n    return merge({}, result(this.prototype, 'presentationAttributes'), presentationAttributes, function (a, b) {\n      if (!a || !b) return;\n      if (typeof a === 'string') a = [a];\n      if (typeof b === 'string') b = [b];\n      if (Array.isArray(a) && Array.isArray(b)) return uniq(a.concat(b));\n    });\n  }\n});","map":{"version":3,"names":["config","View","assign","guid","omit","parseDOMJSON","isFunction","isObject","isPlainObject","isBoolean","isEmpty","isString","toKebabCase","result","sortedIndex","merge","uniq","Point","Rect","V","$","HighlighterView","HighlightingTypes","DEFAULT","EMBEDDING","CONNECTING","MAGNET_AVAILABILITY","ELEMENT_AVAILABILITY","CellView","extend","tagName","svgElement","selector","metrics","className","classNames","type","model","get","toLowerCase","split","forEach","value","index","list","push","slice","join","_presentationAttributes","_flags","setFlags","flags","attributes","shift","i","n","label","presentationAttributes","attribute","hasOwnProperty","labels","Array","isArray","length","flag","initFlag","Error","hasFlag","getFlag","removeFlag","cell","id","constructor","options","call","initialize","prototype","apply","arguments","cleanNodesCache","$el","data","startListening","onMount","listenTo","onAttributesChange","opt","getChangeFlag","updateHandled","dirty","tool","async","requestUpdate","paper","requestViewUpdate","UPDATE_PRIORITY","markup","root","doc","selectors","groups","groupSelectors","group","rootSelector","fragment","can","feature","interactive","findBySelector","el","nodes","useCSSSelectors","find","toArray","notify","eventName","args","trigger","concat","getBBox","bbox","useModelGeometry","angle","getNodeBBox","localToPaperRect","magnet","rect","getNodeBoundingRect","magnetMatrix","getNodeMatrix","translateMatrix","getRootTranslateMatrix","rotateMatrix","getRootRotateMatrix","transformRect","multiply","getNodeUnrotatedBBox","position","mt","createSVGMatrix","translate","x","y","mr","cx","width","cy","height","rotate","_notifyHighlight","rootNode","node","partial","undefined","embedding","connecting","magnetAvailability","elementAvailability","highlight","unhighlight","findMagnet","magnetAttribute","getAttribute","isMagnetRoot","parentNode","findProxyNode","nodeSelector","proxyNode","getSelector","prevSelector","nthChild","addLinkFromMagnet","graph","link","getDefaultLink","set","source","getLinkEnd","target","addTo","ui","findView","port","findAttribute","end","hasPort","customizeLinkEnd","endType","connectionStrategy","strategy","getMagnetFromLinkEnd","isElement","findPortNode","dragLinkStart","evt","startBatch","linkView","notifyPointerdown","eventData","startArrowheadMove","whenNotAllowed","dragLink","pointermove","magnetThreshold","currentTarget","getEventTarget","targetMagnet","contains","mousemoved","dragLinkEnd","pointerup","stopBatch","getAttributeDefinition","attrName","setNodeAttributes","attrs","SVGElement","attr","processNodeAttributes","attrVal","def","normalAttrs","setAttrs","positionAttrs","offsetAttrs","relatives","qualify","offset","raw","normal","updateRelativeAttributes","refBBox","rawAttrs","nodeAttrs","setResult","clone","HTMLElement","nodeTransform","transform","nodeMatrix","transformStringToMatrix","nodePosition","e","f","sx","sy","translation","nodeScale","getNodeScale","scalableNode","positioned","scale","offseted","nodeBoundingRect","nodeBBox","round","setAttribute","matrixToTransformString","nodeCache","ensureId","getNodeData","boundingRect","rotatableNode","getTransformToElement","getNodeShape","geometryShape","toGeometryShape","isNodeConnection","isLink","findNodesAttributes","selectorCache","nodeId","nodesAttrs","mergeIds","selected","unique","prevNodeAttrs","array","selectedLength","unshift","sortIndex","splice","reverse","clientX","clientY","fromPoint","document","elementFromPoint","updateDOMSubtreeAttributes","rootBBox","bboxCache","relativeItems","relativeRefItems","item","nodeData","processedAttrs","roAttrs","roAttributes","nodesAllAttrs","nodeAllAttrs","refSelector","ref","refNode","processedAttributes","allAttributes","itemIndex","findIndex","rotatableMatrix","vRotatable","refNodeId","isRefNodeRotatable","unrotatedRefBBox","transformationTarget","mergeProcessedAttributes","roProcessedAttrs","onRemove","removeTools","removeHighlighters","_toolsView","hasTools","name","toolsView","getName","addTools","configure","relatedView","onToolEvent","bind","updateTools","update","remove","hideTools","hide","showTools","show","event","updateHighlighters","transformHighlighters","pointerdblclick","pointerclick","contextmenu","pointerdown","mouseover","mouseout","mouseenter","mouseleave","mousewheel","delta","onevent","onmagnet","magnetpointerdblclick","magnetcontextmenu","checkMouseleave","isAsync","dumpView","view","setInteractivity","Highlighting","addPresentationAttributes","a","b"],"sources":["C:/Users/Admin/dataflow-test/node_modules/jointjs/src/dia/CellView.mjs"],"sourcesContent":["import { config } from '../config/index.mjs';\nimport { View } from '../mvc/index.mjs';\nimport {\n    assign,\n    guid,\n    omit,\n    parseDOMJSON,\n    isFunction,\n    isObject,\n    isPlainObject,\n    isBoolean,\n    isEmpty,\n    isString,\n    toKebabCase,\n    result,\n    sortedIndex,\n    merge,\n    uniq\n} from '../util/index.mjs';\nimport { Point, Rect } from '../g/index.mjs';\nimport V from '../V/index.mjs';\nimport $ from 'jquery';\nimport { HighlighterView } from './HighlighterView.mjs';\n\nconst HighlightingTypes = {\n    DEFAULT: 'default',\n    EMBEDDING: 'embedding',\n    CONNECTING: 'connecting',\n    MAGNET_AVAILABILITY: 'magnetAvailability',\n    ELEMENT_AVAILABILITY: 'elementAvailability'\n};\n\n// CellView base view and controller.\n// --------------------------------------------\n\n// This is the base view and controller for `ElementView` and `LinkView`.\nexport const CellView = View.extend({\n\n    tagName: 'g',\n\n    svgElement: true,\n\n    selector: 'root',\n\n    metrics: null,\n\n    className: function() {\n\n        var classNames = ['cell'];\n        var type = this.model.get('type');\n\n        if (type) {\n\n            type.toLowerCase().split('.').forEach(function(value, index, list) {\n                classNames.push('type-' + list.slice(0, index + 1).join('-'));\n            });\n        }\n\n        return classNames.join(' ');\n    },\n\n    _presentationAttributes: null,\n    _flags: null,\n\n    setFlags: function() {\n        var flags = {};\n        var attributes = {};\n        var shift = 0;\n        var i, n, label;\n        var presentationAttributes = result(this, 'presentationAttributes');\n        for (var attribute in presentationAttributes) {\n            if (!presentationAttributes.hasOwnProperty(attribute)) continue;\n            var labels = presentationAttributes[attribute];\n            if (!Array.isArray(labels)) labels = [labels];\n            for (i = 0, n = labels.length; i < n; i++) {\n                label = labels[i];\n                var flag = flags[label];\n                if (!flag) {\n                    flag = flags[label] = 1<<(shift++);\n                }\n                attributes[attribute] |= flag;\n            }\n        }\n        var initFlag = result(this, 'initFlag');\n        if (!Array.isArray(initFlag)) initFlag = [initFlag];\n        for (i = 0, n = initFlag.length; i < n; i++) {\n            label = initFlag[i];\n            if (!flags[label]) flags[label] = 1<<(shift++);\n        }\n\n        // 26 - 30 are reserved for paper flags\n        // 31+ overflows maximal number\n        if (shift > 25) throw new Error('dia.CellView: Maximum number of flags exceeded.');\n\n        this._flags = flags;\n        this._presentationAttributes = attributes;\n    },\n\n    hasFlag: function(flag, label) {\n        return flag & this.getFlag(label);\n    },\n\n    removeFlag: function(flag, label) {\n        return flag ^ (flag & this.getFlag(label));\n    },\n\n    getFlag: function(label) {\n        var flags = this._flags;\n        if (!flags) return 0;\n        var flag = 0;\n        if (Array.isArray(label)) {\n            for (var i = 0, n = label.length; i < n; i++) flag |= flags[label[i]];\n        } else {\n            flag |= flags[label];\n        }\n        return flag;\n    },\n\n    attributes: function() {\n        var cell = this.model;\n        return {\n            'model-id': cell.id,\n            'data-type': cell.attributes.type\n        };\n    },\n\n    constructor: function(options) {\n\n        // Make sure a global unique id is assigned to this view. Store this id also to the properties object.\n        // The global unique id makes sure that the same view can be rendered on e.g. different machines and\n        // still be associated to the same object among all those clients. This is necessary for real-time\n        // collaboration mechanism.\n        options.id = options.id || guid(this);\n\n        View.call(this, options);\n    },\n\n    initialize: function() {\n\n        this.setFlags();\n\n        View.prototype.initialize.apply(this, arguments);\n\n        this.cleanNodesCache();\n\n        // Store reference to this to the <g> DOM element so that the view is accessible through the DOM tree.\n        this.$el.data('view', this);\n\n        this.startListening();\n    },\n\n    onMount() {\n        // To be overridden\n    },\n\n    startListening: function() {\n        this.listenTo(this.model, 'change', this.onAttributesChange);\n    },\n\n    onAttributesChange: function(model, opt) {\n        var flag = model.getChangeFlag(this._presentationAttributes);\n        if (opt.updateHandled || !flag) return;\n        if (opt.dirty && this.hasFlag(flag, 'UPDATE')) flag |= this.getFlag('RENDER');\n        // TODO: tool changes does not need to be sync\n        // Fix Segments tools\n        if (opt.tool) opt.async = false;\n        this.requestUpdate(flag, opt);\n    },\n\n    requestUpdate: function(flags, opt) {\n        const { paper } = this;\n        if (paper && flags > 0) {\n            paper.requestViewUpdate(this, flags, this.UPDATE_PRIORITY, opt);\n        }\n    },\n\n    parseDOMJSON: function(markup, root) {\n\n        var doc = parseDOMJSON(markup);\n        var selectors = doc.selectors;\n        var groups = doc.groupSelectors;\n        for (var group in groups) {\n            if (selectors[group]) throw new Error('dia.CellView: ambiguous group selector');\n            selectors[group] = groups[group];\n        }\n        if (root) {\n            var rootSelector = this.selector;\n            if (selectors[rootSelector]) throw new Error('dia.CellView: ambiguous root selector.');\n            selectors[rootSelector] = root;\n        }\n        return { fragment: doc.fragment, selectors: selectors };\n    },\n\n    // Return `true` if cell link is allowed to perform a certain UI `feature`.\n    // Example: `can('vertexMove')`, `can('labelMove')`.\n    can: function(feature) {\n\n        var interactive = isFunction(this.options.interactive)\n            ? this.options.interactive(this)\n            : this.options.interactive;\n\n        return (isObject(interactive) && interactive[feature] !== false) ||\n            (isBoolean(interactive) && interactive !== false);\n    },\n\n    findBySelector: function(selector, root, selectors) {\n\n        root || (root = this.el);\n        selectors || (selectors = this.selectors);\n\n        // These are either descendants of `this.$el` of `this.$el` itself.\n        // `.` is a special selector used to select the wrapping `<g>` element.\n        if (!selector || selector === '.') return [root];\n        if (selectors) {\n            var nodes = selectors[selector];\n            if (nodes) {\n                if (Array.isArray(nodes)) return nodes;\n                return [nodes];\n            }\n        }\n\n        // Maintaining backwards compatibility\n        // e.g. `circle:first` would fail with querySelector() call\n        if (config.useCSSSelectors) return $(root).find(selector).toArray();\n\n        return [];\n    },\n\n    notify: function(eventName) {\n\n        if (this.paper) {\n\n            var args = Array.prototype.slice.call(arguments, 1);\n\n            // Trigger the event on both the element itself and also on the paper.\n            this.trigger.apply(this, [eventName].concat(args));\n\n            // Paper event handlers receive the view object as the first argument.\n            this.paper.trigger.apply(this.paper, [eventName, this].concat(args));\n        }\n    },\n\n    getBBox: function(opt) {\n\n        var bbox;\n        if (opt && opt.useModelGeometry) {\n            var model = this.model;\n            bbox = model.getBBox().bbox(model.angle());\n        } else {\n            bbox = this.getNodeBBox(this.el);\n        }\n\n        return this.paper.localToPaperRect(bbox);\n    },\n\n    getNodeBBox: function(magnet) {\n\n        var rect = this.getNodeBoundingRect(magnet);\n        var magnetMatrix = this.getNodeMatrix(magnet);\n        var translateMatrix = this.getRootTranslateMatrix();\n        var rotateMatrix = this.getRootRotateMatrix();\n        return V.transformRect(rect, translateMatrix.multiply(rotateMatrix).multiply(magnetMatrix));\n    },\n\n    getNodeUnrotatedBBox: function(magnet) {\n\n        var rect = this.getNodeBoundingRect(magnet);\n        var magnetMatrix = this.getNodeMatrix(magnet);\n        var translateMatrix = this.getRootTranslateMatrix();\n        return V.transformRect(rect, translateMatrix.multiply(magnetMatrix));\n    },\n\n    getRootTranslateMatrix: function() {\n\n        var model = this.model;\n        var position = model.position();\n        var mt = V.createSVGMatrix().translate(position.x, position.y);\n        return mt;\n    },\n\n    getRootRotateMatrix: function() {\n\n        var mr = V.createSVGMatrix();\n        var model = this.model;\n        var angle = model.angle();\n        if (angle) {\n            var bbox = model.getBBox();\n            var cx = bbox.width / 2;\n            var cy = bbox.height / 2;\n            mr = mr.translate(cx, cy).rotate(angle).translate(-cx, -cy);\n        }\n        return mr;\n    },\n\n    _notifyHighlight: function(eventName, el, opt = {}) {\n        const { el: rootNode } = this;\n        let node;\n        if (typeof el === 'string') {\n            [node = rootNode] = this.findBySelector(el);\n        } else {\n            [node = rootNode] = this.$(el);\n        }\n        // set partial flag if the highlighted element is not the entire view.\n        opt.partial = (node !== rootNode);\n        // translate type flag into a type string\n        if (opt.type === undefined) {\n            let type;\n            switch (true) {\n                case opt.embedding:\n                    type = HighlightingTypes.EMBEDDING;\n                    break;\n                case opt.connecting:\n                    type = HighlightingTypes.CONNECTING;\n                    break;\n                case opt.magnetAvailability:\n                    type = HighlightingTypes.MAGNET_AVAILABILITY;\n                    break;\n                case opt.elementAvailability:\n                    type = HighlightingTypes.ELEMENT_AVAILABILITY;\n                    break;\n                default:\n                    type = HighlightingTypes.DEFAULT;\n                    break;\n            }\n            opt.type = type;\n        }\n        this.notify(eventName, node, opt);\n        return this;\n    },\n\n    highlight: function(el, opt) {\n        return this._notifyHighlight('cell:highlight', el, opt);\n    },\n\n    unhighlight: function(el, opt = {}) {\n        return this._notifyHighlight('cell:unhighlight', el, opt);\n    },\n\n    // Find the closest element that has the `magnet` attribute set to `true`. If there was not such\n    // an element found, return the root element of the cell view.\n    findMagnet: function(el) {\n\n        const root = this.el;\n        let magnet = this.$(el)[0];\n        if (!magnet) {\n            magnet = root;\n        }\n\n        do {\n            const magnetAttribute = magnet.getAttribute('magnet');\n            const isMagnetRoot = (magnet === root);\n            if ((magnetAttribute || isMagnetRoot) && magnetAttribute !== 'false') {\n                return magnet;\n            }\n            if (isMagnetRoot) {\n                // If the overall cell has set `magnet === false`, then return `undefined` to\n                // announce there is no magnet found for this cell.\n                // This is especially useful to set on cells that have 'ports'. In this case,\n                // only the ports have set `magnet === true` and the overall element has `magnet === false`.\n                return undefined;\n            }\n            magnet = magnet.parentNode;\n        } while (magnet);\n\n        return undefined;\n    },\n\n    findProxyNode: function(el, type) {\n        el || (el = this.el);\n        const nodeSelector = el.getAttribute(`${type}-selector`);\n        if (nodeSelector) {\n            const [proxyNode] = this.findBySelector(nodeSelector);\n            if (proxyNode) return proxyNode;\n        }\n        return el;\n    },\n\n    // Construct a unique selector for the `el` element within this view.\n    // `prevSelector` is being collected through the recursive call.\n    // No value for `prevSelector` is expected when using this method.\n    getSelector: function(el, prevSelector) {\n\n        var selector;\n\n        if (el === this.el) {\n            if (typeof prevSelector === 'string') selector = '> ' + prevSelector;\n            return selector;\n        }\n\n        if (el) {\n\n            var nthChild = V(el).index() + 1;\n            selector = el.tagName + ':nth-child(' + nthChild + ')';\n\n            if (prevSelector) {\n                selector += ' > ' + prevSelector;\n            }\n\n            selector = this.getSelector(el.parentNode, selector);\n        }\n\n        return selector;\n    },\n\n    addLinkFromMagnet: function(magnet, x, y) {\n\n        var paper = this.paper;\n        var graph = paper.model;\n\n        var link = paper.getDefaultLink(this, magnet);\n        link.set({\n            source: this.getLinkEnd(magnet, x, y, link, 'source'),\n            target: { x: x, y: y }\n        }).addTo(graph, {\n            async: false,\n            ui: true\n        });\n\n        return link.findView(paper);\n    },\n\n    getLinkEnd: function(magnet, ...args) {\n\n        var model = this.model;\n        var id = model.id;\n        var port = this.findAttribute('port', magnet);\n        // Find a unique `selector` of the element under pointer that is a magnet.\n        var selector = magnet.getAttribute('joint-selector');\n\n        var end = { id: id };\n        if (selector != null) end.magnet = selector;\n        if (port != null) {\n            end.port = port;\n            if (!model.hasPort(port) && !selector) {\n                // port created via the `port` attribute (not API)\n                end.selector = this.getSelector(magnet);\n            }\n        } else if (selector == null && this.el !== magnet) {\n            end.selector = this.getSelector(magnet);\n        }\n\n        return this.customizeLinkEnd(end, magnet, ...args);\n    },\n\n    customizeLinkEnd: function(end, magnet, x, y, link, endType) {\n        const { paper } = this;\n        const { connectionStrategy } = paper.options;\n        if (typeof connectionStrategy === 'function') {\n            var strategy = connectionStrategy.call(paper, end, this, magnet, new Point(x, y), link, endType, paper);\n            if (strategy) return strategy;\n        }\n        return end;\n    },\n\n    getMagnetFromLinkEnd: function(end) {\n\n        var root = this.el;\n        var port = end.port;\n        var selector = end.magnet;\n        var model = this.model;\n        var magnet;\n        if (port != null && model.isElement() && model.hasPort(port)) {\n            magnet = this.findPortNode(port, selector) || root;\n        } else {\n            if (!selector) selector = end.selector;\n            if (!selector && port != null) {\n                // link end has only `id` and `port` property referencing\n                // a port created via the `port` attribute (not API).\n                selector = '[port=\"' + port + '\"]';\n            }\n            magnet = this.findBySelector(selector, root, this.selectors)[0];\n        }\n\n        return this.findProxyNode(magnet, 'magnet');\n    },\n\n    dragLinkStart: function(evt, magnet, x, y) {\n        this.model.startBatch('add-link');\n        const linkView = this.addLinkFromMagnet(magnet, x, y);\n        // backwards compatibility events\n        linkView.notifyPointerdown(evt, x, y);\n        linkView.eventData(evt, linkView.startArrowheadMove('target', { whenNotAllowed: 'remove' }));\n        this.eventData(evt, { linkView });\n    },\n\n    dragLink: function(evt, x, y) {\n        var data = this.eventData(evt);\n        var linkView = data.linkView;\n        if (linkView) {\n            linkView.pointermove(evt, x, y);\n        } else {\n            var paper = this.paper;\n            var magnetThreshold = paper.options.magnetThreshold;\n            var currentTarget = this.getEventTarget(evt);\n            var targetMagnet = data.targetMagnet;\n            if (magnetThreshold === 'onleave') {\n                // magnetThreshold when the pointer leaves the magnet\n                if (targetMagnet === currentTarget || V(targetMagnet).contains(currentTarget)) return;\n            } else {\n                // magnetThreshold defined as a number of movements\n                if (paper.eventData(evt).mousemoved <= magnetThreshold) return;\n            }\n            this.dragLinkStart(evt, targetMagnet, x, y);\n        }\n    },\n\n    dragLinkEnd: function(evt, x, y) {\n        var data = this.eventData(evt);\n        var linkView = data.linkView;\n        if (!linkView) return;\n        linkView.pointerup(evt, x, y);\n        this.model.stopBatch('add-link');\n    },\n\n    getAttributeDefinition: function(attrName) {\n\n        return this.model.constructor.getAttributeDefinition(attrName);\n    },\n\n    setNodeAttributes: function(node, attrs) {\n\n        if (!isEmpty(attrs)) {\n            if (node instanceof SVGElement) {\n                V(node).attr(attrs);\n            } else {\n                $(node).attr(attrs);\n            }\n        }\n    },\n\n    processNodeAttributes: function(node, attrs) {\n\n        var attrName, attrVal, def, i, n;\n        var normalAttrs, setAttrs, positionAttrs, offsetAttrs;\n        var relatives = [];\n        // divide the attributes between normal and special\n        for (attrName in attrs) {\n            if (!attrs.hasOwnProperty(attrName)) continue;\n            attrVal = attrs[attrName];\n            def = this.getAttributeDefinition(attrName);\n            if (def && (!isFunction(def.qualify) || def.qualify.call(this, attrVal, node, attrs))) {\n                if (isString(def.set)) {\n                    normalAttrs || (normalAttrs = {});\n                    normalAttrs[def.set] = attrVal;\n                }\n                if (attrVal !== null) {\n                    relatives.push(attrName, def);\n                }\n            } else {\n                normalAttrs || (normalAttrs = {});\n                normalAttrs[toKebabCase(attrName)] = attrVal;\n            }\n        }\n\n        // handle the rest of attributes via related method\n        // from the special attributes namespace.\n        for (i = 0, n = relatives.length; i < n; i+=2) {\n            attrName = relatives[i];\n            def = relatives[i+1];\n            attrVal = attrs[attrName];\n            if (isFunction(def.set)) {\n                setAttrs || (setAttrs = {});\n                setAttrs[attrName] = attrVal;\n            }\n            if (isFunction(def.position)) {\n                positionAttrs || (positionAttrs = {});\n                positionAttrs[attrName] = attrVal;\n            }\n            if (isFunction(def.offset)) {\n                offsetAttrs || (offsetAttrs = {});\n                offsetAttrs[attrName] = attrVal;\n            }\n        }\n\n        return {\n            raw: attrs,\n            normal: normalAttrs,\n            set: setAttrs,\n            position: positionAttrs,\n            offset: offsetAttrs\n        };\n    },\n\n    updateRelativeAttributes: function(node, attrs, refBBox, opt) {\n\n        opt || (opt = {});\n\n        var attrName, attrVal, def;\n        var rawAttrs = attrs.raw || {};\n        var nodeAttrs = attrs.normal || {};\n        var setAttrs = attrs.set;\n        var positionAttrs = attrs.position;\n        var offsetAttrs = attrs.offset;\n\n        for (attrName in setAttrs) {\n            attrVal = setAttrs[attrName];\n            def = this.getAttributeDefinition(attrName);\n            // SET - set function should return attributes to be set on the node,\n            // which will affect the node dimensions based on the reference bounding\n            // box. e.g. `width`, `height`, `d`, `rx`, `ry`, `points\n            var setResult = def.set.call(this, attrVal, refBBox.clone(), node, rawAttrs);\n            if (isObject(setResult)) {\n                assign(nodeAttrs, setResult);\n            } else if (setResult !== undefined) {\n                nodeAttrs[attrName] = setResult;\n            }\n        }\n\n        if (node instanceof HTMLElement) {\n            // TODO: setting the `transform` attribute on HTMLElements\n            // via `node.style.transform = 'matrix(...)';` would introduce\n            // a breaking change (e.g. basic.TextBlock).\n            this.setNodeAttributes(node, nodeAttrs);\n            return;\n        }\n\n        // The final translation of the subelement.\n        var nodeTransform = nodeAttrs.transform;\n        var nodeMatrix = V.transformStringToMatrix(nodeTransform);\n        var nodePosition = Point(nodeMatrix.e, nodeMatrix.f);\n        if (nodeTransform) {\n            nodeAttrs = omit(nodeAttrs, 'transform');\n            nodeMatrix.e = nodeMatrix.f = 0;\n        }\n\n        // Calculate node scale determined by the scalable group\n        // only if later needed.\n        var sx, sy, translation;\n        if (positionAttrs || offsetAttrs) {\n            var nodeScale = this.getNodeScale(node, opt.scalableNode);\n            sx = nodeScale.sx;\n            sy = nodeScale.sy;\n        }\n\n        var positioned = false;\n        for (attrName in positionAttrs) {\n            attrVal = positionAttrs[attrName];\n            def = this.getAttributeDefinition(attrName);\n            // POSITION - position function should return a point from the\n            // reference bounding box. The default position of the node is x:0, y:0 of\n            // the reference bounding box or could be further specify by some\n            // SVG attributes e.g. `x`, `y`\n            translation = def.position.call(this, attrVal, refBBox.clone(), node, rawAttrs);\n            if (translation) {\n                nodePosition.offset(Point(translation).scale(sx, sy));\n                positioned || (positioned = true);\n            }\n        }\n\n        // The node bounding box could depend on the `size` set from the previous loop.\n        // Here we know, that all the size attributes have been already set.\n        this.setNodeAttributes(node, nodeAttrs);\n\n        var offseted = false;\n        if (offsetAttrs) {\n            // Check if the node is visible\n            var nodeBoundingRect = this.getNodeBoundingRect(node);\n            if (nodeBoundingRect.width > 0 && nodeBoundingRect.height > 0) {\n                var nodeBBox = V.transformRect(nodeBoundingRect, nodeMatrix).scale(1 / sx, 1 / sy);\n                for (attrName in offsetAttrs) {\n                    attrVal = offsetAttrs[attrName];\n                    def = this.getAttributeDefinition(attrName);\n                    // OFFSET - offset function should return a point from the element\n                    // bounding box. The default offset point is x:0, y:0 (origin) or could be further\n                    // specify with some SVG attributes e.g. `text-anchor`, `cx`, `cy`\n                    translation = def.offset.call(this, attrVal, nodeBBox, node, rawAttrs);\n                    if (translation) {\n                        nodePosition.offset(Point(translation).scale(sx, sy));\n                        offseted || (offseted = true);\n                    }\n                }\n            }\n        }\n\n        // Do not touch node's transform attribute if there is no transformation applied.\n        if (nodeTransform !== undefined || positioned || offseted) {\n            // Round the coordinates to 1 decimal point.\n            nodePosition.round(1);\n            nodeMatrix.e = nodePosition.x;\n            nodeMatrix.f = nodePosition.y;\n            node.setAttribute('transform', V.matrixToTransformString(nodeMatrix));\n            // TODO: store nodeMatrix metrics?\n        }\n    },\n\n    getNodeScale: function(node, scalableNode) {\n\n        // Check if the node is a descendant of the scalable group.\n        var sx, sy;\n        if (scalableNode && scalableNode.contains(node)) {\n            var scale = scalableNode.scale();\n            sx = 1 / scale.sx;\n            sy = 1 / scale.sy;\n        } else {\n            sx = 1;\n            sy = 1;\n        }\n\n        return { sx: sx, sy: sy };\n    },\n\n    cleanNodesCache: function() {\n        this.metrics = {};\n    },\n\n    nodeCache: function(magnet) {\n\n        var metrics = this.metrics;\n        // Don't use cache? It most likely a custom view with overridden update.\n        if (!metrics) return {};\n        var id = V.ensureId(magnet);\n        var value = metrics[id];\n        if (!value) value = metrics[id] = {};\n        return value;\n    },\n\n    getNodeData: function(magnet) {\n\n        var metrics = this.nodeCache(magnet);\n        if (!metrics.data) metrics.data = {};\n        return metrics.data;\n    },\n\n    getNodeBoundingRect: function(magnet) {\n\n        var metrics = this.nodeCache(magnet);\n        if (metrics.boundingRect === undefined) metrics.boundingRect = V(magnet).getBBox();\n        return new Rect(metrics.boundingRect);\n    },\n\n    getNodeMatrix: function(magnet) {\n\n        var metrics = this.nodeCache(magnet);\n        if (metrics.magnetMatrix === undefined) {\n            var target = this.rotatableNode || this.el;\n            metrics.magnetMatrix = V(magnet).getTransformToElement(target);\n        }\n        return V.createSVGMatrix(metrics.magnetMatrix);\n    },\n\n    getNodeShape: function(magnet) {\n\n        var metrics = this.nodeCache(magnet);\n        if (metrics.geometryShape === undefined) metrics.geometryShape = V(magnet).toGeometryShape();\n        return metrics.geometryShape.clone();\n    },\n\n    isNodeConnection: function(node) {\n        return this.model.isLink() && (!node || node === this.el);\n    },\n\n    findNodesAttributes: function(attrs, root, selectorCache, selectors) {\n\n        var i, n, nodeAttrs, nodeId;\n        var nodesAttrs = {};\n        var mergeIds = [];\n        for (var selector in attrs) {\n            if (!attrs.hasOwnProperty(selector)) continue;\n            nodeAttrs = attrs[selector];\n            if (!isPlainObject(nodeAttrs)) continue; // Not a valid selector-attributes pair\n            var selected = selectorCache[selector] = this.findBySelector(selector, root, selectors);\n            for (i = 0, n = selected.length; i < n; i++) {\n                var node = selected[i];\n                nodeId = V.ensureId(node);\n                // \"unique\" selectors are selectors that referencing a single node (defined by `selector`)\n                // groupSelector referencing a single node is not \"unique\"\n                var unique = (selectors && selectors[selector] === node);\n                var prevNodeAttrs = nodesAttrs[nodeId];\n                if (prevNodeAttrs) {\n                    // Note, that nodes referenced by deprecated `CSS selectors` are not taken into account.\n                    // e.g. css:`.circle` and selector:`circle` can be applied in a random order\n                    if (!prevNodeAttrs.array) {\n                        mergeIds.push(nodeId);\n                        prevNodeAttrs.array = true;\n                        prevNodeAttrs.attributes = [prevNodeAttrs.attributes];\n                        prevNodeAttrs.selectedLength = [prevNodeAttrs.selectedLength];\n                    }\n                    var attributes = prevNodeAttrs.attributes;\n                    var selectedLength = prevNodeAttrs.selectedLength;\n                    if (unique) {\n                        // node referenced by `selector`\n                        attributes.unshift(nodeAttrs);\n                        selectedLength.unshift(-1);\n                    } else {\n                        // node referenced by `groupSelector`\n                        var sortIndex = sortedIndex(selectedLength, n);\n                        attributes.splice(sortIndex, 0, nodeAttrs);\n                        selectedLength.splice(sortIndex, 0, n);\n                    }\n                } else {\n                    nodesAttrs[nodeId] = {\n                        attributes: nodeAttrs,\n                        selectedLength: unique ? -1 : n,\n                        node: node,\n                        array: false\n                    };\n                }\n            }\n        }\n\n        for (i = 0, n = mergeIds.length; i < n; i++) {\n            nodeId = mergeIds[i];\n            nodeAttrs = nodesAttrs[nodeId];\n            nodeAttrs.attributes = merge({}, ...nodeAttrs.attributes.reverse());\n        }\n\n        return nodesAttrs;\n    },\n\n    getEventTarget: function(evt, opt = {}) {\n        // Touchmove/Touchend event's target is not reflecting the element under the coordinates as mousemove does.\n        // It holds the element when a touchstart triggered.\n        const { target, type, clientX = 0, clientY = 0 } = evt;\n        if (opt.fromPoint || type === 'touchmove' || type === 'touchend') {\n            return document.elementFromPoint(clientX, clientY);\n        }\n\n        return target;\n    },\n\n    // Default is to process the `model.attributes.attrs` object and set attributes on subelements based on the selectors,\n    // unless `attrs` parameter was passed.\n    updateDOMSubtreeAttributes: function(rootNode, attrs, opt) {\n\n        opt || (opt = {});\n        opt.rootBBox || (opt.rootBBox = Rect());\n        opt.selectors || (opt.selectors = this.selectors); // selector collection to use\n\n        // Cache table for query results and bounding box calculation.\n        // Note that `selectorCache` needs to be invalidated for all\n        // `updateAttributes` calls, as the selectors might pointing\n        // to nodes designated by an attribute or elements dynamically\n        // created.\n        var selectorCache = {};\n        var bboxCache = {};\n        var relativeItems = [];\n        var relativeRefItems = [];\n        var item, node, nodeAttrs, nodeData, processedAttrs;\n\n        var roAttrs = opt.roAttributes;\n        var nodesAttrs = this.findNodesAttributes(roAttrs || attrs, rootNode, selectorCache, opt.selectors);\n        // `nodesAttrs` are different from all attributes, when\n        // rendering only  attributes sent to this method.\n        var nodesAllAttrs = (roAttrs)\n            ? this.findNodesAttributes(attrs, rootNode, selectorCache, opt.selectors)\n            : nodesAttrs;\n\n        for (var nodeId in nodesAttrs) {\n            nodeData = nodesAttrs[nodeId];\n            nodeAttrs = nodeData.attributes;\n            node = nodeData.node;\n            processedAttrs = this.processNodeAttributes(node, nodeAttrs);\n\n            if (!processedAttrs.set && !processedAttrs.position && !processedAttrs.offset) {\n                // Set all the normal attributes right on the SVG/HTML element.\n                this.setNodeAttributes(node, processedAttrs.normal);\n\n            } else {\n\n                var nodeAllAttrs = nodesAllAttrs[nodeId] && nodesAllAttrs[nodeId].attributes;\n                var refSelector = (nodeAllAttrs && (nodeAttrs.ref === undefined))\n                    ? nodeAllAttrs.ref\n                    : nodeAttrs.ref;\n\n                var refNode;\n                if (refSelector) {\n                    refNode = (selectorCache[refSelector] || this.findBySelector(refSelector, rootNode, opt.selectors))[0];\n                    if (!refNode) {\n                        throw new Error('dia.CellView: \"' + refSelector + '\" reference does not exist.');\n                    }\n                } else {\n                    refNode = null;\n                }\n\n                item = {\n                    node: node,\n                    refNode: refNode,\n                    processedAttributes: processedAttrs,\n                    allAttributes: nodeAllAttrs\n                };\n\n                if (refNode) {\n                    // If an element in the list is positioned relative to this one, then\n                    // we want to insert this one before it in the list.\n                    var itemIndex = relativeRefItems.findIndex(function(item) {\n                        return item.refNode === node;\n                    });\n\n                    if (itemIndex > -1) {\n                        relativeRefItems.splice(itemIndex, 0, item);\n                    } else {\n                        relativeRefItems.push(item);\n                    }\n                } else {\n                    // A node with no ref attribute. To be updated before the nodes referencing other nodes.\n                    // The order of no-ref-items is not specified/important.\n                    relativeItems.push(item);\n                }\n            }\n        }\n\n        relativeItems.push(...relativeRefItems);\n\n        var rotatableMatrix;\n        for (var i = 0, n = relativeItems.length; i < n; i++) {\n            item = relativeItems[i];\n            node = item.node;\n            refNode = item.refNode;\n\n            // Find the reference element bounding box. If no reference was provided, we\n            // use the optional bounding box.\n            var vRotatable = V(opt.rotatableNode);\n            var refNodeId = refNode ? V.ensureId(refNode) : '';\n            var isRefNodeRotatable = !!vRotatable && !!refNode && vRotatable.contains(refNode);\n            var unrotatedRefBBox = bboxCache[refNodeId];\n            if (!unrotatedRefBBox) {\n                // Get the bounding box of the reference element relative to the `rotatable` `<g>` (without rotation)\n                // or to the root `<g>` element if no rotatable group present if reference node present.\n                // Uses the bounding box provided.\n                var transformationTarget = (isRefNodeRotatable) ? vRotatable : rootNode;\n                unrotatedRefBBox = bboxCache[refNodeId] = (refNode)\n                    ? V(refNode).getBBox({ target: transformationTarget })\n                    : opt.rootBBox;\n            }\n\n            if (roAttrs) {\n                // if there was a special attribute affecting the position amongst passed-in attributes\n                // we have to merge it with the rest of the element's attributes as they are necessary\n                // to update the position relatively (i.e `ref-x` && 'ref-dx')\n                processedAttrs = this.processNodeAttributes(node, item.allAttributes);\n                this.mergeProcessedAttributes(processedAttrs, item.processedAttributes);\n\n            } else {\n                processedAttrs = item.processedAttributes;\n            }\n\n            var refBBox = unrotatedRefBBox;\n            if (isRefNodeRotatable && !vRotatable.contains(node)) {\n                // if the referenced node is inside the rotatable group while the updated node is outside,\n                // we need to take the rotatable node transformation into account\n                if (!rotatableMatrix) rotatableMatrix = V.transformStringToMatrix(vRotatable.attr('transform'));\n                refBBox = V.transformRect(unrotatedRefBBox, rotatableMatrix);\n            }\n\n            this.updateRelativeAttributes(node, processedAttrs, refBBox, opt);\n        }\n    },\n\n    mergeProcessedAttributes: function(processedAttrs, roProcessedAttrs) {\n\n        processedAttrs.set || (processedAttrs.set = {});\n        processedAttrs.position || (processedAttrs.position = {});\n        processedAttrs.offset || (processedAttrs.offset = {});\n\n        assign(processedAttrs.set, roProcessedAttrs.set);\n        assign(processedAttrs.position, roProcessedAttrs.position);\n        assign(processedAttrs.offset, roProcessedAttrs.offset);\n\n        // Handle also the special transform property.\n        var transform = processedAttrs.normal && processedAttrs.normal.transform;\n        if (transform !== undefined && roProcessedAttrs.normal) {\n            roProcessedAttrs.normal.transform = transform;\n        }\n        processedAttrs.normal = roProcessedAttrs.normal;\n    },\n\n    onRemove: function() {\n        this.removeTools();\n        this.removeHighlighters();\n    },\n\n    _toolsView: null,\n\n    hasTools: function(name) {\n        var toolsView = this._toolsView;\n        if (!toolsView) return false;\n        if (!name) return true;\n        return (toolsView.getName() === name);\n    },\n\n    addTools: function(toolsView) {\n\n        this.removeTools();\n\n        if (toolsView) {\n            this._toolsView = toolsView;\n            toolsView.configure({ relatedView: this });\n            toolsView.listenTo(this.paper, 'tools:event', this.onToolEvent.bind(this));\n        }\n        return this;\n    },\n\n    updateTools: function(opt) {\n\n        var toolsView = this._toolsView;\n        if (toolsView) toolsView.update(opt);\n        return this;\n    },\n\n    removeTools: function() {\n\n        var toolsView = this._toolsView;\n        if (toolsView) {\n            toolsView.remove();\n            this._toolsView = null;\n        }\n        return this;\n    },\n\n    hideTools: function() {\n\n        var toolsView = this._toolsView;\n        if (toolsView) toolsView.hide();\n        return this;\n    },\n\n    showTools: function() {\n\n        var toolsView = this._toolsView;\n        if (toolsView) toolsView.show();\n        return this;\n    },\n\n    onToolEvent: function(event) {\n        switch (event) {\n            case 'remove':\n                this.removeTools();\n                break;\n            case 'hide':\n                this.hideTools();\n                break;\n            case 'show':\n                this.showTools();\n                break;\n        }\n    },\n\n    removeHighlighters: function() {\n        HighlighterView.remove(this);\n    },\n\n    updateHighlighters: function(dirty = false) {\n        HighlighterView.update(this, null, dirty);\n    },\n\n    transformHighlighters: function() {\n        HighlighterView.transform(this);\n    },\n\n    // Interaction. The controller part.\n    // ---------------------------------\n\n    // Interaction is handled by the paper and delegated to the view in interest.\n    // `x` & `y` parameters passed to these functions represent the coordinates already snapped to the paper grid.\n    // If necessary, real coordinates can be obtained from the `evt` event object.\n\n    // These functions are supposed to be overriden by the views that inherit from `joint.dia.Cell`,\n    // i.e. `joint.dia.Element` and `joint.dia.Link`.\n\n    pointerdblclick: function(evt, x, y) {\n\n        this.notify('cell:pointerdblclick', evt, x, y);\n    },\n\n    pointerclick: function(evt, x, y) {\n\n        this.notify('cell:pointerclick', evt, x, y);\n    },\n\n    contextmenu: function(evt, x, y) {\n\n        this.notify('cell:contextmenu', evt, x, y);\n    },\n\n    pointerdown: function(evt, x, y) {\n\n        const { model } = this;\n        const { graph } = model;\n        if (graph) {\n            model.startBatch('pointer');\n            this.eventData(evt, { graph });\n        }\n\n        this.notify('cell:pointerdown', evt, x, y);\n    },\n\n    pointermove: function(evt, x, y) {\n\n        this.notify('cell:pointermove', evt, x, y);\n    },\n\n    pointerup: function(evt, x, y) {\n\n        const { graph } = this.eventData(evt);\n\n        this.notify('cell:pointerup', evt, x, y);\n\n        if (graph) {\n            // we don't want to trigger event on model as model doesn't\n            // need to be member of collection anymore (remove)\n            graph.stopBatch('pointer', { cell: this.model });\n        }\n    },\n\n    mouseover: function(evt) {\n\n        this.notify('cell:mouseover', evt);\n    },\n\n    mouseout: function(evt) {\n\n        this.notify('cell:mouseout', evt);\n    },\n\n    mouseenter: function(evt) {\n\n        this.notify('cell:mouseenter', evt);\n    },\n\n    mouseleave: function(evt) {\n\n        this.notify('cell:mouseleave', evt);\n    },\n\n    mousewheel: function(evt, x, y, delta) {\n\n        this.notify('cell:mousewheel', evt, x, y, delta);\n    },\n\n    onevent: function(evt, eventName, x, y) {\n\n        this.notify(eventName, evt, x, y);\n    },\n\n    onmagnet: function() {\n\n        // noop\n    },\n\n    magnetpointerdblclick: function() {\n\n        // noop\n    },\n\n    magnetcontextmenu: function() {\n\n        // noop\n    },\n\n    checkMouseleave(evt) {\n        const { paper } = this;\n        if (paper.isAsync()) {\n            // Do the updates of the current view synchronously now\n            paper.dumpView(this);\n        }\n        const target = this.getEventTarget(evt, { fromPoint: true });\n        const view = paper.findView(target);\n        if (view === this) return;\n        // Leaving the current view\n        this.mouseleave(evt);\n        if (!view) return;\n        // Entering another view\n        view.mouseenter(evt);\n    },\n\n    setInteractivity: function(value) {\n\n        this.options.interactive = value;\n    }\n}, {\n\n    Highlighting: HighlightingTypes,\n\n    addPresentationAttributes: function(presentationAttributes) {\n        return merge({}, result(this.prototype, 'presentationAttributes'), presentationAttributes, function(a, b) {\n            if (!a || !b) return;\n            if (typeof a === 'string') a = [a];\n            if (typeof b === 'string') b = [b];\n            if (Array.isArray(a) && Array.isArray(b)) return uniq(a.concat(b));\n        });\n    }\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}