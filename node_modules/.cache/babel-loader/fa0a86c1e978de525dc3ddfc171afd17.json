{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport { Cell } from './Cell.mjs';\nimport { Point, toRad, normalizeAngle, Rect } from '../g/index.mjs';\nimport { isNumber, isObject, interpolate, assign, invoke, normalizeSides } from '../util/index.mjs';\nimport { elementPortPrototype } from './ports.mjs'; // Element base model.\n// -----------------------------\n\nexport const Element = Cell.extend({\n  defaults: {\n    position: {\n      x: 0,\n      y: 0\n    },\n    size: {\n      width: 1,\n      height: 1\n    },\n    angle: 0\n  },\n  initialize: function () {\n    this._initializePorts();\n\n    Cell.prototype.initialize.apply(this, arguments);\n  },\n\n  /**\n   * @abstract\n   */\n  _initializePorts: function () {// implemented in ports.js\n  },\n  _refreshPorts: function () {// implemented in ports.js\n  },\n  isElement: function () {\n    return true;\n  },\n  position: function (x, y, opt) {\n    const isSetter = isNumber(y);\n    opt = (isSetter ? opt : x) || {};\n    const {\n      parentRelative,\n      deep,\n      restrictedArea\n    } = opt; // option `parentRelative` for setting the position relative to the element's parent.\n\n    let parentPosition;\n\n    if (parentRelative) {\n      // Getting the parent's position requires the collection.\n      // Cell.parent() holds cell id only.\n      if (!this.graph) throw new Error('Element must be part of a graph.');\n      const parent = this.getParentCell();\n\n      if (parent && !parent.isLink()) {\n        parentPosition = parent.get('position');\n      }\n    }\n\n    if (isSetter) {\n      if (parentPosition) {\n        x += parentPosition.x;\n        y += parentPosition.y;\n      }\n\n      if (deep || restrictedArea) {\n        const {\n          x: x0,\n          y: y0\n        } = this.get('position');\n        this.translate(x - x0, y - y0, opt);\n      } else {\n        this.set('position', {\n          x,\n          y\n        }, opt);\n      }\n\n      return this;\n    } else {\n      // Getter returns a geometry point.\n      const elementPosition = Point(this.get('position'));\n      return parentRelative ? elementPosition.difference(parentPosition) : elementPosition;\n    }\n  },\n  translate: function (tx, ty, opt) {\n    tx = tx || 0;\n    ty = ty || 0;\n\n    if (tx === 0 && ty === 0) {\n      // Like nothing has happened.\n      return this;\n    }\n\n    opt = opt || {}; // Pass the initiator of the translation.\n\n    opt.translateBy = opt.translateBy || this.id;\n    var position = this.get('position') || {\n      x: 0,\n      y: 0\n    };\n    var ra = opt.restrictedArea;\n\n    if (ra && opt.translateBy === this.id) {\n      if (typeof ra === 'function') {\n        var newPosition = ra.call(this, position.x + tx, position.y + ty, opt);\n        tx = newPosition.x - position.x;\n        ty = newPosition.y - position.y;\n      } else {\n        // We are restricting the translation for the element itself only. We get\n        // the bounding box of the element including all its embeds.\n        // All embeds have to be translated the exact same way as the element.\n        var bbox = this.getBBox({\n          deep: true\n        }); //- - - - - - - - - - - - -> ra.x + ra.width\n        // - - - -> position.x      |\n        // -> bbox.x\n        //                ▓▓▓▓▓▓▓   |\n        //         ░░░░░░░▓▓▓▓▓▓▓\n        //         ░░░░░░░░░        |\n        //   ▓▓▓▓▓▓▓▓░░░░░░░\n        //   ▓▓▓▓▓▓▓▓               |\n        //   <-dx->                     | restricted area right border\n        //         <-width->        |   ░ translated element\n        //   <- - bbox.width - ->       ▓ embedded element\n\n        var dx = position.x - bbox.x;\n        var dy = position.y - bbox.y; // Find the maximal/minimal coordinates that the element can be translated\n        // while complies the restrictions.\n\n        var x = Math.max(ra.x + dx, Math.min(ra.x + ra.width + dx - bbox.width, position.x + tx));\n        var y = Math.max(ra.y + dy, Math.min(ra.y + ra.height + dy - bbox.height, position.y + ty)); // recalculate the translation taking the restrictions into account.\n\n        tx = x - position.x;\n        ty = y - position.y;\n      }\n    }\n\n    var translatedPosition = {\n      x: position.x + tx,\n      y: position.y + ty\n    }; // To find out by how much an element was translated in event 'change:position' handlers.\n\n    opt.tx = tx;\n    opt.ty = ty;\n\n    if (opt.transition) {\n      if (!isObject(opt.transition)) opt.transition = {};\n      this.transition('position', translatedPosition, assign({}, opt.transition, {\n        valueFunction: interpolate.object\n      })); // Recursively call `translate()` on all the embeds cells.\n\n      invoke(this.getEmbeddedCells(), 'translate', tx, ty, opt);\n    } else {\n      this.startBatch('translate', opt);\n      this.set('position', translatedPosition, opt);\n      invoke(this.getEmbeddedCells(), 'translate', tx, ty, opt);\n      this.stopBatch('translate', opt);\n    }\n\n    return this;\n  },\n  size: function (width, height, opt) {\n    var currentSize = this.get('size'); // Getter\n    // () signature\n\n    if (width === undefined) {\n      return {\n        width: currentSize.width,\n        height: currentSize.height\n      };\n    } // Setter\n    // (size, opt) signature\n\n\n    if (isObject(width)) {\n      opt = height;\n      height = isNumber(width.height) ? width.height : currentSize.height;\n      width = isNumber(width.width) ? width.width : currentSize.width;\n    }\n\n    return this.resize(width, height, opt);\n  },\n  resize: function (width, height, opt) {\n    opt = opt || {};\n    this.startBatch('resize', opt);\n\n    if (opt.direction) {\n      var currentSize = this.get('size');\n\n      switch (opt.direction) {\n        case 'left':\n        case 'right':\n          // Don't change height when resizing horizontally.\n          height = currentSize.height;\n          break;\n\n        case 'top':\n        case 'bottom':\n          // Don't change width when resizing vertically.\n          width = currentSize.width;\n          break;\n      } // Get the angle and clamp its value between 0 and 360 degrees.\n\n\n      var angle = normalizeAngle(this.get('angle') || 0); // This is a rectangle in size of the un-rotated element.\n\n      var bbox = this.getBBox();\n      var origin;\n\n      if (angle) {\n        var quadrant = {\n          'top-right': 0,\n          'right': 0,\n          'top-left': 1,\n          'top': 1,\n          'bottom-left': 2,\n          'left': 2,\n          'bottom-right': 3,\n          'bottom': 3\n        }[opt.direction];\n\n        if (opt.absolute) {\n          // We are taking the element's rotation into account\n          quadrant += Math.floor((angle + 45) / 90);\n          quadrant %= 4;\n        } // Pick the corner point on the element, which meant to stay on its place before and\n        // after the rotation.\n\n\n        var fixedPoint = bbox[['bottomLeft', 'corner', 'topRight', 'origin'][quadrant]](); // Find  an image of the previous indent point. This is the position, where is the\n        // point actually located on the screen.\n\n        var imageFixedPoint = Point(fixedPoint).rotate(bbox.center(), -angle); // Every point on the element rotates around a circle with the centre of rotation\n        // in the middle of the element while the whole element is being rotated. That means\n        // that the distance from a point in the corner of the element (supposed its always rect) to\n        // the center of the element doesn't change during the rotation and therefore it equals\n        // to a distance on un-rotated element.\n        // We can find the distance as DISTANCE = (ELEMENTWIDTH/2)^2 + (ELEMENTHEIGHT/2)^2)^0.5.\n\n        var radius = Math.sqrt(width * width + height * height) / 2; // Now we are looking for an angle between x-axis and the line starting at image of fixed point\n        // and ending at the center of the element. We call this angle `alpha`.\n        // The image of a fixed point is located in n-th quadrant. For each quadrant passed\n        // going anti-clockwise we have to add 90 degrees. Note that the first quadrant has index 0.\n        //\n        // 3 | 2\n        // --c-- Quadrant positions around the element's center `c`\n        // 0 | 1\n        //\n\n        var alpha = quadrant * Math.PI / 2; // Add an angle between the beginning of the current quadrant (line parallel with x-axis or y-axis\n        // going through the center of the element) and line crossing the indent of the fixed point and the center\n        // of the element. This is the angle we need but on the un-rotated element.\n\n        alpha += Math.atan(quadrant % 2 == 0 ? height / width : width / height); // Lastly we have to deduct the original angle the element was rotated by and that's it.\n\n        alpha -= toRad(angle); // With this angle and distance we can easily calculate the centre of the un-rotated element.\n        // Note that fromPolar constructor accepts an angle in radians.\n\n        var center = Point.fromPolar(radius, alpha, imageFixedPoint); // The top left corner on the un-rotated element has to be half a width on the left\n        // and half a height to the top from the center. This will be the origin of rectangle\n        // we were looking for.\n\n        origin = Point(center).offset(width / -2, height / -2);\n      } else {\n        // calculation for the origin Point when there is no rotation of the element\n        origin = bbox.topLeft();\n\n        switch (opt.direction) {\n          case 'top':\n          case 'top-right':\n            origin.offset(0, bbox.height - height);\n            break;\n\n          case 'left':\n          case 'bottom-left':\n            origin.offset(bbox.width - width, 0);\n            break;\n\n          case 'top-left':\n            origin.offset(bbox.width - width, bbox.height - height);\n            break;\n        }\n      } // Resize the element (before re-positioning it).\n\n\n      this.set('size', {\n        width: width,\n        height: height\n      }, opt); // Finally, re-position the element.\n\n      this.position(origin.x, origin.y, opt);\n    } else {\n      // Resize the element.\n      this.set('size', {\n        width: width,\n        height: height\n      }, opt);\n    }\n\n    this.stopBatch('resize', opt);\n    return this;\n  },\n  scale: function (sx, sy, origin, opt) {\n    var scaledBBox = this.getBBox().scale(sx, sy, origin);\n    this.startBatch('scale', opt);\n    this.position(scaledBBox.x, scaledBBox.y, opt);\n    this.resize(scaledBBox.width, scaledBBox.height, opt);\n    this.stopBatch('scale');\n    return this;\n  },\n  fitEmbeds: function (opt = {}) {\n    // Getting the children's size and position requires the collection.\n    // Cell.get('embeds') helds an array of cell ids only.\n    const {\n      graph\n    } = this;\n    if (!graph) throw new Error('Element must be part of a graph.');\n    const embeddedCells = this.getEmbeddedCells().filter(cell => cell.isElement());\n    if (embeddedCells.length === 0) return this;\n    this.startBatch('fit-embeds', opt);\n\n    if (opt.deep) {\n      // Recursively apply fitEmbeds on all embeds first.\n      invoke(embeddedCells, 'fitEmbeds', opt);\n    } // Compute cell's size and position based on the children bbox\n    // and given padding.\n\n\n    const {\n      left,\n      right,\n      top,\n      bottom\n    } = normalizeSides(opt.padding);\n    let {\n      x,\n      y,\n      width,\n      height\n    } = graph.getCellsBBox(embeddedCells); // Apply padding computed above to the bbox.\n\n    x -= left;\n    y -= top;\n    width += left + right;\n    height += bottom + top; // Set new element dimensions finally.\n\n    this.set({\n      position: {\n        x,\n        y\n      },\n      size: {\n        width,\n        height\n      }\n    }, opt);\n    this.stopBatch('fit-embeds');\n    return this;\n  },\n  // Rotate element by `angle` degrees, optionally around `origin` point.\n  // If `origin` is not provided, it is considered to be the center of the element.\n  // If `absolute` is `true`, the `angle` is considered is absolute, i.e. it is not\n  // the difference from the previous angle.\n  rotate: function (angle, absolute, origin, opt) {\n    if (origin) {\n      var center = this.getBBox().center();\n      var size = this.get('size');\n      var position = this.get('position');\n      center.rotate(origin, this.get('angle') - angle);\n      var dx = center.x - size.width / 2 - position.x;\n      var dy = center.y - size.height / 2 - position.y;\n      this.startBatch('rotate', {\n        angle: angle,\n        absolute: absolute,\n        origin: origin\n      });\n      this.position(position.x + dx, position.y + dy, opt);\n      this.rotate(angle, absolute, null, opt);\n      this.stopBatch('rotate');\n    } else {\n      this.set('angle', absolute ? angle : (this.get('angle') + angle) % 360, opt);\n    }\n\n    return this;\n  },\n  angle: function () {\n    return normalizeAngle(this.get('angle') || 0);\n  },\n  getBBox: function (opt = {}) {\n    const {\n      graph,\n      attributes\n    } = this;\n    const {\n      deep,\n      rotate\n    } = opt;\n\n    if (deep && graph) {\n      // Get all the embedded elements using breadth first algorithm.\n      const elements = this.getEmbeddedCells({\n        deep: true,\n        breadthFirst: true\n      }); // Add the model itself.\n\n      elements.push(this); // Note: the default of getCellsBBox() is rotate=true and can't be\n      // changed without a breaking change\n\n      return graph.getCellsBBox(elements, opt);\n    }\n\n    const {\n      angle = 0,\n      position: {\n        x,\n        y\n      },\n      size: {\n        width,\n        height\n      }\n    } = attributes;\n    const bbox = new Rect(x, y, width, height);\n\n    if (rotate) {\n      bbox.rotateAroundCenter(angle);\n    }\n\n    return bbox;\n  },\n  getPointFromConnectedLink: function (link, endType) {\n    // Center of the model\n    var bbox = this.getBBox();\n    var center = bbox.center(); // Center of a port\n\n    var endDef = link.get(endType);\n    if (!endDef) return center;\n    var portId = endDef.port;\n    if (!portId || !this.hasPort(portId)) return center;\n    var portGroup = this.portProp(portId, ['group']);\n    var portsPositions = this.getPortsPositions(portGroup);\n    var portCenter = new Point(portsPositions[portId]).offset(bbox.origin());\n    var angle = this.angle();\n    if (angle) portCenter.rotate(center, -angle);\n    return portCenter;\n  }\n});\nassign(Element.prototype, elementPortPrototype);","map":{"version":3,"names":["Cell","Point","toRad","normalizeAngle","Rect","isNumber","isObject","interpolate","assign","invoke","normalizeSides","elementPortPrototype","Element","extend","defaults","position","x","y","size","width","height","angle","initialize","_initializePorts","prototype","apply","arguments","_refreshPorts","isElement","opt","isSetter","parentRelative","deep","restrictedArea","parentPosition","graph","Error","parent","getParentCell","isLink","get","x0","y0","translate","set","elementPosition","difference","tx","ty","translateBy","id","ra","newPosition","call","bbox","getBBox","dx","dy","Math","max","min","translatedPosition","transition","valueFunction","object","getEmbeddedCells","startBatch","stopBatch","currentSize","undefined","resize","direction","origin","quadrant","absolute","floor","fixedPoint","imageFixedPoint","rotate","center","radius","sqrt","alpha","PI","atan","fromPolar","offset","topLeft","scale","sx","sy","scaledBBox","fitEmbeds","embeddedCells","filter","cell","length","left","right","top","bottom","padding","getCellsBBox","attributes","elements","breadthFirst","push","rotateAroundCenter","getPointFromConnectedLink","link","endType","endDef","portId","port","hasPort","portGroup","portProp","portsPositions","getPortsPositions","portCenter"],"sources":["C:/Users/Admin/dataflow-test/node_modules/jointjs/src/dia/Element.mjs"],"sourcesContent":["import { Cell } from './Cell.mjs';\nimport { Point, toRad, normalizeAngle, Rect } from '../g/index.mjs';\nimport { isNumber, isObject, interpolate, assign, invoke, normalizeSides } from '../util/index.mjs';\nimport { elementPortPrototype } from './ports.mjs';\n\n// Element base model.\n// -----------------------------\n\nexport const Element = Cell.extend({\n\n    defaults: {\n        position: { x: 0, y: 0 },\n        size: { width: 1, height: 1 },\n        angle: 0\n    },\n\n    initialize: function() {\n\n        this._initializePorts();\n        Cell.prototype.initialize.apply(this, arguments);\n    },\n\n    /**\n     * @abstract\n     */\n    _initializePorts: function() {\n        // implemented in ports.js\n    },\n\n    _refreshPorts: function() {\n        // implemented in ports.js\n    },\n\n    isElement: function() {\n\n        return true;\n    },\n\n    position: function(x, y, opt) {\n\n        const isSetter = isNumber(y);\n        opt = (isSetter ? opt : x) || {};\n        const { parentRelative, deep, restrictedArea } = opt;\n\n\n        // option `parentRelative` for setting the position relative to the element's parent.\n        let parentPosition;\n        if (parentRelative) {\n\n            // Getting the parent's position requires the collection.\n            // Cell.parent() holds cell id only.\n            if (!this.graph) throw new Error('Element must be part of a graph.');\n\n            const parent = this.getParentCell();\n            if (parent && !parent.isLink()) {\n                parentPosition = parent.get('position');\n            }\n        }\n\n        if (isSetter) {\n\n            if (parentPosition) {\n                x += parentPosition.x;\n                y += parentPosition.y;\n            }\n\n            if (deep || restrictedArea) {\n                const { x: x0, y: y0 } = this.get('position');\n                this.translate(x - x0, y - y0, opt);\n            } else {\n                this.set('position', { x, y }, opt);\n            }\n\n            return this;\n\n        } else { // Getter returns a geometry point.\n\n            const elementPosition = Point(this.get('position'));\n            return parentRelative\n                ? elementPosition.difference(parentPosition)\n                : elementPosition;\n        }\n    },\n\n    translate: function(tx, ty, opt) {\n\n        tx = tx || 0;\n        ty = ty || 0;\n\n        if (tx === 0 && ty === 0) {\n            // Like nothing has happened.\n            return this;\n        }\n\n        opt = opt || {};\n        // Pass the initiator of the translation.\n        opt.translateBy = opt.translateBy || this.id;\n\n        var position = this.get('position') || { x: 0, y: 0 };\n        var ra = opt.restrictedArea;\n        if (ra && opt.translateBy === this.id) {\n\n            if (typeof ra === 'function') {\n\n                var newPosition = ra.call(this, position.x + tx, position.y + ty, opt);\n\n                tx = newPosition.x - position.x;\n                ty = newPosition.y - position.y;\n\n            } else  {\n                // We are restricting the translation for the element itself only. We get\n                // the bounding box of the element including all its embeds.\n                // All embeds have to be translated the exact same way as the element.\n                var bbox = this.getBBox({ deep: true });\n                //- - - - - - - - - - - - -> ra.x + ra.width\n                // - - - -> position.x      |\n                // -> bbox.x\n                //                ▓▓▓▓▓▓▓   |\n                //         ░░░░░░░▓▓▓▓▓▓▓\n                //         ░░░░░░░░░        |\n                //   ▓▓▓▓▓▓▓▓░░░░░░░\n                //   ▓▓▓▓▓▓▓▓               |\n                //   <-dx->                     | restricted area right border\n                //         <-width->        |   ░ translated element\n                //   <- - bbox.width - ->       ▓ embedded element\n                var dx = position.x - bbox.x;\n                var dy = position.y - bbox.y;\n                // Find the maximal/minimal coordinates that the element can be translated\n                // while complies the restrictions.\n                var x = Math.max(ra.x + dx, Math.min(ra.x + ra.width + dx - bbox.width, position.x + tx));\n                var y = Math.max(ra.y + dy, Math.min(ra.y + ra.height + dy - bbox.height, position.y + ty));\n                // recalculate the translation taking the restrictions into account.\n                tx = x - position.x;\n                ty = y - position.y;\n            }\n        }\n\n        var translatedPosition = {\n            x: position.x + tx,\n            y: position.y + ty\n        };\n\n        // To find out by how much an element was translated in event 'change:position' handlers.\n        opt.tx = tx;\n        opt.ty = ty;\n\n        if (opt.transition) {\n\n            if (!isObject(opt.transition)) opt.transition = {};\n\n            this.transition('position', translatedPosition, assign({}, opt.transition, {\n                valueFunction: interpolate.object\n            }));\n\n            // Recursively call `translate()` on all the embeds cells.\n            invoke(this.getEmbeddedCells(), 'translate', tx, ty, opt);\n\n        } else {\n\n            this.startBatch('translate', opt);\n            this.set('position', translatedPosition, opt);\n            invoke(this.getEmbeddedCells(), 'translate', tx, ty, opt);\n            this.stopBatch('translate', opt);\n        }\n\n        return this;\n    },\n\n    size: function(width, height, opt) {\n\n        var currentSize = this.get('size');\n        // Getter\n        // () signature\n        if (width === undefined) {\n            return {\n                width: currentSize.width,\n                height: currentSize.height\n            };\n        }\n        // Setter\n        // (size, opt) signature\n        if (isObject(width)) {\n            opt = height;\n            height = isNumber(width.height) ? width.height : currentSize.height;\n            width = isNumber(width.width) ? width.width : currentSize.width;\n        }\n\n        return this.resize(width, height, opt);\n    },\n\n    resize: function(width, height, opt) {\n\n        opt = opt || {};\n\n        this.startBatch('resize', opt);\n\n        if (opt.direction) {\n\n            var currentSize = this.get('size');\n\n            switch (opt.direction) {\n\n                case 'left':\n                case 'right':\n                    // Don't change height when resizing horizontally.\n                    height = currentSize.height;\n                    break;\n\n                case 'top':\n                case 'bottom':\n                    // Don't change width when resizing vertically.\n                    width = currentSize.width;\n                    break;\n            }\n\n            // Get the angle and clamp its value between 0 and 360 degrees.\n            var angle = normalizeAngle(this.get('angle') || 0);\n\n            // This is a rectangle in size of the un-rotated element.\n            var bbox = this.getBBox();\n\n            var origin;\n\n            if (angle) {\n\n                var quadrant = {\n                    'top-right': 0,\n                    'right': 0,\n                    'top-left': 1,\n                    'top': 1,\n                    'bottom-left': 2,\n                    'left': 2,\n                    'bottom-right': 3,\n                    'bottom': 3\n                }[opt.direction];\n\n                if (opt.absolute) {\n\n                    // We are taking the element's rotation into account\n                    quadrant += Math.floor((angle + 45) / 90);\n                    quadrant %= 4;\n                }\n\n                // Pick the corner point on the element, which meant to stay on its place before and\n                // after the rotation.\n                var fixedPoint = bbox[['bottomLeft', 'corner', 'topRight', 'origin'][quadrant]]();\n\n                // Find  an image of the previous indent point. This is the position, where is the\n                // point actually located on the screen.\n                var imageFixedPoint = Point(fixedPoint).rotate(bbox.center(), -angle);\n\n                // Every point on the element rotates around a circle with the centre of rotation\n                // in the middle of the element while the whole element is being rotated. That means\n                // that the distance from a point in the corner of the element (supposed its always rect) to\n                // the center of the element doesn't change during the rotation and therefore it equals\n                // to a distance on un-rotated element.\n                // We can find the distance as DISTANCE = (ELEMENTWIDTH/2)^2 + (ELEMENTHEIGHT/2)^2)^0.5.\n                var radius = Math.sqrt((width * width) + (height * height)) / 2;\n\n                // Now we are looking for an angle between x-axis and the line starting at image of fixed point\n                // and ending at the center of the element. We call this angle `alpha`.\n\n                // The image of a fixed point is located in n-th quadrant. For each quadrant passed\n                // going anti-clockwise we have to add 90 degrees. Note that the first quadrant has index 0.\n                //\n                // 3 | 2\n                // --c-- Quadrant positions around the element's center `c`\n                // 0 | 1\n                //\n                var alpha = quadrant * Math.PI / 2;\n\n                // Add an angle between the beginning of the current quadrant (line parallel with x-axis or y-axis\n                // going through the center of the element) and line crossing the indent of the fixed point and the center\n                // of the element. This is the angle we need but on the un-rotated element.\n                alpha += Math.atan(quadrant % 2 == 0 ? height / width : width / height);\n\n                // Lastly we have to deduct the original angle the element was rotated by and that's it.\n                alpha -= toRad(angle);\n\n                // With this angle and distance we can easily calculate the centre of the un-rotated element.\n                // Note that fromPolar constructor accepts an angle in radians.\n                var center = Point.fromPolar(radius, alpha, imageFixedPoint);\n\n                // The top left corner on the un-rotated element has to be half a width on the left\n                // and half a height to the top from the center. This will be the origin of rectangle\n                // we were looking for.\n                origin = Point(center).offset(width / -2, height / -2);\n\n            } else {\n                // calculation for the origin Point when there is no rotation of the element\n                origin = bbox.topLeft();\n\n                switch (opt.direction) {\n                    case 'top':\n                    case 'top-right':\n                        origin.offset(0, bbox.height - height);\n                        break;\n                    case 'left':\n                    case 'bottom-left':\n                        origin.offset(bbox.width -width, 0);\n                        break;\n                    case 'top-left':\n                        origin.offset(bbox.width - width, bbox.height - height);\n                        break;\n                }\n            }\n\n            // Resize the element (before re-positioning it).\n            this.set('size', { width: width, height: height }, opt);\n\n            // Finally, re-position the element.\n            this.position(origin.x, origin.y, opt);\n\n        } else {\n\n            // Resize the element.\n            this.set('size', { width: width, height: height }, opt);\n        }\n\n        this.stopBatch('resize', opt);\n\n        return this;\n    },\n\n    scale: function(sx, sy, origin, opt) {\n\n        var scaledBBox = this.getBBox().scale(sx, sy, origin);\n        this.startBatch('scale', opt);\n        this.position(scaledBBox.x, scaledBBox.y, opt);\n        this.resize(scaledBBox.width, scaledBBox.height, opt);\n        this.stopBatch('scale');\n        return this;\n    },\n\n    fitEmbeds: function(opt = {}) {\n\n        // Getting the children's size and position requires the collection.\n        // Cell.get('embeds') helds an array of cell ids only.\n        const { graph } = this;\n        if (!graph) throw new Error('Element must be part of a graph.');\n\n        const embeddedCells = this.getEmbeddedCells().filter(cell => cell.isElement());\n        if (embeddedCells.length === 0) return this;\n\n        this.startBatch('fit-embeds', opt);\n\n        if (opt.deep) {\n            // Recursively apply fitEmbeds on all embeds first.\n            invoke(embeddedCells, 'fitEmbeds', opt);\n        }\n\n        // Compute cell's size and position based on the children bbox\n        // and given padding.\n        const { left, right, top, bottom } = normalizeSides(opt.padding);\n        let { x, y, width, height } = graph.getCellsBBox(embeddedCells);\n        // Apply padding computed above to the bbox.\n        x -= left;\n        y -= top;\n        width += left + right;\n        height += bottom + top;\n\n        // Set new element dimensions finally.\n        this.set({\n            position: { x, y },\n            size: { width, height }\n        }, opt);\n\n        this.stopBatch('fit-embeds');\n\n        return this;\n    },\n\n    // Rotate element by `angle` degrees, optionally around `origin` point.\n    // If `origin` is not provided, it is considered to be the center of the element.\n    // If `absolute` is `true`, the `angle` is considered is absolute, i.e. it is not\n    // the difference from the previous angle.\n    rotate: function(angle, absolute, origin, opt) {\n\n        if (origin) {\n\n            var center = this.getBBox().center();\n            var size = this.get('size');\n            var position = this.get('position');\n            center.rotate(origin, this.get('angle') - angle);\n            var dx = center.x - size.width / 2 - position.x;\n            var dy = center.y - size.height / 2 - position.y;\n            this.startBatch('rotate', { angle: angle, absolute: absolute, origin: origin });\n            this.position(position.x + dx, position.y + dy, opt);\n            this.rotate(angle, absolute, null, opt);\n            this.stopBatch('rotate');\n\n        } else {\n\n            this.set('angle', absolute ? angle : (this.get('angle') + angle) % 360, opt);\n        }\n\n        return this;\n    },\n\n    angle: function() {\n        return normalizeAngle(this.get('angle') || 0);\n    },\n\n    getBBox: function(opt = {}) {\n\n        const { graph, attributes } = this;\n        const { deep, rotate } = opt;\n\n        if (deep && graph) {\n            // Get all the embedded elements using breadth first algorithm.\n            const elements = this.getEmbeddedCells({ deep: true, breadthFirst: true });\n            // Add the model itself.\n            elements.push(this);\n            // Note: the default of getCellsBBox() is rotate=true and can't be\n            // changed without a breaking change\n            return graph.getCellsBBox(elements, opt);\n        }\n\n        const { angle = 0, position: { x, y }, size: { width, height }} = attributes;\n        const bbox = new Rect(x, y, width, height);\n        if (rotate) {\n            bbox.rotateAroundCenter(angle);\n        }\n        return bbox;\n    },\n\n    getPointFromConnectedLink: function(link, endType) {\n        // Center of the model\n        var bbox = this.getBBox();\n        var center = bbox.center();\n        // Center of a port\n        var endDef = link.get(endType);\n        if (!endDef) return center;\n        var portId = endDef.port;\n        if (!portId || !this.hasPort(portId)) return center;\n        var portGroup = this.portProp(portId, ['group']);\n        var portsPositions = this.getPortsPositions(portGroup);\n        var portCenter = new Point(portsPositions[portId]).offset(bbox.origin());\n        var angle = this.angle();\n        if (angle) portCenter.rotate(center, -angle);\n        return portCenter;\n    }\n});\n\nassign(Element.prototype, elementPortPrototype);\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}