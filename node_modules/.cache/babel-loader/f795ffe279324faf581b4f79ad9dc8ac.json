{"ast":null,"code":"import { Point } from './point.mjs';\nimport { Rect } from './rect.mjs';\nimport { bearing } from './line.bearing.mjs';\nimport { squaredLength } from './line.squaredLength.mjs';\nimport { length } from './line.length.mjs';\nimport { types } from './types.mjs';\nconst {\n  max,\n  min\n} = Math;\nexport const Line = function (p1, p2) {\n  if (!(this instanceof Line)) {\n    return new Line(p1, p2);\n  }\n\n  if (p1 instanceof Line) {\n    return new Line(p1.start, p1.end);\n  }\n\n  this.start = new Point(p1);\n  this.end = new Point(p2);\n};\nLine.prototype = {\n  type: types.Line,\n  // @returns the angle of incline of the line.\n  angle: function () {\n    var horizontalPoint = new Point(this.start.x + 1, this.start.y);\n    return this.start.angleBetween(this.end, horizontalPoint);\n  },\n  bbox: function () {\n    var left = min(this.start.x, this.end.x);\n    var top = min(this.start.y, this.end.y);\n    var right = max(this.start.x, this.end.x);\n    var bottom = max(this.start.y, this.end.y);\n    return new Rect(left, top, right - left, bottom - top);\n  },\n  // @return the bearing (cardinal direction) of the line. For example N, W, or SE.\n  // @returns {String} One of the following bearings : NE, E, SE, S, SW, W, NW, N.\n  bearing: function () {\n    return bearing(this.start, this.end);\n  },\n  clone: function () {\n    return new Line(this.start, this.end);\n  },\n  // @return {point} the closest point on the line to point `p`\n  closestPoint: function (p) {\n    return this.pointAt(this.closestPointNormalizedLength(p));\n  },\n  closestPointLength: function (p) {\n    return this.closestPointNormalizedLength(p) * this.length();\n  },\n  // @return {number} the normalized length of the closest point on the line to point `p`\n  closestPointNormalizedLength: function (p) {\n    var product = this.vector().dot(new Line(this.start, p).vector());\n    var cpNormalizedLength = min(1, max(0, product / this.squaredLength())); // cpNormalizedLength returns `NaN` if this line has zero length\n    // we can work with that - if `NaN`, return 0\n\n    if (cpNormalizedLength !== cpNormalizedLength) return 0; // condition evaluates to `true` if and only if cpNormalizedLength is `NaN`\n    // (`NaN` is the only value that is not equal to itself)\n\n    return cpNormalizedLength;\n  },\n  closestPointTangent: function (p) {\n    return this.tangentAt(this.closestPointNormalizedLength(p));\n  },\n  // Returns `true` if the point lies on the line.\n  containsPoint: function (p) {\n    var start = this.start;\n    var end = this.end;\n    if (start.cross(p, end) !== 0) return false; // else: cross product of 0 indicates that this line and the vector to `p` are collinear\n\n    var length = this.length();\n    if (new Line(start, p).length() > length) return false;\n    if (new Line(p, end).length() > length) return false; // else: `p` lies between start and end of the line\n\n    return true;\n  },\n  // Divides the line into two at requested `ratio` between 0 and 1.\n  divideAt: function (ratio) {\n    var dividerPoint = this.pointAt(ratio); // return array with two lines\n\n    return [new Line(this.start, dividerPoint), new Line(dividerPoint, this.end)];\n  },\n  // Divides the line into two at requested `length`.\n  divideAtLength: function (length) {\n    var dividerPoint = this.pointAtLength(length); // return array with two new lines\n\n    return [new Line(this.start, dividerPoint), new Line(dividerPoint, this.end)];\n  },\n  equals: function (l) {\n    return !!l && this.start.x === l.start.x && this.start.y === l.start.y && this.end.x === l.end.x && this.end.y === l.end.y;\n  },\n  // @return {point} Point where I'm intersecting a line.\n  // @return [point] Points where I'm intersecting a rectangle.\n  // @see Squeak Smalltalk, LineSegment>>intersectionWith:\n  intersect: function (shape, opt) {\n    if (shape && shape.intersectionWithLine) {\n      var intersection = shape.intersectionWithLine(this, opt); // Backwards compatibility\n\n      if (intersection && shape instanceof Line) {\n        intersection = intersection[0];\n      }\n\n      return intersection;\n    }\n\n    return null;\n  },\n  intersectionWithLine: function (line) {\n    var pt1Dir = new Point(this.end.x - this.start.x, this.end.y - this.start.y);\n    var pt2Dir = new Point(line.end.x - line.start.x, line.end.y - line.start.y);\n    var det = pt1Dir.x * pt2Dir.y - pt1Dir.y * pt2Dir.x;\n    var deltaPt = new Point(line.start.x - this.start.x, line.start.y - this.start.y);\n    var alpha = deltaPt.x * pt2Dir.y - deltaPt.y * pt2Dir.x;\n    var beta = deltaPt.x * pt1Dir.y - deltaPt.y * pt1Dir.x;\n\n    if (det === 0 || alpha * det < 0 || beta * det < 0) {\n      // No intersection found.\n      return null;\n    }\n\n    if (det > 0) {\n      if (alpha > det || beta > det) {\n        return null;\n      }\n    } else {\n      if (alpha < det || beta < det) {\n        return null;\n      }\n    }\n\n    return [new Point(this.start.x + alpha * pt1Dir.x / det, this.start.y + alpha * pt1Dir.y / det)];\n  },\n  isDifferentiable: function () {\n    return !this.start.equals(this.end);\n  },\n  // @return {double} length of the line\n  length: function () {\n    return length(this.start, this.end);\n  },\n  // @return {point} my midpoint\n  midpoint: function () {\n    return new Point((this.start.x + this.end.x) / 2, (this.start.y + this.end.y) / 2);\n  },\n  parallel: function (distance) {\n    const l = this.clone();\n    if (!this.isDifferentiable()) return l;\n    const {\n      start,\n      end\n    } = l;\n    const eRef = start.clone().rotate(end, 270);\n    const sRef = end.clone().rotate(start, 90);\n    start.move(sRef, distance);\n    end.move(eRef, distance);\n    return l;\n  },\n  // @return {point} my point at 't' <0,1>\n  pointAt: function (t) {\n    var start = this.start;\n    var end = this.end;\n    if (t <= 0) return start.clone();\n    if (t >= 1) return end.clone();\n    return start.lerp(end, t);\n  },\n  pointAtLength: function (length) {\n    var start = this.start;\n    var end = this.end;\n    var fromStart = true;\n\n    if (length < 0) {\n      fromStart = false; // negative lengths mean start calculation from end point\n\n      length = -length; // absolute value\n    }\n\n    var lineLength = this.length();\n    if (length >= lineLength) return fromStart ? end.clone() : start.clone();\n    return this.pointAt((fromStart ? length : lineLength - length) / lineLength);\n  },\n  // @return {number} the offset of the point `p` from the line. + if the point `p` is on the right side of the line, - if on the left and 0 if on the line.\n  pointOffset: function (p) {\n    // Find the sign of the determinant of vectors (start,end), where p is the query point.\n    p = new Point(p);\n    var start = this.start;\n    var end = this.end;\n    var determinant = (end.x - start.x) * (p.y - start.y) - (end.y - start.y) * (p.x - start.x);\n    return determinant / this.length();\n  },\n  rotate: function (origin, angle) {\n    this.start.rotate(origin, angle);\n    this.end.rotate(origin, angle);\n    return this;\n  },\n  round: function (precision) {\n    this.start.round(precision);\n    this.end.round(precision);\n    return this;\n  },\n  scale: function (sx, sy, origin) {\n    this.start.scale(sx, sy, origin);\n    this.end.scale(sx, sy, origin);\n    return this;\n  },\n  // @return {number} scale the line so that it has the requested length\n  setLength: function (length) {\n    var currentLength = this.length();\n    if (!currentLength) return this;\n    var scaleFactor = length / currentLength;\n    return this.scale(scaleFactor, scaleFactor, this.start);\n  },\n  // @return {integer} length without sqrt\n  // @note for applications where the exact length is not necessary (e.g. compare only)\n  squaredLength: function () {\n    return squaredLength(this.start, this.end);\n  },\n  tangentAt: function (t) {\n    if (!this.isDifferentiable()) return null;\n    var start = this.start;\n    var end = this.end;\n    var tangentStart = this.pointAt(t); // constrains `t` between 0 and 1\n\n    var tangentLine = new Line(start, end);\n    tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y); // move so that tangent line starts at the point requested\n\n    return tangentLine;\n  },\n  tangentAtLength: function (length) {\n    if (!this.isDifferentiable()) return null;\n    var start = this.start;\n    var end = this.end;\n    var tangentStart = this.pointAtLength(length);\n    var tangentLine = new Line(start, end);\n    tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y); // move so that tangent line starts at the point requested\n\n    return tangentLine;\n  },\n  toString: function () {\n    return this.start.toString() + ' ' + this.end.toString();\n  },\n  serialize: function () {\n    return this.start.serialize() + ' ' + this.end.serialize();\n  },\n  translate: function (tx, ty) {\n    this.start.translate(tx, ty);\n    this.end.translate(tx, ty);\n    return this;\n  },\n  // @return vector {point} of the line\n  vector: function () {\n    return new Point(this.end.x - this.start.x, this.end.y - this.start.y);\n  }\n}; // For backwards compatibility:\n\nLine.prototype.intersection = Line.prototype.intersect; // For backwards compatibility:\n\nexport const line = Line;","map":{"version":3,"names":["Point","Rect","bearing","squaredLength","length","types","max","min","Math","Line","p1","p2","start","end","prototype","type","angle","horizontalPoint","x","y","angleBetween","bbox","left","top","right","bottom","clone","closestPoint","p","pointAt","closestPointNormalizedLength","closestPointLength","product","vector","dot","cpNormalizedLength","closestPointTangent","tangentAt","containsPoint","cross","divideAt","ratio","dividerPoint","divideAtLength","pointAtLength","equals","l","intersect","shape","opt","intersectionWithLine","intersection","line","pt1Dir","pt2Dir","det","deltaPt","alpha","beta","isDifferentiable","midpoint","parallel","distance","eRef","rotate","sRef","move","t","lerp","fromStart","lineLength","pointOffset","determinant","origin","round","precision","scale","sx","sy","setLength","currentLength","scaleFactor","tangentStart","tangentLine","translate","tangentAtLength","toString","serialize","tx","ty"],"sources":["C:/Users/Admin/dataflow-test/node_modules/jointjs/src/g/line.mjs"],"sourcesContent":["import { Point } from './point.mjs';\nimport { Rect } from './rect.mjs';\nimport { bearing } from './line.bearing.mjs';\nimport { squaredLength } from './line.squaredLength.mjs';\nimport { length } from './line.length.mjs';\nimport { types } from './types.mjs';\n\nconst {\n    max,\n    min\n} = Math;\n\nexport const Line = function(p1, p2) {\n\n    if (!(this instanceof Line)) {\n        return new Line(p1, p2);\n    }\n\n    if (p1 instanceof Line) {\n        return new Line(p1.start, p1.end);\n    }\n\n    this.start = new Point(p1);\n    this.end = new Point(p2);\n};\n\nLine.prototype = {\n\n    type: types.Line,\n\n    // @returns the angle of incline of the line.\n    angle: function() {\n\n        var horizontalPoint = new Point(this.start.x + 1, this.start.y);\n        return this.start.angleBetween(this.end, horizontalPoint);\n    },\n\n    bbox: function() {\n\n        var left = min(this.start.x, this.end.x);\n        var top = min(this.start.y, this.end.y);\n        var right = max(this.start.x, this.end.x);\n        var bottom = max(this.start.y, this.end.y);\n\n        return new Rect(left, top, (right - left), (bottom - top));\n    },\n\n    // @return the bearing (cardinal direction) of the line. For example N, W, or SE.\n    // @returns {String} One of the following bearings : NE, E, SE, S, SW, W, NW, N.\n    bearing: function() {\n        return bearing(this.start, this.end);\n    },\n\n    clone: function() {\n\n        return new Line(this.start, this.end);\n    },\n\n    // @return {point} the closest point on the line to point `p`\n    closestPoint: function(p) {\n\n        return this.pointAt(this.closestPointNormalizedLength(p));\n    },\n\n    closestPointLength: function(p) {\n\n        return this.closestPointNormalizedLength(p) * this.length();\n    },\n\n    // @return {number} the normalized length of the closest point on the line to point `p`\n    closestPointNormalizedLength: function(p) {\n\n        var product = this.vector().dot((new Line(this.start, p)).vector());\n        var cpNormalizedLength = min(1, max(0, product / this.squaredLength()));\n\n        // cpNormalizedLength returns `NaN` if this line has zero length\n        // we can work with that - if `NaN`, return 0\n        if (cpNormalizedLength !== cpNormalizedLength) return 0; // condition evaluates to `true` if and only if cpNormalizedLength is `NaN`\n        // (`NaN` is the only value that is not equal to itself)\n\n        return cpNormalizedLength;\n    },\n\n    closestPointTangent: function(p) {\n\n        return this.tangentAt(this.closestPointNormalizedLength(p));\n    },\n\n    // Returns `true` if the point lies on the line.\n    containsPoint: function(p) {\n\n        var start = this.start;\n        var end = this.end;\n\n        if (start.cross(p, end) !== 0) return false;\n        // else: cross product of 0 indicates that this line and the vector to `p` are collinear\n\n        var length = this.length();\n        if ((new Line(start, p)).length() > length) return false;\n        if ((new Line(p, end)).length() > length) return false;\n        // else: `p` lies between start and end of the line\n\n        return true;\n    },\n\n    // Divides the line into two at requested `ratio` between 0 and 1.\n    divideAt: function(ratio) {\n\n        var dividerPoint = this.pointAt(ratio);\n\n        // return array with two lines\n        return [\n            new Line(this.start, dividerPoint),\n            new Line(dividerPoint, this.end)\n        ];\n    },\n\n    // Divides the line into two at requested `length`.\n    divideAtLength: function(length) {\n\n        var dividerPoint = this.pointAtLength(length);\n\n        // return array with two new lines\n        return [\n            new Line(this.start, dividerPoint),\n            new Line(dividerPoint, this.end)\n        ];\n    },\n\n    equals: function(l) {\n\n        return !!l &&\n            this.start.x === l.start.x &&\n            this.start.y === l.start.y &&\n            this.end.x === l.end.x &&\n            this.end.y === l.end.y;\n    },\n\n    // @return {point} Point where I'm intersecting a line.\n    // @return [point] Points where I'm intersecting a rectangle.\n    // @see Squeak Smalltalk, LineSegment>>intersectionWith:\n    intersect: function(shape, opt) {\n\n        if (shape && shape.intersectionWithLine) {\n            var intersection = shape.intersectionWithLine(this, opt);\n\n            // Backwards compatibility\n            if (intersection && (shape instanceof Line)) {\n                intersection = intersection[0];\n            }\n\n            return intersection;\n        }\n\n        return null;\n    },\n\n    intersectionWithLine: function(line) {\n\n        var pt1Dir = new Point(this.end.x - this.start.x, this.end.y - this.start.y);\n        var pt2Dir = new Point(line.end.x - line.start.x, line.end.y - line.start.y);\n        var det = (pt1Dir.x * pt2Dir.y) - (pt1Dir.y * pt2Dir.x);\n        var deltaPt = new Point(line.start.x - this.start.x, line.start.y - this.start.y);\n        var alpha = (deltaPt.x * pt2Dir.y) - (deltaPt.y * pt2Dir.x);\n        var beta = (deltaPt.x * pt1Dir.y) - (deltaPt.y * pt1Dir.x);\n\n        if (det === 0 || alpha * det < 0 || beta * det < 0) {\n            // No intersection found.\n            return null;\n        }\n\n        if (det > 0) {\n            if (alpha > det || beta > det) {\n                return null;\n            }\n\n        } else {\n            if (alpha < det || beta < det) {\n                return null;\n            }\n        }\n\n        return [new Point(\n            this.start.x + (alpha * pt1Dir.x / det),\n            this.start.y + (alpha * pt1Dir.y / det)\n        )];\n    },\n\n    isDifferentiable: function() {\n\n        return !this.start.equals(this.end);\n    },\n\n    // @return {double} length of the line\n    length: function() {\n        return length(this.start, this.end);\n    },\n\n    // @return {point} my midpoint\n    midpoint: function() {\n\n        return new Point(\n            (this.start.x + this.end.x) / 2,\n            (this.start.y + this.end.y) / 2\n        );\n    },\n\n    parallel: function(distance) {\n        const l = this.clone();\n        if (!this.isDifferentiable()) return l;\n        const { start, end } = l;\n        const eRef = start.clone().rotate(end, 270);\n        const sRef = end.clone().rotate(start, 90);\n        start.move(sRef, distance);\n        end.move(eRef, distance);\n        return l;\n    },\n\n    // @return {point} my point at 't' <0,1>\n    pointAt: function(t) {\n\n        var start = this.start;\n        var end = this.end;\n\n        if (t <= 0) return start.clone();\n        if (t >= 1) return end.clone();\n\n        return start.lerp(end, t);\n    },\n\n    pointAtLength: function(length) {\n\n        var start = this.start;\n        var end = this.end;\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        var lineLength = this.length();\n        if (length >= lineLength) return (fromStart ? end.clone() : start.clone());\n\n        return this.pointAt((fromStart ? (length) : (lineLength - length)) / lineLength);\n    },\n\n    // @return {number} the offset of the point `p` from the line. + if the point `p` is on the right side of the line, - if on the left and 0 if on the line.\n    pointOffset: function(p) {\n\n        // Find the sign of the determinant of vectors (start,end), where p is the query point.\n        p = new Point(p);\n        var start = this.start;\n        var end = this.end;\n        var determinant = ((end.x - start.x) * (p.y - start.y) - (end.y - start.y) * (p.x - start.x));\n\n        return determinant / this.length();\n    },\n\n    rotate: function(origin, angle) {\n\n        this.start.rotate(origin, angle);\n        this.end.rotate(origin, angle);\n        return this;\n    },\n\n    round: function(precision) {\n\n        this.start.round(precision);\n        this.end.round(precision);\n        return this;\n    },\n\n    scale: function(sx, sy, origin) {\n\n        this.start.scale(sx, sy, origin);\n        this.end.scale(sx, sy, origin);\n        return this;\n    },\n\n    // @return {number} scale the line so that it has the requested length\n    setLength: function(length) {\n\n        var currentLength = this.length();\n        if (!currentLength) return this;\n\n        var scaleFactor = length / currentLength;\n        return this.scale(scaleFactor, scaleFactor, this.start);\n    },\n\n    // @return {integer} length without sqrt\n    // @note for applications where the exact length is not necessary (e.g. compare only)\n    squaredLength: function() {\n        return squaredLength(this.start, this.end);\n    },\n\n    tangentAt: function(t) {\n\n        if (!this.isDifferentiable()) return null;\n\n        var start = this.start;\n        var end = this.end;\n\n        var tangentStart = this.pointAt(t); // constrains `t` between 0 and 1\n\n        var tangentLine = new Line(start, end);\n        tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y); // move so that tangent line starts at the point requested\n\n        return tangentLine;\n    },\n\n    tangentAtLength: function(length) {\n\n        if (!this.isDifferentiable()) return null;\n\n        var start = this.start;\n        var end = this.end;\n\n        var tangentStart = this.pointAtLength(length);\n\n        var tangentLine = new Line(start, end);\n        tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y); // move so that tangent line starts at the point requested\n\n        return tangentLine;\n    },\n\n    toString: function() {\n\n        return this.start.toString() + ' ' + this.end.toString();\n    },\n\n    serialize: function() {\n\n        return this.start.serialize() + ' ' + this.end.serialize();\n    },\n\n    translate: function(tx, ty) {\n\n        this.start.translate(tx, ty);\n        this.end.translate(tx, ty);\n        return this;\n    },\n\n    // @return vector {point} of the line\n    vector: function() {\n\n        return new Point(this.end.x - this.start.x, this.end.y - this.start.y);\n    }\n};\n\n// For backwards compatibility:\nLine.prototype.intersection = Line.prototype.intersect;\n\n\n// For backwards compatibility:\nexport const line = Line;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}