{"ast":null,"code":"import { Rect } from './rect.mjs';\nimport { Point } from './point.mjs';\nimport { Line } from './line.mjs';\nimport { types } from './types.mjs';\nimport { clonePoints, parsePoints, convexHull } from './points.mjs';\nexport const Polyline = function (points) {\n  if (!(this instanceof Polyline)) {\n    return new Polyline(points);\n  }\n\n  if (typeof points === 'string') {\n    return new Polyline.parse(points);\n  }\n\n  this.points = Array.isArray(points) ? points.map(Point) : [];\n};\n\nPolyline.parse = function (svgString) {\n  return new Polyline(parsePoints(svgString));\n};\n\nPolyline.fromRect = function (rect) {\n  return new Polyline([rect.topLeft(), rect.topRight(), rect.bottomRight(), rect.bottomLeft(), rect.topLeft()]);\n};\n\nPolyline.prototype = {\n  type: types.Polyline,\n  bbox: function () {\n    var x1 = Infinity;\n    var x2 = -Infinity;\n    var y1 = Infinity;\n    var y2 = -Infinity;\n    var points = this.points;\n    var numPoints = points.length;\n    if (numPoints === 0) return null; // if points array is empty\n\n    for (var i = 0; i < numPoints; i++) {\n      var point = points[i];\n      var x = point.x;\n      var y = point.y;\n      if (x < x1) x1 = x;\n      if (x > x2) x2 = x;\n      if (y < y1) y1 = y;\n      if (y > y2) y2 = y;\n    }\n\n    return new Rect(x1, y1, x2 - x1, y2 - y1);\n  },\n  clone: function () {\n    return new Polyline(clonePoints(this.points));\n  },\n  closestPoint: function (p) {\n    var cpLength = this.closestPointLength(p);\n    return this.pointAtLength(cpLength);\n  },\n  closestPointLength: function (p) {\n    var points = this.lengthPoints();\n    var numPoints = points.length;\n    if (numPoints === 0) return 0; // if points array is empty\n\n    if (numPoints === 1) return 0; // if there is only one point\n\n    var cpLength;\n    var minSqrDistance = Infinity;\n    var length = 0;\n    var n = numPoints - 1;\n\n    for (var i = 0; i < n; i++) {\n      var line = new Line(points[i], points[i + 1]);\n      var lineLength = line.length();\n      var cpNormalizedLength = line.closestPointNormalizedLength(p);\n      var cp = line.pointAt(cpNormalizedLength);\n      var sqrDistance = cp.squaredDistance(p);\n\n      if (sqrDistance < minSqrDistance) {\n        minSqrDistance = sqrDistance;\n        cpLength = length + cpNormalizedLength * lineLength;\n      }\n\n      length += lineLength;\n    }\n\n    return cpLength;\n  },\n  closestPointNormalizedLength: function (p) {\n    var cpLength = this.closestPointLength(p);\n    if (cpLength === 0) return 0; // shortcut\n\n    var length = this.length();\n    if (length === 0) return 0; // prevents division by zero\n\n    return cpLength / length;\n  },\n  closestPointTangent: function (p) {\n    var cpLength = this.closestPointLength(p);\n    return this.tangentAtLength(cpLength);\n  },\n  // Returns `true` if the area surrounded by the polyline contains the point `p`.\n  // Implements the even-odd SVG algorithm (self-intersections are \"outside\").\n  // (Uses horizontal rays to the right of `p` to look for intersections.)\n  // Closes open polylines (always imagines a final closing segment).\n  containsPoint: function (p) {\n    var points = this.points;\n    var numPoints = points.length;\n    if (numPoints === 0) return false; // shortcut (this polyline has no points)\n\n    var x = p.x;\n    var y = p.y; // initialize a final closing segment by creating one from last-first points on polyline\n\n    var startIndex = numPoints - 1; // start of current polyline segment\n\n    var endIndex = 0; // end of current polyline segment\n\n    var numIntersections = 0;\n    var segment = new Line();\n    var ray = new Line();\n    var rayEnd = new Point();\n\n    for (; endIndex < numPoints; endIndex++) {\n      var start = points[startIndex];\n      var end = points[endIndex];\n      if (p.equals(start)) return true; // shortcut (`p` is a point on polyline)\n      // current polyline segment\n\n      segment.start = start;\n      segment.end = end;\n      if (segment.containsPoint(p)) return true; // shortcut (`p` lies on a polyline segment)\n      // do we have an intersection?\n\n      if (y <= start.y && y > end.y || y > start.y && y <= end.y) {\n        // this conditional branch IS NOT entered when `segment` is collinear/coincident with `ray`\n        // (when `y === start.y === end.y`)\n        // this conditional branch IS entered when `segment` touches `ray` at only one point\n        // (e.g. when `y === start.y !== end.y`)\n        // since this branch is entered again for the following segment, the two touches cancel out\n        var xDifference = start.x - x > end.x - x ? start.x - x : end.x - x;\n\n        if (xDifference >= 0) {\n          // segment lies at least partially to the right of `p`\n          rayEnd.x = x + xDifference;\n          rayEnd.y = y; // right\n\n          ray.start = p;\n          ray.end = rayEnd;\n\n          if (segment.intersect(ray)) {\n            // an intersection was detected to the right of `p`\n            numIntersections++;\n          }\n        } // else: `segment` lies completely to the left of `p` (i.e. no intersection to the right)\n\n      } // move to check the next polyline segment\n\n\n      startIndex = endIndex;\n    } // returns `true` for odd numbers of intersections (even-odd algorithm)\n\n\n    return numIntersections % 2 === 1;\n  },\n  close: function () {\n    const {\n      start,\n      end,\n      points\n    } = this;\n\n    if (start && end && !start.equals(end)) {\n      points.push(start.clone());\n    }\n\n    return this;\n  },\n  lengthPoints: function () {\n    return this.points;\n  },\n  convexHull: function () {\n    return new Polyline(convexHull(this.points));\n  },\n  // Checks whether two polylines are exactly the same.\n  // If `p` is undefined or null, returns false.\n  equals: function (p) {\n    if (!p) return false;\n    var points = this.points;\n    var otherPoints = p.points;\n    var numPoints = points.length;\n    if (otherPoints.length !== numPoints) return false; // if the two polylines have different number of points, they cannot be equal\n\n    for (var i = 0; i < numPoints; i++) {\n      var point = points[i];\n      var otherPoint = p.points[i]; // as soon as an inequality is found in points, return false\n\n      if (!point.equals(otherPoint)) return false;\n    } // if no inequality found in points, return true\n\n\n    return true;\n  },\n  intersectionWithLine: function (l) {\n    var line = new Line(l);\n    var intersections = [];\n    var points = this.lengthPoints();\n    var l2 = new Line();\n\n    for (var i = 0, n = points.length - 1; i < n; i++) {\n      l2.start = points[i];\n      l2.end = points[i + 1];\n      var int = line.intersectionWithLine(l2);\n      if (int) intersections.push(int[0]);\n    }\n\n    return intersections.length > 0 ? intersections : null;\n  },\n  isDifferentiable: function () {\n    var points = this.points;\n    var numPoints = points.length;\n    if (numPoints === 0) return false;\n    var line = new Line();\n    var n = numPoints - 1;\n\n    for (var i = 0; i < n; i++) {\n      line.start = points[i];\n      line.end = points[i + 1]; // as soon as a differentiable line is found between two points, return true\n\n      if (line.isDifferentiable()) return true;\n    } // if no differentiable line is found between pairs of points, return false\n\n\n    return false;\n  },\n  length: function () {\n    var points = this.lengthPoints();\n    var numPoints = points.length;\n    if (numPoints === 0) return 0; // if points array is empty\n\n    var length = 0;\n    var n = numPoints - 1;\n\n    for (var i = 0; i < n; i++) {\n      length += points[i].distance(points[i + 1]);\n    }\n\n    return length;\n  },\n  pointAt: function (ratio) {\n    var points = this.lengthPoints();\n    var numPoints = points.length;\n    if (numPoints === 0) return null; // if points array is empty\n\n    if (numPoints === 1) return points[0].clone(); // if there is only one point\n\n    if (ratio <= 0) return points[0].clone();\n    if (ratio >= 1) return points[numPoints - 1].clone();\n    var polylineLength = this.length();\n    var length = polylineLength * ratio;\n    return this.pointAtLength(length);\n  },\n  pointAtLength: function (length) {\n    var points = this.lengthPoints();\n    var numPoints = points.length;\n    if (numPoints === 0) return null; // if points array is empty\n\n    if (numPoints === 1) return points[0].clone(); // if there is only one point\n\n    var fromStart = true;\n\n    if (length < 0) {\n      fromStart = false; // negative lengths mean start calculation from end point\n\n      length = -length; // absolute value\n    }\n\n    var l = 0;\n    var n = numPoints - 1;\n\n    for (var i = 0; i < n; i++) {\n      var index = fromStart ? i : n - 1 - i;\n      var a = points[index];\n      var b = points[index + 1];\n      var line = new Line(a, b);\n      var d = a.distance(b);\n\n      if (length <= l + d) {\n        return line.pointAtLength((fromStart ? 1 : -1) * (length - l));\n      }\n\n      l += d;\n    } // if length requested is higher than the length of the polyline, return last endpoint\n\n\n    var lastPoint = fromStart ? points[numPoints - 1] : points[0];\n    return lastPoint.clone();\n  },\n  round: function (precision) {\n    var points = this.points;\n    var numPoints = points.length;\n\n    for (var i = 0; i < numPoints; i++) {\n      points[i].round(precision);\n    }\n\n    return this;\n  },\n  scale: function (sx, sy, origin) {\n    var points = this.points;\n    var numPoints = points.length;\n\n    for (var i = 0; i < numPoints; i++) {\n      points[i].scale(sx, sy, origin);\n    }\n\n    return this;\n  },\n  simplify: function (opt = {}) {\n    const points = this.points;\n    if (points.length < 3) return this; // we need at least 3 points\n    // TODO: we may also accept startIndex and endIndex to specify where to start and end simplification\n\n    const threshold = opt.threshold || 0; // = max distance of middle point from chord to be simplified\n    // start at the beginning of the polyline and go forward\n\n    let currentIndex = 0; // we need at least one intermediate point (3 points) in every iteration\n    // as soon as that stops being true, we know we reached the end of the polyline\n\n    while (points[currentIndex + 2]) {\n      const firstIndex = currentIndex;\n      const middleIndex = currentIndex + 1;\n      const lastIndex = currentIndex + 2;\n      const firstPoint = points[firstIndex];\n      const middlePoint = points[middleIndex];\n      const lastPoint = points[lastIndex];\n      const chord = new Line(firstPoint, lastPoint); // = connection between first and last point\n\n      const closestPoint = chord.closestPoint(middlePoint); // = closest point on chord from middle point\n\n      const closestPointDistance = closestPoint.distance(middlePoint);\n\n      if (closestPointDistance <= threshold) {\n        // middle point is close enough to the chord = simplify\n        // 1) remove middle point:\n        points.splice(middleIndex, 1); // 2) in next iteration, investigate the newly-created triplet of points\n        //    - do not change `currentIndex`\n        //    = (first point stays, point after removed point becomes middle point)\n      } else {\n        // middle point is far from the chord\n        // 1) preserve middle point\n        // 2) in next iteration, move `currentIndex` by one step:\n        currentIndex += 1; //    = (point after first point becomes first point)\n      }\n    } // `points` array was modified in-place\n\n\n    return this;\n  },\n  tangentAt: function (ratio) {\n    var points = this.lengthPoints();\n    var numPoints = points.length;\n    if (numPoints === 0) return null; // if points array is empty\n\n    if (numPoints === 1) return null; // if there is only one point\n\n    if (ratio < 0) ratio = 0;\n    if (ratio > 1) ratio = 1;\n    var polylineLength = this.length();\n    var length = polylineLength * ratio;\n    return this.tangentAtLength(length);\n  },\n  tangentAtLength: function (length) {\n    var points = this.lengthPoints();\n    var numPoints = points.length;\n    if (numPoints === 0) return null; // if points array is empty\n\n    if (numPoints === 1) return null; // if there is only one point\n\n    var fromStart = true;\n\n    if (length < 0) {\n      fromStart = false; // negative lengths mean start calculation from end point\n\n      length = -length; // absolute value\n    }\n\n    var lastValidLine; // differentiable (with a tangent)\n\n    var l = 0; // length so far\n\n    var n = numPoints - 1;\n\n    for (var i = 0; i < n; i++) {\n      var index = fromStart ? i : n - 1 - i;\n      var a = points[index];\n      var b = points[index + 1];\n      var line = new Line(a, b);\n      var d = a.distance(b);\n\n      if (line.isDifferentiable()) {\n        // has a tangent line (line length is not 0)\n        if (length <= l + d) {\n          return line.tangentAtLength((fromStart ? 1 : -1) * (length - l));\n        }\n\n        lastValidLine = line;\n      }\n\n      l += d;\n    } // if length requested is higher than the length of the polyline, return last valid endpoint\n\n\n    if (lastValidLine) {\n      var ratio = fromStart ? 1 : 0;\n      return lastValidLine.tangentAt(ratio);\n    } // if no valid line, return null\n\n\n    return null;\n  },\n  toString: function () {\n    return this.points + '';\n  },\n  translate: function (tx, ty) {\n    var points = this.points;\n    var numPoints = points.length;\n\n    for (var i = 0; i < numPoints; i++) {\n      points[i].translate(tx, ty);\n    }\n\n    return this;\n  },\n  // Return svgString that can be used to recreate this line.\n  serialize: function () {\n    var points = this.points;\n    var numPoints = points.length;\n    if (numPoints === 0) return ''; // if points array is empty\n\n    var output = '';\n\n    for (var i = 0; i < numPoints; i++) {\n      var point = points[i];\n      output += point.x + ',' + point.y + ' ';\n    }\n\n    return output.trim();\n  }\n};\nObject.defineProperty(Polyline.prototype, 'start', {\n  // Getter for the first point of the polyline.\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    var points = this.points;\n    var numPoints = points.length;\n    if (numPoints === 0) return null; // if points array is empty\n\n    return this.points[0];\n  }\n});\nObject.defineProperty(Polyline.prototype, 'end', {\n  // Getter for the last point of the polyline.\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    var points = this.points;\n    var numPoints = points.length;\n    if (numPoints === 0) return null; // if points array is empty\n\n    return this.points[numPoints - 1];\n  }\n});","map":{"version":3,"names":["Rect","Point","Line","types","clonePoints","parsePoints","convexHull","Polyline","points","parse","Array","isArray","map","svgString","fromRect","rect","topLeft","topRight","bottomRight","bottomLeft","prototype","type","bbox","x1","Infinity","x2","y1","y2","numPoints","length","i","point","x","y","clone","closestPoint","p","cpLength","closestPointLength","pointAtLength","lengthPoints","minSqrDistance","n","line","lineLength","cpNormalizedLength","closestPointNormalizedLength","cp","pointAt","sqrDistance","squaredDistance","closestPointTangent","tangentAtLength","containsPoint","startIndex","endIndex","numIntersections","segment","ray","rayEnd","start","end","equals","xDifference","intersect","close","push","otherPoints","otherPoint","intersectionWithLine","l","intersections","l2","int","isDifferentiable","distance","ratio","polylineLength","fromStart","index","a","b","d","lastPoint","round","precision","scale","sx","sy","origin","simplify","opt","threshold","currentIndex","firstIndex","middleIndex","lastIndex","firstPoint","middlePoint","chord","closestPointDistance","splice","tangentAt","lastValidLine","toString","translate","tx","ty","serialize","output","trim","Object","defineProperty","configurable","enumerable","get"],"sources":["C:/Users/Admin/dataflow-test/node_modules/jointjs/src/g/polyline.mjs"],"sourcesContent":["import { Rect } from './rect.mjs';\nimport { Point } from './point.mjs';\nimport { Line } from './line.mjs';\nimport { types } from './types.mjs';\nimport { clonePoints, parsePoints, convexHull } from './points.mjs';\n\n\nexport const Polyline = function(points) {\n\n    if (!(this instanceof Polyline)) {\n        return new Polyline(points);\n    }\n\n    if (typeof points === 'string') {\n        return new Polyline.parse(points);\n    }\n\n    this.points = (Array.isArray(points) ? points.map(Point) : []);\n};\n\nPolyline.parse = function(svgString) {\n    return new Polyline(parsePoints(svgString));\n};\n\nPolyline.fromRect = function(rect) {\n    return new Polyline([\n        rect.topLeft(),\n        rect.topRight(),\n        rect.bottomRight(),\n        rect.bottomLeft(),\n        rect.topLeft(),\n    ]);\n};\n\nPolyline.prototype = {\n\n    type: types.Polyline,\n\n    bbox: function() {\n\n        var x1 = Infinity;\n        var x2 = -Infinity;\n        var y1 = Infinity;\n        var y2 = -Infinity;\n\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n\n        for (var i = 0; i < numPoints; i++) {\n\n            var point = points[i];\n            var x = point.x;\n            var y = point.y;\n\n            if (x < x1) x1 = x;\n            if (x > x2) x2 = x;\n            if (y < y1) y1 = y;\n            if (y > y2) y2 = y;\n        }\n\n        return new Rect(x1, y1, x2 - x1, y2 - y1);\n    },\n\n    clone: function() {\n        return new Polyline(clonePoints(this.points));\n    },\n\n    closestPoint: function(p) {\n\n        var cpLength = this.closestPointLength(p);\n\n        return this.pointAtLength(cpLength);\n    },\n\n    closestPointLength: function(p) {\n\n        var points = this.lengthPoints();\n        var numPoints = points.length;\n        if (numPoints === 0) return 0; // if points array is empty\n        if (numPoints === 1) return 0; // if there is only one point\n\n        var cpLength;\n        var minSqrDistance = Infinity;\n        var length = 0;\n        var n = numPoints - 1;\n        for (var i = 0; i < n; i++) {\n\n            var line = new Line(points[i], points[i + 1]);\n            var lineLength = line.length();\n\n            var cpNormalizedLength = line.closestPointNormalizedLength(p);\n            var cp = line.pointAt(cpNormalizedLength);\n\n            var sqrDistance = cp.squaredDistance(p);\n            if (sqrDistance < minSqrDistance) {\n                minSqrDistance = sqrDistance;\n                cpLength = length + (cpNormalizedLength * lineLength);\n            }\n\n            length += lineLength;\n        }\n\n        return cpLength;\n    },\n\n    closestPointNormalizedLength: function(p) {\n\n        var cpLength = this.closestPointLength(p);\n        if (cpLength === 0) return 0; // shortcut\n\n        var length = this.length();\n        if (length === 0) return 0; // prevents division by zero\n\n        return cpLength / length;\n    },\n\n    closestPointTangent: function(p) {\n\n        var cpLength = this.closestPointLength(p);\n\n        return this.tangentAtLength(cpLength);\n    },\n\n    // Returns `true` if the area surrounded by the polyline contains the point `p`.\n    // Implements the even-odd SVG algorithm (self-intersections are \"outside\").\n    // (Uses horizontal rays to the right of `p` to look for intersections.)\n    // Closes open polylines (always imagines a final closing segment).\n    containsPoint: function(p) {\n\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return false; // shortcut (this polyline has no points)\n\n        var x = p.x;\n        var y = p.y;\n\n        // initialize a final closing segment by creating one from last-first points on polyline\n        var startIndex = numPoints - 1; // start of current polyline segment\n        var endIndex = 0; // end of current polyline segment\n        var numIntersections = 0;\n        var segment = new Line();\n        var ray = new Line();\n        var rayEnd = new Point();\n        for (; endIndex < numPoints; endIndex++) {\n            var start = points[startIndex];\n            var end = points[endIndex];\n            if (p.equals(start)) return true; // shortcut (`p` is a point on polyline)\n            // current polyline segment\n            segment.start = start;\n            segment.end = end;\n            if (segment.containsPoint(p)) return true; // shortcut (`p` lies on a polyline segment)\n\n            // do we have an intersection?\n            if (((y <= start.y) && (y > end.y)) || ((y > start.y) && (y <= end.y))) {\n                // this conditional branch IS NOT entered when `segment` is collinear/coincident with `ray`\n                // (when `y === start.y === end.y`)\n                // this conditional branch IS entered when `segment` touches `ray` at only one point\n                // (e.g. when `y === start.y !== end.y`)\n                // since this branch is entered again for the following segment, the two touches cancel out\n\n                var xDifference = (((start.x - x) > (end.x - x)) ? (start.x - x) : (end.x - x));\n                if (xDifference >= 0) {\n                    // segment lies at least partially to the right of `p`\n                    rayEnd.x = x + xDifference;\n                    rayEnd.y = y; // right\n                    ray.start = p;\n                    ray.end = rayEnd;\n                    if (segment.intersect(ray)) {\n                        // an intersection was detected to the right of `p`\n                        numIntersections++;\n                    }\n                } // else: `segment` lies completely to the left of `p` (i.e. no intersection to the right)\n            }\n\n            // move to check the next polyline segment\n            startIndex = endIndex;\n        }\n\n        // returns `true` for odd numbers of intersections (even-odd algorithm)\n        return ((numIntersections % 2) === 1);\n    },\n\n    close: function() {\n        const { start, end, points } = this;\n        if (start && end && !start.equals(end)) {\n            points.push(start.clone());\n        }\n        return this;\n    },\n\n    lengthPoints: function() {\n        return this.points;\n    },\n\n    convexHull: function() {\n        return new Polyline(convexHull(this.points));\n    },\n\n    // Checks whether two polylines are exactly the same.\n    // If `p` is undefined or null, returns false.\n    equals: function(p) {\n\n        if (!p) return false;\n\n        var points = this.points;\n        var otherPoints = p.points;\n\n        var numPoints = points.length;\n        if (otherPoints.length !== numPoints) return false; // if the two polylines have different number of points, they cannot be equal\n\n        for (var i = 0; i < numPoints; i++) {\n\n            var point = points[i];\n            var otherPoint = p.points[i];\n\n            // as soon as an inequality is found in points, return false\n            if (!point.equals(otherPoint)) return false;\n        }\n\n        // if no inequality found in points, return true\n        return true;\n    },\n\n    intersectionWithLine: function(l) {\n        var line = new Line(l);\n        var intersections = [];\n        var points = this.lengthPoints();\n        var l2 = new Line();\n        for (var i = 0, n = points.length - 1; i < n; i++) {\n            l2.start = points[i];\n            l2.end = points[i + 1];\n            var int = line.intersectionWithLine(l2);\n            if (int) intersections.push(int[0]);\n        }\n        return (intersections.length > 0) ? intersections : null;\n    },\n\n    isDifferentiable: function() {\n\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return false;\n\n        var line = new Line();\n        var n = numPoints - 1;\n        for (var i = 0; i < n; i++) {\n            line.start = points[i];\n            line.end = points[i + 1];\n            // as soon as a differentiable line is found between two points, return true\n            if (line.isDifferentiable()) return true;\n        }\n\n        // if no differentiable line is found between pairs of points, return false\n        return false;\n    },\n\n    length: function() {\n\n        var points = this.lengthPoints();\n        var numPoints = points.length;\n        if (numPoints === 0) return 0; // if points array is empty\n\n        var length = 0;\n        var n = numPoints - 1;\n        for (var i = 0; i < n; i++) {\n            length += points[i].distance(points[i + 1]);\n        }\n\n        return length;\n    },\n\n    pointAt: function(ratio) {\n\n        var points = this.lengthPoints();\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n        if (numPoints === 1) return points[0].clone(); // if there is only one point\n\n        if (ratio <= 0) return points[0].clone();\n        if (ratio >= 1) return points[numPoints - 1].clone();\n\n        var polylineLength = this.length();\n        var length = polylineLength * ratio;\n\n        return this.pointAtLength(length);\n    },\n\n    pointAtLength: function(length) {\n\n        var points = this.lengthPoints();\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n        if (numPoints === 1) return points[0].clone(); // if there is only one point\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        var l = 0;\n        var n = numPoints - 1;\n        for (var i = 0; i < n; i++) {\n            var index = (fromStart ? i : (n - 1 - i));\n\n            var a = points[index];\n            var b = points[index + 1];\n            var line = new Line(a, b);\n            var d = a.distance(b);\n\n            if (length <= (l + d)) {\n                return line.pointAtLength((fromStart ? 1 : -1) * (length - l));\n            }\n\n            l += d;\n        }\n\n        // if length requested is higher than the length of the polyline, return last endpoint\n        var lastPoint = (fromStart ? points[numPoints - 1] : points[0]);\n        return lastPoint.clone();\n    },\n\n    round: function(precision) {\n\n        var points = this.points;\n        var numPoints = points.length;\n\n        for (var i = 0; i < numPoints; i++) {\n            points[i].round(precision);\n        }\n\n        return this;\n    },\n\n    scale: function(sx, sy, origin) {\n\n        var points = this.points;\n        var numPoints = points.length;\n\n        for (var i = 0; i < numPoints; i++) {\n            points[i].scale(sx, sy, origin);\n        }\n\n        return this;\n    },\n\n    simplify: function(opt = {}) {\n\n        const points = this.points;\n        if (points.length < 3) return this; // we need at least 3 points\n\n        // TODO: we may also accept startIndex and endIndex to specify where to start and end simplification\n        const threshold = opt.threshold || 0; // = max distance of middle point from chord to be simplified\n\n        // start at the beginning of the polyline and go forward\n        let currentIndex = 0;\n        // we need at least one intermediate point (3 points) in every iteration\n        // as soon as that stops being true, we know we reached the end of the polyline\n        while (points[currentIndex + 2]) {\n            const firstIndex = currentIndex;\n            const middleIndex = (currentIndex + 1);\n            const lastIndex = (currentIndex + 2);\n\n            const firstPoint = points[firstIndex];\n            const middlePoint = points[middleIndex];\n            const lastPoint = points[lastIndex];\n\n            const chord = new Line(firstPoint, lastPoint); // = connection between first and last point\n            const closestPoint = chord.closestPoint(middlePoint); // = closest point on chord from middle point\n            const closestPointDistance = closestPoint.distance(middlePoint);\n            if (closestPointDistance <= threshold) {\n                // middle point is close enough to the chord = simplify\n                // 1) remove middle point:\n                points.splice(middleIndex, 1);\n                // 2) in next iteration, investigate the newly-created triplet of points\n                //    - do not change `currentIndex`\n                //    = (first point stays, point after removed point becomes middle point)\n            } else {\n                // middle point is far from the chord\n                // 1) preserve middle point\n                // 2) in next iteration, move `currentIndex` by one step:\n                currentIndex += 1;\n                //    = (point after first point becomes first point)\n            }\n        }\n\n        // `points` array was modified in-place\n        return this;\n    },\n\n    tangentAt: function(ratio) {\n\n        var points = this.lengthPoints();\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n        if (numPoints === 1) return null; // if there is only one point\n\n        if (ratio < 0) ratio = 0;\n        if (ratio > 1) ratio = 1;\n\n        var polylineLength = this.length();\n        var length = polylineLength * ratio;\n\n        return this.tangentAtLength(length);\n    },\n\n    tangentAtLength: function(length) {\n\n        var points = this.lengthPoints();\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n        if (numPoints === 1) return null; // if there is only one point\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        var lastValidLine; // differentiable (with a tangent)\n        var l = 0; // length so far\n        var n = numPoints - 1;\n        for (var i = 0; i < n; i++) {\n            var index = (fromStart ? i : (n - 1 - i));\n\n            var a = points[index];\n            var b = points[index + 1];\n            var line = new Line(a, b);\n            var d = a.distance(b);\n\n            if (line.isDifferentiable()) { // has a tangent line (line length is not 0)\n                if (length <= (l + d)) {\n                    return line.tangentAtLength((fromStart ? 1 : -1) * (length - l));\n                }\n\n                lastValidLine = line;\n            }\n\n            l += d;\n        }\n\n        // if length requested is higher than the length of the polyline, return last valid endpoint\n        if (lastValidLine) {\n            var ratio = (fromStart ? 1 : 0);\n            return lastValidLine.tangentAt(ratio);\n        }\n\n        // if no valid line, return null\n        return null;\n    },\n\n    toString: function() {\n\n        return this.points + '';\n    },\n\n    translate: function(tx, ty) {\n\n        var points = this.points;\n        var numPoints = points.length;\n\n        for (var i = 0; i < numPoints; i++) {\n            points[i].translate(tx, ty);\n        }\n\n        return this;\n    },\n\n    // Return svgString that can be used to recreate this line.\n    serialize: function() {\n\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return ''; // if points array is empty\n\n        var output = '';\n        for (var i = 0; i < numPoints; i++) {\n\n            var point = points[i];\n            output += point.x + ',' + point.y + ' ';\n        }\n\n        return output.trim();\n    }\n};\n\nObject.defineProperty(Polyline.prototype, 'start', {\n    // Getter for the first point of the polyline.\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n\n        return this.points[0];\n    },\n});\n\nObject.defineProperty(Polyline.prototype, 'end', {\n    // Getter for the last point of the polyline.\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n\n        return this.points[numPoints - 1];\n    },\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}