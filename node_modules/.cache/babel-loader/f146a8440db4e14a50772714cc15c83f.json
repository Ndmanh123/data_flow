{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport * as util from '../util/index.mjs'; // Routes the link always to/from a certain side\n//\n// Arguments:\n//   padding ... gap between the element and the first vertex. :: Default 40.\n//   side ... 'left' | 'right' | 'top' | 'bottom' :: Default 'bottom'.\n//\n\nexport const oneSide = function (vertices, opt, linkView) {\n  var side = opt.side || 'bottom';\n  var padding = util.normalizeSides(opt.padding || 40); // LinkView contains cached source an target bboxes.\n  // Note that those are Geometry rectangle objects.\n\n  var sourceBBox = linkView.sourceBBox;\n  var targetBBox = linkView.targetBBox;\n  var sourcePoint = sourceBBox.center();\n  var targetPoint = targetBBox.center();\n  var coordinate, dimension, direction;\n\n  switch (side) {\n    case 'bottom':\n      direction = 1;\n      coordinate = 'y';\n      dimension = 'height';\n      break;\n\n    case 'top':\n      direction = -1;\n      coordinate = 'y';\n      dimension = 'height';\n      break;\n\n    case 'left':\n      direction = -1;\n      coordinate = 'x';\n      dimension = 'width';\n      break;\n\n    case 'right':\n      direction = 1;\n      coordinate = 'x';\n      dimension = 'width';\n      break;\n\n    default:\n      throw new Error('Router: invalid side');\n  } // move the points from the center of the element to outside of it.\n\n\n  sourcePoint[coordinate] += direction * (sourceBBox[dimension] / 2 + padding[side]);\n  targetPoint[coordinate] += direction * (targetBBox[dimension] / 2 + padding[side]); // make link orthogonal (at least the first and last vertex).\n\n  if (direction * (sourcePoint[coordinate] - targetPoint[coordinate]) > 0) {\n    targetPoint[coordinate] = sourcePoint[coordinate];\n  } else {\n    sourcePoint[coordinate] = targetPoint[coordinate];\n  }\n\n  return [sourcePoint].concat(vertices, targetPoint);\n};","map":{"version":3,"names":["util","oneSide","vertices","opt","linkView","side","padding","normalizeSides","sourceBBox","targetBBox","sourcePoint","center","targetPoint","coordinate","dimension","direction","Error","concat"],"sources":["C:/Users/Admin/dataflow-test/node_modules/jointjs/src/routers/oneSide.mjs"],"sourcesContent":["import * as util from '../util/index.mjs';\n\n// Routes the link always to/from a certain side\n//\n// Arguments:\n//   padding ... gap between the element and the first vertex. :: Default 40.\n//   side ... 'left' | 'right' | 'top' | 'bottom' :: Default 'bottom'.\n//\nexport const oneSide = function(vertices, opt, linkView) {\n\n    var side = opt.side || 'bottom';\n    var padding = util.normalizeSides(opt.padding || 40);\n\n    // LinkView contains cached source an target bboxes.\n    // Note that those are Geometry rectangle objects.\n    var sourceBBox = linkView.sourceBBox;\n    var targetBBox = linkView.targetBBox;\n    var sourcePoint = sourceBBox.center();\n    var targetPoint = targetBBox.center();\n\n    var coordinate, dimension, direction;\n\n    switch (side) {\n        case 'bottom':\n            direction = 1;\n            coordinate = 'y';\n            dimension = 'height';\n            break;\n        case 'top':\n            direction = -1;\n            coordinate = 'y';\n            dimension = 'height';\n            break;\n        case 'left':\n            direction = -1;\n            coordinate = 'x';\n            dimension = 'width';\n            break;\n        case 'right':\n            direction = 1;\n            coordinate = 'x';\n            dimension = 'width';\n            break;\n        default:\n            throw new Error('Router: invalid side');\n    }\n\n    // move the points from the center of the element to outside of it.\n    sourcePoint[coordinate] += direction * (sourceBBox[dimension] / 2 + padding[side]);\n    targetPoint[coordinate] += direction * (targetBBox[dimension] / 2 + padding[side]);\n\n    // make link orthogonal (at least the first and last vertex).\n    if ((direction * (sourcePoint[coordinate] - targetPoint[coordinate])) > 0) {\n        targetPoint[coordinate] = sourcePoint[coordinate];\n    } else {\n        sourcePoint[coordinate] = targetPoint[coordinate];\n    }\n\n    return [sourcePoint].concat(vertices, targetPoint);\n};\n"],"mappings":";AAAA,OAAO,KAAKA,IAAZ,MAAsB,mBAAtB,C,CAEA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,OAAO,GAAG,UAASC,QAAT,EAAmBC,GAAnB,EAAwBC,QAAxB,EAAkC;EAErD,IAAIC,IAAI,GAAGF,GAAG,CAACE,IAAJ,IAAY,QAAvB;EACA,IAAIC,OAAO,GAAGN,IAAI,CAACO,cAAL,CAAoBJ,GAAG,CAACG,OAAJ,IAAe,EAAnC,CAAd,CAHqD,CAKrD;EACA;;EACA,IAAIE,UAAU,GAAGJ,QAAQ,CAACI,UAA1B;EACA,IAAIC,UAAU,GAAGL,QAAQ,CAACK,UAA1B;EACA,IAAIC,WAAW,GAAGF,UAAU,CAACG,MAAX,EAAlB;EACA,IAAIC,WAAW,GAAGH,UAAU,CAACE,MAAX,EAAlB;EAEA,IAAIE,UAAJ,EAAgBC,SAAhB,EAA2BC,SAA3B;;EAEA,QAAQV,IAAR;IACI,KAAK,QAAL;MACIU,SAAS,GAAG,CAAZ;MACAF,UAAU,GAAG,GAAb;MACAC,SAAS,GAAG,QAAZ;MACA;;IACJ,KAAK,KAAL;MACIC,SAAS,GAAG,CAAC,CAAb;MACAF,UAAU,GAAG,GAAb;MACAC,SAAS,GAAG,QAAZ;MACA;;IACJ,KAAK,MAAL;MACIC,SAAS,GAAG,CAAC,CAAb;MACAF,UAAU,GAAG,GAAb;MACAC,SAAS,GAAG,OAAZ;MACA;;IACJ,KAAK,OAAL;MACIC,SAAS,GAAG,CAAZ;MACAF,UAAU,GAAG,GAAb;MACAC,SAAS,GAAG,OAAZ;MACA;;IACJ;MACI,MAAM,IAAIE,KAAJ,CAAU,sBAAV,CAAN;EAtBR,CAdqD,CAuCrD;;;EACAN,WAAW,CAACG,UAAD,CAAX,IAA2BE,SAAS,IAAIP,UAAU,CAACM,SAAD,CAAV,GAAwB,CAAxB,GAA4BR,OAAO,CAACD,IAAD,CAAvC,CAApC;EACAO,WAAW,CAACC,UAAD,CAAX,IAA2BE,SAAS,IAAIN,UAAU,CAACK,SAAD,CAAV,GAAwB,CAAxB,GAA4BR,OAAO,CAACD,IAAD,CAAvC,CAApC,CAzCqD,CA2CrD;;EACA,IAAKU,SAAS,IAAIL,WAAW,CAACG,UAAD,CAAX,GAA0BD,WAAW,CAACC,UAAD,CAAzC,CAAV,GAAoE,CAAxE,EAA2E;IACvED,WAAW,CAACC,UAAD,CAAX,GAA0BH,WAAW,CAACG,UAAD,CAArC;EACH,CAFD,MAEO;IACHH,WAAW,CAACG,UAAD,CAAX,GAA0BD,WAAW,CAACC,UAAD,CAArC;EACH;;EAED,OAAO,CAACH,WAAD,EAAcO,MAAd,CAAqBf,QAArB,EAA+BU,WAA/B,CAAP;AACH,CAnDM"},"metadata":{},"sourceType":"module"}