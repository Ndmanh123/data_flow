{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\n// Local helper function.\n// Add properties from arguments on top of properties from `obj`.\n// This allows for rudimentary inheritance.\n// - The `obj` argument acts as parent.\n// - This function creates a new object that inherits all `obj` properties and adds/replaces those that are present in arguments.\n// - A high-level example: calling `extend(Vehicle, Car)` would be akin to declaring `class Car extends Vehicle`.\nexport function extend(obj) {\n  // In JavaScript, the combination of a constructor function (e.g. `g.Line = function(...) {...}`) and prototype (e.g. `g.Line.prototype = {...}) is akin to a C++ class.\n  // - When inheritance is not necessary, we can leave it at that. (This would be akin to calling extend with only `obj`.)\n  // - But, what if we wanted the `g.Line` quasiclass to inherit from another quasiclass (let's call it `g.GeometryObject`) in JavaScript?\n  // - First, realize that both of those quasiclasses would still have their own separate constructor function.\n  // - So what we are actually saying is that we want the `g.Line` prototype to inherit from `g.GeometryObject` prototype.\n  // - This method provides a way to do exactly that.\n  // - It copies parent prototype's properties, then adds extra ones from child prototype/overrides parent prototype properties with child prototype properties.\n  // - Therefore, to continue with the example above:\n  //   - `g.Line.prototype = extend(g.GeometryObject.prototype, linePrototype)`\n  //   - Where `linePrototype` is a properties object that looks just like `g.Line.prototype` does right now.\n  //   - Then, `g.Line` would allow the programmer to access to all methods currently in `g.Line.Prototype`, plus any non-overridden methods from `g.GeometryObject.prototype`.\n  //   - In that aspect, `g.GeometryObject` would then act like the parent of `g.Line`.\n  // - Multiple inheritance is also possible, if multiple arguments are provided.\n  // - What if we wanted to add another level of abstraction between `g.GeometryObject` and `g.Line` (let's call it `g.LinearObject`)?\n  //   - `g.Line.prototype = extend(g.GeometryObject.prototype, g.LinearObject.prototype, linePrototype)`\n  //   - The ancestors are applied in order of appearance.\n  //   - That means that `g.Line` would have inherited from `g.LinearObject` that would have inherited from `g.GeometryObject`.\n  //   - Any number of ancestors may be provided.\n  // - Note that neither `obj` nor any of the arguments need to actually be prototypes of any JavaScript quasiclass, that was just a simplified explanation.\n  // - We can create a new object composed from the properties of any number of other objects (since they do not have a constructor, we can think of those as interfaces).\n  //   - `extend({ a: 1, b: 2 }, { b: 10, c: 20 }, { c: 100, d: 200 })` gives `{ a: 1, b: 10, c: 100, d: 200 }`.\n  //   - Basically, with this function, we can emulate the `extends` keyword as well as the `implements` keyword.\n  // - Therefore, both of the following are valid:\n  //   - `Lineto.prototype = extend(Line.prototype, segmentPrototype, linetoPrototype)`\n  //   - `Moveto.prototype = extend(segmentPrototype, movetoPrototype)`\n  var i;\n  var n;\n  var args = [];\n  n = arguments.length;\n\n  for (i = 1; i < n; i++) {\n    // skip over obj\n    args.push(arguments[i]);\n  }\n\n  if (!obj) throw new Error('Missing a parent object.');\n  var child = Object.create(obj);\n  n = args.length;\n\n  for (i = 0; i < n; i++) {\n    var src = args[i];\n    var inheritedProperty;\n    var key;\n\n    for (key in src) {\n      if (src.hasOwnProperty(key)) {\n        delete child[key]; // delete property inherited from parent\n\n        inheritedProperty = Object.getOwnPropertyDescriptor(src, key); // get new definition of property from src\n\n        Object.defineProperty(child, key, inheritedProperty); // re-add property with new definition (includes getter/setter methods)\n      }\n    }\n  }\n\n  return child;\n}","map":{"version":3,"names":["extend","obj","i","n","args","arguments","length","push","Error","child","Object","create","src","inheritedProperty","key","hasOwnProperty","getOwnPropertyDescriptor","defineProperty"],"sources":["C:/Users/Admin/dataflow-test/node_modules/jointjs/src/g/extend.mjs"],"sourcesContent":["// Local helper function.\n// Add properties from arguments on top of properties from `obj`.\n// This allows for rudimentary inheritance.\n// - The `obj` argument acts as parent.\n// - This function creates a new object that inherits all `obj` properties and adds/replaces those that are present in arguments.\n// - A high-level example: calling `extend(Vehicle, Car)` would be akin to declaring `class Car extends Vehicle`.\nexport function extend(obj) {\n    // In JavaScript, the combination of a constructor function (e.g. `g.Line = function(...) {...}`) and prototype (e.g. `g.Line.prototype = {...}) is akin to a C++ class.\n    // - When inheritance is not necessary, we can leave it at that. (This would be akin to calling extend with only `obj`.)\n    // - But, what if we wanted the `g.Line` quasiclass to inherit from another quasiclass (let's call it `g.GeometryObject`) in JavaScript?\n    // - First, realize that both of those quasiclasses would still have their own separate constructor function.\n    // - So what we are actually saying is that we want the `g.Line` prototype to inherit from `g.GeometryObject` prototype.\n    // - This method provides a way to do exactly that.\n    // - It copies parent prototype's properties, then adds extra ones from child prototype/overrides parent prototype properties with child prototype properties.\n    // - Therefore, to continue with the example above:\n    //   - `g.Line.prototype = extend(g.GeometryObject.prototype, linePrototype)`\n    //   - Where `linePrototype` is a properties object that looks just like `g.Line.prototype` does right now.\n    //   - Then, `g.Line` would allow the programmer to access to all methods currently in `g.Line.Prototype`, plus any non-overridden methods from `g.GeometryObject.prototype`.\n    //   - In that aspect, `g.GeometryObject` would then act like the parent of `g.Line`.\n    // - Multiple inheritance is also possible, if multiple arguments are provided.\n    // - What if we wanted to add another level of abstraction between `g.GeometryObject` and `g.Line` (let's call it `g.LinearObject`)?\n    //   - `g.Line.prototype = extend(g.GeometryObject.prototype, g.LinearObject.prototype, linePrototype)`\n    //   - The ancestors are applied in order of appearance.\n    //   - That means that `g.Line` would have inherited from `g.LinearObject` that would have inherited from `g.GeometryObject`.\n    //   - Any number of ancestors may be provided.\n    // - Note that neither `obj` nor any of the arguments need to actually be prototypes of any JavaScript quasiclass, that was just a simplified explanation.\n    // - We can create a new object composed from the properties of any number of other objects (since they do not have a constructor, we can think of those as interfaces).\n    //   - `extend({ a: 1, b: 2 }, { b: 10, c: 20 }, { c: 100, d: 200 })` gives `{ a: 1, b: 10, c: 100, d: 200 }`.\n    //   - Basically, with this function, we can emulate the `extends` keyword as well as the `implements` keyword.\n    // - Therefore, both of the following are valid:\n    //   - `Lineto.prototype = extend(Line.prototype, segmentPrototype, linetoPrototype)`\n    //   - `Moveto.prototype = extend(segmentPrototype, movetoPrototype)`\n\n    var i;\n    var n;\n\n    var args = [];\n    n = arguments.length;\n    for (i = 1; i < n; i++) { // skip over obj\n        args.push(arguments[i]);\n    }\n\n    if (!obj) throw new Error('Missing a parent object.');\n    var child = Object.create(obj);\n\n    n = args.length;\n    for (i = 0; i < n; i++) {\n\n        var src = args[i];\n\n        var inheritedProperty;\n        var key;\n        for (key in src) {\n\n            if (src.hasOwnProperty(key)) {\n                delete child[key]; // delete property inherited from parent\n                inheritedProperty = Object.getOwnPropertyDescriptor(src, key); // get new definition of property from src\n                Object.defineProperty(child, key, inheritedProperty); // re-add property with new definition (includes getter/setter methods)\n            }\n        }\n    }\n\n    return child;\n}\n"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,MAAT,CAAgBC,GAAhB,EAAqB;EACxB;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EAEA,IAAIC,CAAJ;EACA,IAAIC,CAAJ;EAEA,IAAIC,IAAI,GAAG,EAAX;EACAD,CAAC,GAAGE,SAAS,CAACC,MAAd;;EACA,KAAKJ,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGC,CAAhB,EAAmBD,CAAC,EAApB,EAAwB;IAAE;IACtBE,IAAI,CAACG,IAAL,CAAUF,SAAS,CAACH,CAAD,CAAnB;EACH;;EAED,IAAI,CAACD,GAAL,EAAU,MAAM,IAAIO,KAAJ,CAAU,0BAAV,CAAN;EACV,IAAIC,KAAK,GAAGC,MAAM,CAACC,MAAP,CAAcV,GAAd,CAAZ;EAEAE,CAAC,GAAGC,IAAI,CAACE,MAAT;;EACA,KAAKJ,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGC,CAAhB,EAAmBD,CAAC,EAApB,EAAwB;IAEpB,IAAIU,GAAG,GAAGR,IAAI,CAACF,CAAD,CAAd;IAEA,IAAIW,iBAAJ;IACA,IAAIC,GAAJ;;IACA,KAAKA,GAAL,IAAYF,GAAZ,EAAiB;MAEb,IAAIA,GAAG,CAACG,cAAJ,CAAmBD,GAAnB,CAAJ,EAA6B;QACzB,OAAOL,KAAK,CAACK,GAAD,CAAZ,CADyB,CACN;;QACnBD,iBAAiB,GAAGH,MAAM,CAACM,wBAAP,CAAgCJ,GAAhC,EAAqCE,GAArC,CAApB,CAFyB,CAEsC;;QAC/DJ,MAAM,CAACO,cAAP,CAAsBR,KAAtB,EAA6BK,GAA7B,EAAkCD,iBAAlC,EAHyB,CAG6B;MACzD;IACJ;EACJ;;EAED,OAAOJ,KAAP;AACH"},"metadata":{},"sourceType":"module"}