{"ast":null,"code":"import { Path } from './path.mjs';\nimport { Curve } from './curve.mjs';\nimport { Point } from './point.mjs';\nexport const bezier = {\n  // Cubic Bezier curve path through points.\n  // @deprecated\n  // @param {array} points Array of points through which the smooth line will go.\n  // @return {array} SVG Path commands as an array\n  curveThroughPoints: function (points) {\n    console.warn('deprecated');\n    return new Path(Curve.throughPoints(points)).serialize();\n  },\n  // Get open-ended Bezier Spline Control Points.\n  // @deprecated\n  // @param knots Input Knot Bezier spline points (At least two points!).\n  // @param firstControlPoints Output First Control points. Array of knots.length - 1 length.\n  // @param secondControlPoints Output Second Control points. Array of knots.length - 1 length.\n  getCurveControlPoints: function (knots) {\n    console.warn('deprecated');\n    var firstControlPoints = [];\n    var secondControlPoints = [];\n    var n = knots.length - 1;\n    var i; // Special case: Bezier curve should be a straight line.\n\n    if (n == 1) {\n      // 3P1 = 2P0 + P3\n      firstControlPoints[0] = new Point((2 * knots[0].x + knots[1].x) / 3, (2 * knots[0].y + knots[1].y) / 3); // P2 = 2P1 – P0\n\n      secondControlPoints[0] = new Point(2 * firstControlPoints[0].x - knots[0].x, 2 * firstControlPoints[0].y - knots[0].y);\n      return [firstControlPoints, secondControlPoints];\n    } // Calculate first Bezier control points.\n    // Right hand side vector.\n\n\n    var rhs = []; // Set right hand side X values.\n\n    for (i = 1; i < n - 1; i++) {\n      rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;\n    }\n\n    rhs[0] = knots[0].x + 2 * knots[1].x;\n    rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0; // Get first control points X-values.\n\n    var x = this.getFirstControlPoints(rhs); // Set right hand side Y values.\n\n    for (i = 1; i < n - 1; ++i) {\n      rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;\n    }\n\n    rhs[0] = knots[0].y + 2 * knots[1].y;\n    rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0; // Get first control points Y-values.\n\n    var y = this.getFirstControlPoints(rhs); // Fill output arrays.\n\n    for (i = 0; i < n; i++) {\n      // First control point.\n      firstControlPoints.push(new Point(x[i], y[i])); // Second control point.\n\n      if (i < n - 1) {\n        secondControlPoints.push(new Point(2 * knots[i + 1].x - x[i + 1], 2 * knots[i + 1].y - y[i + 1]));\n      } else {\n        secondControlPoints.push(new Point((knots[n].x + x[n - 1]) / 2, (knots[n].y + y[n - 1]) / 2));\n      }\n    }\n\n    return [firstControlPoints, secondControlPoints];\n  },\n  // Divide a Bezier curve into two at point defined by value 't' <0,1>.\n  // Using deCasteljau algorithm. http://math.stackexchange.com/a/317867\n  // @deprecated\n  // @param control points (start, control start, control end, end)\n  // @return a function that accepts t and returns 2 curves.\n  getCurveDivider: function (p0, p1, p2, p3) {\n    console.warn('deprecated');\n    var curve = new Curve(p0, p1, p2, p3);\n    return function divideCurve(t) {\n      var divided = curve.divide(t);\n      return [{\n        p0: divided[0].start,\n        p1: divided[0].controlPoint1,\n        p2: divided[0].controlPoint2,\n        p3: divided[0].end\n      }, {\n        p0: divided[1].start,\n        p1: divided[1].controlPoint1,\n        p2: divided[1].controlPoint2,\n        p3: divided[1].end\n      }];\n    };\n  },\n  // Solves a tridiagonal system for one of coordinates (x or y) of first Bezier control points.\n  // @deprecated\n  // @param rhs Right hand side vector.\n  // @return Solution vector.\n  getFirstControlPoints: function (rhs) {\n    console.warn('deprecated');\n    var n = rhs.length; // `x` is a solution vector.\n\n    var x = [];\n    var tmp = [];\n    var b = 2.0;\n    x[0] = rhs[0] / b; // Decomposition and forward substitution.\n\n    for (var i = 1; i < n; i++) {\n      tmp[i] = 1 / b;\n      b = (i < n - 1 ? 4.0 : 3.5) - tmp[i];\n      x[i] = (rhs[i] - x[i - 1]) / b;\n    }\n\n    for (i = 1; i < n; i++) {\n      // Backsubstitution.\n      x[n - i - 1] -= tmp[n - i] * x[n - i];\n    }\n\n    return x;\n  },\n  // Solves an inversion problem -- Given the (x, y) coordinates of a point which lies on\n  // a parametric curve x = x(t)/w(t), y = y(t)/w(t), ﬁnd the parameter value t\n  // which corresponds to that point.\n  // @deprecated\n  // @param control points (start, control start, control end, end)\n  // @return a function that accepts a point and returns t.\n  getInversionSolver: function (p0, p1, p2, p3) {\n    console.warn('deprecated');\n    var curve = new Curve(p0, p1, p2, p3);\n    return function solveInversion(p) {\n      return curve.closestPointT(p);\n    };\n  }\n};","map":{"version":3,"names":["Path","Curve","Point","bezier","curveThroughPoints","points","console","warn","throughPoints","serialize","getCurveControlPoints","knots","firstControlPoints","secondControlPoints","n","length","i","x","y","rhs","getFirstControlPoints","push","getCurveDivider","p0","p1","p2","p3","curve","divideCurve","t","divided","divide","start","controlPoint1","controlPoint2","end","tmp","b","getInversionSolver","solveInversion","p","closestPointT"],"sources":["C:/Users/Admin/dataflow-test/node_modules/jointjs/src/g/bezier.mjs"],"sourcesContent":["import { Path } from './path.mjs';\nimport { Curve } from './curve.mjs';\nimport { Point } from './point.mjs';\n\nexport const bezier = {\n\n    // Cubic Bezier curve path through points.\n    // @deprecated\n    // @param {array} points Array of points through which the smooth line will go.\n    // @return {array} SVG Path commands as an array\n    curveThroughPoints: function(points) {\n\n        console.warn('deprecated');\n\n        return new Path(Curve.throughPoints(points)).serialize();\n    },\n\n    // Get open-ended Bezier Spline Control Points.\n    // @deprecated\n    // @param knots Input Knot Bezier spline points (At least two points!).\n    // @param firstControlPoints Output First Control points. Array of knots.length - 1 length.\n    // @param secondControlPoints Output Second Control points. Array of knots.length - 1 length.\n    getCurveControlPoints: function(knots) {\n\n        console.warn('deprecated');\n\n        var firstControlPoints = [];\n        var secondControlPoints = [];\n        var n = knots.length - 1;\n        var i;\n\n        // Special case: Bezier curve should be a straight line.\n        if (n == 1) {\n            // 3P1 = 2P0 + P3\n            firstControlPoints[0] = new Point(\n                (2 * knots[0].x + knots[1].x) / 3,\n                (2 * knots[0].y + knots[1].y) / 3\n            );\n\n            // P2 = 2P1 – P0\n            secondControlPoints[0] = new Point(\n                2 * firstControlPoints[0].x - knots[0].x,\n                2 * firstControlPoints[0].y - knots[0].y\n            );\n\n            return [firstControlPoints, secondControlPoints];\n        }\n\n        // Calculate first Bezier control points.\n        // Right hand side vector.\n        var rhs = [];\n\n        // Set right hand side X values.\n        for (i = 1; i < n - 1; i++) {\n            rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;\n        }\n\n        rhs[0] = knots[0].x + 2 * knots[1].x;\n        rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0;\n\n        // Get first control points X-values.\n        var x = this.getFirstControlPoints(rhs);\n\n        // Set right hand side Y values.\n        for (i = 1; i < n - 1; ++i) {\n            rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;\n        }\n\n        rhs[0] = knots[0].y + 2 * knots[1].y;\n        rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0;\n\n        // Get first control points Y-values.\n        var y = this.getFirstControlPoints(rhs);\n\n        // Fill output arrays.\n        for (i = 0; i < n; i++) {\n            // First control point.\n            firstControlPoints.push(new Point(x[i], y[i]));\n\n            // Second control point.\n            if (i < n - 1) {\n                secondControlPoints.push(new Point(\n                    2 * knots [i + 1].x - x[i + 1],\n                    2 * knots[i + 1].y - y[i + 1]\n                ));\n\n            } else {\n                secondControlPoints.push(new Point(\n                    (knots[n].x + x[n - 1]) / 2,\n                    (knots[n].y + y[n - 1]) / 2)\n                );\n            }\n        }\n\n        return [firstControlPoints, secondControlPoints];\n    },\n\n    // Divide a Bezier curve into two at point defined by value 't' <0,1>.\n    // Using deCasteljau algorithm. http://math.stackexchange.com/a/317867\n    // @deprecated\n    // @param control points (start, control start, control end, end)\n    // @return a function that accepts t and returns 2 curves.\n    getCurveDivider: function(p0, p1, p2, p3) {\n\n        console.warn('deprecated');\n\n        var curve = new Curve(p0, p1, p2, p3);\n\n        return function divideCurve(t) {\n\n            var divided = curve.divide(t);\n\n            return [{\n                p0: divided[0].start,\n                p1: divided[0].controlPoint1,\n                p2: divided[0].controlPoint2,\n                p3: divided[0].end\n            }, {\n                p0: divided[1].start,\n                p1: divided[1].controlPoint1,\n                p2: divided[1].controlPoint2,\n                p3: divided[1].end\n            }];\n        };\n    },\n\n    // Solves a tridiagonal system for one of coordinates (x or y) of first Bezier control points.\n    // @deprecated\n    // @param rhs Right hand side vector.\n    // @return Solution vector.\n    getFirstControlPoints: function(rhs) {\n\n        console.warn('deprecated');\n\n        var n = rhs.length;\n        // `x` is a solution vector.\n        var x = [];\n        var tmp = [];\n        var b = 2.0;\n\n        x[0] = rhs[0] / b;\n\n        // Decomposition and forward substitution.\n        for (var i = 1; i < n; i++) {\n            tmp[i] = 1 / b;\n            b = (i < n - 1 ? 4.0 : 3.5) - tmp[i];\n            x[i] = (rhs[i] - x[i - 1]) / b;\n        }\n\n        for (i = 1; i < n; i++) {\n            // Backsubstitution.\n            x[n - i - 1] -= tmp[n - i] * x[n - i];\n        }\n\n        return x;\n    },\n\n    // Solves an inversion problem -- Given the (x, y) coordinates of a point which lies on\n    // a parametric curve x = x(t)/w(t), y = y(t)/w(t), ﬁnd the parameter value t\n    // which corresponds to that point.\n    // @deprecated\n    // @param control points (start, control start, control end, end)\n    // @return a function that accepts a point and returns t.\n    getInversionSolver: function(p0, p1, p2, p3) {\n\n        console.warn('deprecated');\n\n        var curve = new Curve(p0, p1, p2, p3);\n\n        return function solveInversion(p) {\n\n            return curve.closestPointT(p);\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}