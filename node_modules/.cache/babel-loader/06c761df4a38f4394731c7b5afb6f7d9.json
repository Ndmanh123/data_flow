{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport Backbone from 'backbone';\nimport * as util from '../util/index.mjs';\nimport * as g from '../g/index.mjs';\nimport { Link } from './Link.mjs';\nimport { Element } from './Element.mjs';\nimport { wrappers, wrapWith } from '../util/wrappers.mjs';\nimport { cloneCells } from '../util/index.mjs';\nconst GraphCells = Backbone.Collection.extend({\n  initialize: function (models, opt) {\n    // Set the optional namespace where all model classes are defined.\n    if (opt.cellNamespace) {\n      this.cellNamespace = opt.cellNamespace;\n    } else {\n      /* eslint-disable no-undef */\n      this.cellNamespace = typeof joint !== 'undefined' && util.has(joint, 'shapes') ? joint.shapes : null;\n      /* eslint-enable no-undef */\n    }\n\n    this.graph = opt.graph;\n  },\n  model: function (attrs, opt) {\n    var collection = opt.collection;\n    var namespace = collection.cellNamespace; // Find the model class in the namespace or use the default one.\n\n    var ModelClass = attrs.type === 'link' ? Link : util.getByPath(namespace, attrs.type, '.') || Element;\n    var cell = new ModelClass(attrs, opt); // Add a reference to the graph. It is necessary to do this here because this is the earliest place\n    // where a new model is created from a plain JS object. For other objects, see `joint.dia.Graph>>_prepareCell()`.\n\n    if (!opt.dry) {\n      cell.graph = collection.graph;\n    }\n\n    return cell;\n  },\n  // `comparator` makes it easy to sort cells based on their `z` index.\n  comparator: function (model) {\n    return model.get('z') || 0;\n  }\n});\nexport const Graph = Backbone.Model.extend({\n  initialize: function (attrs, opt) {\n    opt = opt || {}; // Passing `cellModel` function in the options object to graph allows for\n    // setting models based on attribute objects. This is especially handy\n    // when processing JSON graphs that are in a different than JointJS format.\n\n    var cells = new GraphCells([], {\n      model: opt.cellModel,\n      cellNamespace: opt.cellNamespace,\n      graph: this\n    });\n    Backbone.Model.prototype.set.call(this, 'cells', cells); // Make all the events fired in the `cells` collection available.\n    // to the outside world.\n\n    cells.on('all', this.trigger, this); // Backbone automatically doesn't trigger re-sort if models attributes are changed later when\n    // they're already in the collection. Therefore, we're triggering sort manually here.\n\n    this.on('change:z', this._sortOnChangeZ, this); // `joint.dia.Graph` keeps an internal data structure (an adjacency list)\n    // for fast graph queries. All changes that affect the structure of the graph\n    // must be reflected in the `al` object. This object provides fast answers to\n    // questions such as \"what are the neighbours of this node\" or \"what\n    // are the sibling links of this link\".\n    // Outgoing edges per node. Note that we use a hash-table for the list\n    // of outgoing edges for a faster lookup.\n    // [nodeId] -> Object [edgeId] -> true\n\n    this._out = {}; // Ingoing edges per node.\n    // [nodeId] -> Object [edgeId] -> true\n\n    this._in = {}; // `_nodes` is useful for quick lookup of all the elements in the graph, without\n    // having to go through the whole cells array.\n    // [node ID] -> true\n\n    this._nodes = {}; // `_edges` is useful for quick lookup of all the links in the graph, without\n    // having to go through the whole cells array.\n    // [edgeId] -> true\n\n    this._edges = {};\n    this._batches = {};\n    cells.on('add', this._restructureOnAdd, this);\n    cells.on('remove', this._restructureOnRemove, this);\n    cells.on('reset', this._restructureOnReset, this);\n    cells.on('change:source', this._restructureOnChangeSource, this);\n    cells.on('change:target', this._restructureOnChangeTarget, this);\n    cells.on('remove', this._removeCell, this);\n  },\n  _sortOnChangeZ: function () {\n    this.get('cells').sort();\n  },\n  _restructureOnAdd: function (cell) {\n    if (cell.isLink()) {\n      this._edges[cell.id] = true;\n      var {\n        source,\n        target\n      } = cell.attributes;\n\n      if (source.id) {\n        (this._out[source.id] || (this._out[source.id] = {}))[cell.id] = true;\n      }\n\n      if (target.id) {\n        (this._in[target.id] || (this._in[target.id] = {}))[cell.id] = true;\n      }\n    } else {\n      this._nodes[cell.id] = true;\n    }\n  },\n  _restructureOnRemove: function (cell) {\n    if (cell.isLink()) {\n      delete this._edges[cell.id];\n      var {\n        source,\n        target\n      } = cell.attributes;\n\n      if (source.id && this._out[source.id] && this._out[source.id][cell.id]) {\n        delete this._out[source.id][cell.id];\n      }\n\n      if (target.id && this._in[target.id] && this._in[target.id][cell.id]) {\n        delete this._in[target.id][cell.id];\n      }\n    } else {\n      delete this._nodes[cell.id];\n    }\n  },\n  _restructureOnReset: function (cells) {\n    // Normalize into an array of cells. The original `cells` is GraphCells Backbone collection.\n    cells = cells.models;\n    this._out = {};\n    this._in = {};\n    this._nodes = {};\n    this._edges = {};\n    cells.forEach(this._restructureOnAdd, this);\n  },\n  _restructureOnChangeSource: function (link) {\n    var prevSource = link.previous('source');\n\n    if (prevSource.id && this._out[prevSource.id]) {\n      delete this._out[prevSource.id][link.id];\n    }\n\n    var source = link.attributes.source;\n\n    if (source.id) {\n      (this._out[source.id] || (this._out[source.id] = {}))[link.id] = true;\n    }\n  },\n  _restructureOnChangeTarget: function (link) {\n    var prevTarget = link.previous('target');\n\n    if (prevTarget.id && this._in[prevTarget.id]) {\n      delete this._in[prevTarget.id][link.id];\n    }\n\n    var target = link.get('target');\n\n    if (target.id) {\n      (this._in[target.id] || (this._in[target.id] = {}))[link.id] = true;\n    }\n  },\n  // Return all outbound edges for the node. Return value is an object\n  // of the form: [edgeId] -> true\n  getOutboundEdges: function (node) {\n    return this._out && this._out[node] || {};\n  },\n  // Return all inbound edges for the node. Return value is an object\n  // of the form: [edgeId] -> true\n  getInboundEdges: function (node) {\n    return this._in && this._in[node] || {};\n  },\n  toJSON: function () {\n    // Backbone does not recursively call `toJSON()` on attributes that are themselves models/collections.\n    // It just clones the attributes. Therefore, we must call `toJSON()` on the cells collection explicitly.\n    var json = Backbone.Model.prototype.toJSON.apply(this, arguments);\n    json.cells = this.get('cells').toJSON();\n    return json;\n  },\n  fromJSON: function (json, opt) {\n    if (!json.cells) {\n      throw new Error('Graph JSON must contain cells array.');\n    }\n\n    return this.set(json, opt);\n  },\n  set: function (key, val, opt) {\n    var attrs; // Handle both `key`, value and {key: value} style arguments.\n\n    if (typeof key === 'object') {\n      attrs = key;\n      opt = val;\n    } else {\n      (attrs = {})[key] = val;\n    } // Make sure that `cells` attribute is handled separately via resetCells().\n\n\n    if (attrs.hasOwnProperty('cells')) {\n      this.resetCells(attrs.cells, opt);\n      attrs = util.omit(attrs, 'cells');\n    } // The rest of the attributes are applied via original set method.\n\n\n    return Backbone.Model.prototype.set.call(this, attrs, opt);\n  },\n  clear: function (opt) {\n    opt = util.assign({}, opt, {\n      clear: true\n    });\n    var collection = this.get('cells');\n    if (collection.length === 0) return this;\n    this.startBatch('clear', opt); // The elements come after the links.\n\n    var cells = collection.sortBy(function (cell) {\n      return cell.isLink() ? 1 : 2;\n    });\n\n    do {\n      // Remove all the cells one by one.\n      // Note that all the links are removed first, so it's\n      // safe to remove the elements without removing the connected\n      // links first.\n      cells.shift().remove(opt);\n    } while (cells.length > 0);\n\n    this.stopBatch('clear');\n    return this;\n  },\n  _prepareCell: function (cell, opt) {\n    var attrs;\n\n    if (cell instanceof Backbone.Model) {\n      attrs = cell.attributes;\n\n      if (!cell.graph && (!opt || !opt.dry)) {\n        // An element can not be member of more than one graph.\n        // A cell stops being the member of the graph after it's explicitly removed.\n        cell.graph = this;\n      }\n    } else {\n      // In case we're dealing with a plain JS object, we have to set the reference\n      // to the `graph` right after the actual model is created. This happens in the `model()` function\n      // of `joint.dia.GraphCells`.\n      attrs = cell;\n    }\n\n    if (!util.isString(attrs.type)) {\n      throw new TypeError('dia.Graph: cell type must be a string.');\n    }\n\n    return cell;\n  },\n  minZIndex: function () {\n    var firstCell = this.get('cells').first();\n    return firstCell ? firstCell.get('z') || 0 : 0;\n  },\n  maxZIndex: function () {\n    var lastCell = this.get('cells').last();\n    return lastCell ? lastCell.get('z') || 0 : 0;\n  },\n  addCell: function (cell, opt) {\n    if (Array.isArray(cell)) {\n      return this.addCells(cell, opt);\n    }\n\n    if (cell instanceof Backbone.Model) {\n      if (!cell.has('z')) {\n        cell.set('z', this.maxZIndex() + 1);\n      }\n    } else if (cell.z === undefined) {\n      cell.z = this.maxZIndex() + 1;\n    }\n\n    this.get('cells').add(this._prepareCell(cell, opt), opt || {});\n    return this;\n  },\n  addCells: function (cells, opt) {\n    if (cells.length === 0) return this;\n    cells = util.flattenDeep(cells);\n    opt.maxPosition = opt.position = cells.length - 1;\n    this.startBatch('add', opt);\n    cells.forEach(function (cell) {\n      this.addCell(cell, opt);\n      opt.position--;\n    }, this);\n    this.stopBatch('add', opt);\n    return this;\n  },\n  // When adding a lot of cells, it is much more efficient to\n  // reset the entire cells collection in one go.\n  // Useful for bulk operations and optimizations.\n  resetCells: function (cells, opt) {\n    var preparedCells = util.toArray(cells).map(function (cell) {\n      return this._prepareCell(cell, opt);\n    }, this);\n    this.get('cells').reset(preparedCells, opt);\n    return this;\n  },\n  removeCells: function (cells, opt) {\n    if (cells.length) {\n      this.startBatch('remove');\n      util.invoke(cells, 'remove', opt);\n      this.stopBatch('remove');\n    }\n\n    return this;\n  },\n  _removeCell: function (cell, collection, options) {\n    options = options || {};\n\n    if (!options.clear) {\n      // Applications might provide a `disconnectLinks` option set to `true` in order to\n      // disconnect links when a cell is removed rather then removing them. The default\n      // is to remove all the associated links.\n      if (options.disconnectLinks) {\n        this.disconnectLinks(cell, options);\n      } else {\n        this.removeLinks(cell, options);\n      }\n    } // Silently remove the cell from the cells collection. Silently, because\n    // `joint.dia.Cell.prototype.remove` already triggers the `remove` event which is\n    // then propagated to the graph model. If we didn't remove the cell silently, two `remove` events\n    // would be triggered on the graph model.\n\n\n    this.get('cells').remove(cell, {\n      silent: true\n    });\n\n    if (cell.graph === this) {\n      // Remove the element graph reference only if the cell is the member of this graph.\n      cell.graph = null;\n    }\n  },\n  // Get a cell by `id`.\n  getCell: function (id) {\n    return this.get('cells').get(id);\n  },\n  getCells: function () {\n    return this.get('cells').toArray();\n  },\n  getElements: function () {\n    return this.get('cells').filter(cell => cell.isElement());\n  },\n  getLinks: function () {\n    return this.get('cells').filter(cell => cell.isLink());\n  },\n  getFirstCell: function () {\n    return this.get('cells').first();\n  },\n  getLastCell: function () {\n    return this.get('cells').last();\n  },\n  // Get all inbound and outbound links connected to the cell `model`.\n  getConnectedLinks: function (model, opt) {\n    opt = opt || {};\n    var indirect = opt.indirect;\n    var inbound = opt.inbound;\n    var outbound = opt.outbound;\n\n    if (inbound === undefined && outbound === undefined) {\n      inbound = outbound = true;\n    } // the final array of connected link models\n\n\n    var links = []; // a hash table of connected edges of the form: [edgeId] -> true\n    // used for quick lookups to check if we already added a link\n\n    var edges = {};\n\n    if (outbound) {\n      addOutbounds(this, model);\n    }\n\n    if (inbound) {\n      addInbounds(this, model);\n    }\n\n    function addOutbounds(graph, model) {\n      util.forIn(graph.getOutboundEdges(model.id), function (_, edge) {\n        // skip links that were already added\n        // (those must be self-loop links)\n        // (because they are inbound and outbound edges of the same two elements)\n        if (edges[edge]) return;\n        var link = graph.getCell(edge);\n        links.push(link);\n        edges[edge] = true;\n\n        if (indirect) {\n          if (inbound) addInbounds(graph, link);\n          if (outbound) addOutbounds(graph, link);\n        }\n      }.bind(graph));\n\n      if (indirect && model.isLink()) {\n        var outCell = model.getTargetCell();\n\n        if (outCell && outCell.isLink()) {\n          if (!edges[outCell.id]) {\n            links.push(outCell);\n            addOutbounds(graph, outCell);\n          }\n        }\n      }\n    }\n\n    function addInbounds(graph, model) {\n      util.forIn(graph.getInboundEdges(model.id), function (_, edge) {\n        // skip links that were already added\n        // (those must be self-loop links)\n        // (because they are inbound and outbound edges of the same two elements)\n        if (edges[edge]) return;\n        var link = graph.getCell(edge);\n        links.push(link);\n        edges[edge] = true;\n\n        if (indirect) {\n          if (inbound) addInbounds(graph, link);\n          if (outbound) addOutbounds(graph, link);\n        }\n      }.bind(graph));\n\n      if (indirect && model.isLink()) {\n        var inCell = model.getSourceCell();\n\n        if (inCell && inCell.isLink()) {\n          if (!edges[inCell.id]) {\n            links.push(inCell);\n            addInbounds(graph, inCell);\n          }\n        }\n      }\n    } // if `deep` option is `true`, check also all the links that are connected to any of the descendant cells\n\n\n    if (opt.deep) {\n      var embeddedCells = model.getEmbeddedCells({\n        deep: true\n      }); // in the first round, we collect all the embedded elements\n\n      var embeddedElements = {};\n      embeddedCells.forEach(function (cell) {\n        if (cell.isElement()) {\n          embeddedElements[cell.id] = true;\n        }\n      });\n      embeddedCells.forEach(function (cell) {\n        if (cell.isLink()) return;\n\n        if (outbound) {\n          util.forIn(this.getOutboundEdges(cell.id), function (exists, edge) {\n            if (!edges[edge]) {\n              var edgeCell = this.getCell(edge);\n              var {\n                source,\n                target\n              } = edgeCell.attributes;\n              var sourceId = source.id;\n              var targetId = target.id; // if `includeEnclosed` option is falsy, skip enclosed links\n\n              if (!opt.includeEnclosed && sourceId && embeddedElements[sourceId] && targetId && embeddedElements[targetId]) {\n                return;\n              }\n\n              links.push(this.getCell(edge));\n              edges[edge] = true;\n            }\n          }.bind(this));\n        }\n\n        if (inbound) {\n          util.forIn(this.getInboundEdges(cell.id), function (exists, edge) {\n            if (!edges[edge]) {\n              var edgeCell = this.getCell(edge);\n              var {\n                source,\n                target\n              } = edgeCell.attributes;\n              var sourceId = source.id;\n              var targetId = target.id; // if `includeEnclosed` option is falsy, skip enclosed links\n\n              if (!opt.includeEnclosed && sourceId && embeddedElements[sourceId] && targetId && embeddedElements[targetId]) {\n                return;\n              }\n\n              links.push(this.getCell(edge));\n              edges[edge] = true;\n            }\n          }.bind(this));\n        }\n      }, this);\n    }\n\n    return links;\n  },\n  getNeighbors: function (model, opt) {\n    opt || (opt = {});\n    var inbound = opt.inbound;\n    var outbound = opt.outbound;\n\n    if (inbound === undefined && outbound === undefined) {\n      inbound = outbound = true;\n    }\n\n    var neighbors = this.getConnectedLinks(model, opt).reduce(function (res, link) {\n      var {\n        source,\n        target\n      } = link.attributes;\n      var loop = link.hasLoop(opt); // Discard if it is a point, or if the neighbor was already added.\n\n      if (inbound && util.has(source, 'id') && !res[source.id]) {\n        var sourceElement = this.getCell(source.id);\n\n        if (sourceElement.isElement()) {\n          if (loop || sourceElement && sourceElement !== model && (!opt.deep || !sourceElement.isEmbeddedIn(model))) {\n            res[source.id] = sourceElement;\n          }\n        }\n      } // Discard if it is a point, or if the neighbor was already added.\n\n\n      if (outbound && util.has(target, 'id') && !res[target.id]) {\n        var targetElement = this.getCell(target.id);\n\n        if (targetElement.isElement()) {\n          if (loop || targetElement && targetElement !== model && (!opt.deep || !targetElement.isEmbeddedIn(model))) {\n            res[target.id] = targetElement;\n          }\n        }\n      }\n\n      return res;\n    }.bind(this), {});\n\n    if (model.isLink()) {\n      if (inbound) {\n        var sourceCell = model.getSourceCell();\n\n        if (sourceCell && sourceCell.isElement() && !neighbors[sourceCell.id]) {\n          neighbors[sourceCell.id] = sourceCell;\n        }\n      }\n\n      if (outbound) {\n        var targetCell = model.getTargetCell();\n\n        if (targetCell && targetCell.isElement() && !neighbors[targetCell.id]) {\n          neighbors[targetCell.id] = targetCell;\n        }\n      }\n    }\n\n    return util.toArray(neighbors);\n  },\n  getCommonAncestor: function\n    /* cells */\n  () {\n    var cellsAncestors = Array.from(arguments).map(function (cell) {\n      var ancestors = [];\n      var parentId = cell.get('parent');\n\n      while (parentId) {\n        ancestors.push(parentId);\n        parentId = this.getCell(parentId).get('parent');\n      }\n\n      return ancestors;\n    }, this);\n    cellsAncestors = cellsAncestors.sort(function (a, b) {\n      return a.length - b.length;\n    });\n    var commonAncestor = util.toArray(cellsAncestors.shift()).find(function (ancestor) {\n      return cellsAncestors.every(function (cellAncestors) {\n        return cellAncestors.includes(ancestor);\n      });\n    });\n    return this.getCell(commonAncestor);\n  },\n  // Find the whole branch starting at `element`.\n  // If `opt.deep` is `true`, take into account embedded elements too.\n  // If `opt.breadthFirst` is `true`, use the Breadth-first search algorithm, otherwise use Depth-first search.\n  getSuccessors: function (element, opt) {\n    opt = opt || {};\n    var res = []; // Modify the options so that it includes the `outbound` neighbors only. In other words, search forwards.\n\n    this.search(element, function (el) {\n      if (el !== element) {\n        res.push(el);\n      }\n    }, util.assign({}, opt, {\n      outbound: true\n    }));\n    return res;\n  },\n  cloneCells: cloneCells,\n  // Clone the whole subgraph (including all the connected links whose source/target is in the subgraph).\n  // If `opt.deep` is `true`, also take into account all the embedded cells of all the subgraph cells.\n  // Return a map of the form: [original cell ID] -> [clone].\n  cloneSubgraph: function (cells, opt) {\n    var subgraph = this.getSubgraph(cells, opt);\n    return this.cloneCells(subgraph);\n  },\n  // Return `cells` and all the connected links that connect cells in the `cells` array.\n  // If `opt.deep` is `true`, return all the cells including all their embedded cells\n  // and all the links that connect any of the returned cells.\n  // For example, for a single shallow element, the result is that very same element.\n  // For two elements connected with a link: `A --- L ---> B`, the result for\n  // `getSubgraph([A, B])` is `[A, L, B]`. The same goes for `getSubgraph([L])`, the result is again `[A, L, B]`.\n  getSubgraph: function (cells, opt) {\n    opt = opt || {};\n    var subgraph = []; // `cellMap` is used for a quick lookup of existence of a cell in the `cells` array.\n\n    var cellMap = {};\n    var elements = [];\n    var links = [];\n    util.toArray(cells).forEach(function (cell) {\n      if (!cellMap[cell.id]) {\n        subgraph.push(cell);\n        cellMap[cell.id] = cell;\n\n        if (cell.isLink()) {\n          links.push(cell);\n        } else {\n          elements.push(cell);\n        }\n      }\n\n      if (opt.deep) {\n        var embeds = cell.getEmbeddedCells({\n          deep: true\n        });\n        embeds.forEach(function (embed) {\n          if (!cellMap[embed.id]) {\n            subgraph.push(embed);\n            cellMap[embed.id] = embed;\n\n            if (embed.isLink()) {\n              links.push(embed);\n            } else {\n              elements.push(embed);\n            }\n          }\n        });\n      }\n    });\n    links.forEach(function (link) {\n      // For links, return their source & target (if they are elements - not points).\n      var {\n        source,\n        target\n      } = link.attributes;\n\n      if (source.id && !cellMap[source.id]) {\n        var sourceElement = this.getCell(source.id);\n        subgraph.push(sourceElement);\n        cellMap[sourceElement.id] = sourceElement;\n        elements.push(sourceElement);\n      }\n\n      if (target.id && !cellMap[target.id]) {\n        var targetElement = this.getCell(target.id);\n        subgraph.push(this.getCell(target.id));\n        cellMap[targetElement.id] = targetElement;\n        elements.push(targetElement);\n      }\n    }, this);\n    elements.forEach(function (element) {\n      // For elements, include their connected links if their source/target is in the subgraph;\n      var links = this.getConnectedLinks(element, opt);\n      links.forEach(function (link) {\n        var {\n          source,\n          target\n        } = link.attributes;\n\n        if (!cellMap[link.id] && source.id && cellMap[source.id] && target.id && cellMap[target.id]) {\n          subgraph.push(link);\n          cellMap[link.id] = link;\n        }\n      });\n    }, this);\n    return subgraph;\n  },\n  // Find all the predecessors of `element`. This is a reverse operation of `getSuccessors()`.\n  // If `opt.deep` is `true`, take into account embedded elements too.\n  // If `opt.breadthFirst` is `true`, use the Breadth-first search algorithm, otherwise use Depth-first search.\n  getPredecessors: function (element, opt) {\n    opt = opt || {};\n    var res = []; // Modify the options so that it includes the `inbound` neighbors only. In other words, search backwards.\n\n    this.search(element, function (el) {\n      if (el !== element) {\n        res.push(el);\n      }\n    }, util.assign({}, opt, {\n      inbound: true\n    }));\n    return res;\n  },\n  // Perform search on the graph.\n  // If `opt.breadthFirst` is `true`, use the Breadth-first Search algorithm, otherwise use Depth-first search.\n  // By setting `opt.inbound` to `true`, you can reverse the direction of the search.\n  // If `opt.deep` is `true`, take into account embedded elements too.\n  // `iteratee` is a function of the form `function(element) {}`.\n  // If `iteratee` explicitly returns `false`, the searching stops.\n  search: function (element, iteratee, opt) {\n    opt = opt || {};\n\n    if (opt.breadthFirst) {\n      this.bfs(element, iteratee, opt);\n    } else {\n      this.dfs(element, iteratee, opt);\n    }\n  },\n  // Breadth-first search.\n  // If `opt.deep` is `true`, take into account embedded elements too.\n  // If `opt.inbound` is `true`, reverse the search direction (it's like reversing all the link directions).\n  // `iteratee` is a function of the form `function(element, distance) {}`.\n  // where `element` is the currently visited element and `distance` is the distance of that element\n  // from the root `element` passed the `bfs()`, i.e. the element we started the search from.\n  // Note that the `distance` is not the shortest or longest distance, it is simply the number of levels\n  // crossed till we visited the `element` for the first time. It is especially useful for tree graphs.\n  // If `iteratee` explicitly returns `false`, the searching stops.\n  bfs: function (element, iteratee, opt = {}) {\n    const visited = {};\n    const distance = {};\n    const queue = [];\n    queue.push(element);\n    distance[element.id] = 0;\n\n    while (queue.length > 0) {\n      var next = queue.shift();\n      if (visited[next.id]) continue;\n      visited[next.id] = true;\n      if (iteratee.call(this, next, distance[next.id]) === false) continue;\n      const neighbors = this.getNeighbors(next, opt);\n\n      for (let i = 0, n = neighbors.length; i < n; i++) {\n        const neighbor = neighbors[i];\n        distance[neighbor.id] = distance[next.id] + 1;\n        queue.push(neighbor);\n      }\n    }\n  },\n  // Depth-first search.\n  // If `opt.deep` is `true`, take into account embedded elements too.\n  // If `opt.inbound` is `true`, reverse the search direction (it's like reversing all the link directions).\n  // `iteratee` is a function of the form `function(element, distance) {}`.\n  // If `iteratee` explicitly returns `false`, the search stops.\n  dfs: function (element, iteratee, opt = {}) {\n    const visited = {};\n    const distance = {};\n    const queue = [];\n    queue.push(element);\n    distance[element.id] = 0;\n\n    while (queue.length > 0) {\n      const next = queue.pop();\n      if (visited[next.id]) continue;\n      visited[next.id] = true;\n      if (iteratee.call(this, next, distance[next.id]) === false) continue;\n      const neighbors = this.getNeighbors(next, opt);\n      const lastIndex = queue.length;\n\n      for (let i = 0, n = neighbors.length; i < n; i++) {\n        const neighbor = neighbors[i];\n        distance[neighbor.id] = distance[next.id] + 1;\n        queue.splice(lastIndex, 0, neighbor);\n      }\n    }\n  },\n  // Get all the roots of the graph. Time complexity: O(|V|).\n  getSources: function () {\n    var sources = [];\n    util.forIn(this._nodes, function (exists, node) {\n      if (!this._in[node] || util.isEmpty(this._in[node])) {\n        sources.push(this.getCell(node));\n      }\n    }.bind(this));\n    return sources;\n  },\n  // Get all the leafs of the graph. Time complexity: O(|V|).\n  getSinks: function () {\n    var sinks = [];\n    util.forIn(this._nodes, function (exists, node) {\n      if (!this._out[node] || util.isEmpty(this._out[node])) {\n        sinks.push(this.getCell(node));\n      }\n    }.bind(this));\n    return sinks;\n  },\n  // Return `true` if `element` is a root. Time complexity: O(1).\n  isSource: function (element) {\n    return !this._in[element.id] || util.isEmpty(this._in[element.id]);\n  },\n  // Return `true` if `element` is a leaf. Time complexity: O(1).\n  isSink: function (element) {\n    return !this._out[element.id] || util.isEmpty(this._out[element.id]);\n  },\n  // Return `true` is `elementB` is a successor of `elementA`. Return `false` otherwise.\n  isSuccessor: function (elementA, elementB) {\n    var isSuccessor = false;\n    this.search(elementA, function (element) {\n      if (element === elementB && element !== elementA) {\n        isSuccessor = true;\n        return false;\n      }\n    }, {\n      outbound: true\n    });\n    return isSuccessor;\n  },\n  // Return `true` is `elementB` is a predecessor of `elementA`. Return `false` otherwise.\n  isPredecessor: function (elementA, elementB) {\n    var isPredecessor = false;\n    this.search(elementA, function (element) {\n      if (element === elementB && element !== elementA) {\n        isPredecessor = true;\n        return false;\n      }\n    }, {\n      inbound: true\n    });\n    return isPredecessor;\n  },\n  // Return `true` is `elementB` is a neighbor of `elementA`. Return `false` otherwise.\n  // `opt.deep` controls whether to take into account embedded elements as well. See `getNeighbors()`\n  // for more details.\n  // If `opt.outbound` is set to `true`, return `true` only if `elementB` is a successor neighbor.\n  // Similarly, if `opt.inbound` is set to `true`, return `true` only if `elementB` is a predecessor neighbor.\n  isNeighbor: function (elementA, elementB, opt) {\n    opt = opt || {};\n    var inbound = opt.inbound;\n    var outbound = opt.outbound;\n\n    if (inbound === undefined && outbound === undefined) {\n      inbound = outbound = true;\n    }\n\n    var isNeighbor = false;\n    this.getConnectedLinks(elementA, opt).forEach(function (link) {\n      var {\n        source,\n        target\n      } = link.attributes; // Discard if it is a point.\n\n      if (inbound && util.has(source, 'id') && source.id === elementB.id) {\n        isNeighbor = true;\n        return false;\n      } // Discard if it is a point, or if the neighbor was already added.\n\n\n      if (outbound && util.has(target, 'id') && target.id === elementB.id) {\n        isNeighbor = true;\n        return false;\n      }\n    });\n    return isNeighbor;\n  },\n  // Disconnect links connected to the cell `model`.\n  disconnectLinks: function (model, opt) {\n    this.getConnectedLinks(model).forEach(function (link) {\n      link.set(link.attributes.source.id === model.id ? 'source' : 'target', {\n        x: 0,\n        y: 0\n      }, opt);\n    });\n  },\n  // Remove links connected to the cell `model` completely.\n  removeLinks: function (model, opt) {\n    util.invoke(this.getConnectedLinks(model), 'remove', opt);\n  },\n  // Find all elements at given point\n  findModelsFromPoint: function (p) {\n    return this.getElements().filter(el => el.getBBox({\n      rotate: true\n    }).containsPoint(p));\n  },\n  // Find all elements in given area\n  findModelsInArea: function (rect, opt = {}) {\n    const r = new g.Rect(rect);\n    const {\n      strict = false\n    } = opt;\n    const method = strict ? 'containsRect' : 'intersect';\n    return this.getElements().filter(el => r[method](el.getBBox({\n      rotate: true\n    })));\n  },\n  // Find all elements under the given element.\n  findModelsUnderElement: function (element, opt = {}) {\n    const {\n      searchBy = 'bbox'\n    } = opt;\n    const bbox = element.getBBox().rotateAroundCenter(element.angle());\n    const elements = searchBy === 'bbox' ? this.findModelsInArea(bbox) : this.findModelsFromPoint(bbox[searchBy]()); // don't account element itself or any of its descendants\n\n    return elements.filter(el => element.id !== el.id && !el.isEmbeddedIn(element));\n  },\n  // Return bounding box of all elements.\n  getBBox: function () {\n    return this.getCellsBBox(this.getCells());\n  },\n  // Return the bounding box of all cells in array provided.\n  getCellsBBox: function (cells, opt = {}) {\n    const {\n      rotate = true\n    } = opt;\n    return util.toArray(cells).reduce(function (memo, cell) {\n      const rect = cell.getBBox({\n        rotate\n      });\n      if (!rect) return memo;\n\n      if (memo) {\n        return memo.union(rect);\n      }\n\n      return rect;\n    }, null);\n  },\n  translate: function (dx, dy, opt) {\n    // Don't translate cells that are embedded in any other cell.\n    var cells = this.getCells().filter(function (cell) {\n      return !cell.isEmbedded();\n    });\n    util.invoke(cells, 'translate', dx, dy, opt);\n    return this;\n  },\n  resize: function (width, height, opt) {\n    return this.resizeCells(width, height, this.getCells(), opt);\n  },\n  resizeCells: function (width, height, cells, opt) {\n    // `getBBox` method returns `null` if no elements provided.\n    // i.e. cells can be an array of links\n    var bbox = this.getCellsBBox(cells);\n\n    if (bbox) {\n      var sx = Math.max(width / bbox.width, 0);\n      var sy = Math.max(height / bbox.height, 0);\n      util.invoke(cells, 'scale', sx, sy, bbox.origin(), opt);\n    }\n\n    return this;\n  },\n  startBatch: function (name, data) {\n    data = data || {};\n    this._batches[name] = (this._batches[name] || 0) + 1;\n    return this.trigger('batch:start', util.assign({}, data, {\n      batchName: name\n    }));\n  },\n  stopBatch: function (name, data) {\n    data = data || {};\n    this._batches[name] = (this._batches[name] || 0) - 1;\n    return this.trigger('batch:stop', util.assign({}, data, {\n      batchName: name\n    }));\n  },\n  hasActiveBatch: function (name) {\n    const batches = this._batches;\n    let names;\n\n    if (arguments.length === 0) {\n      names = Object.keys(batches);\n    } else if (Array.isArray(name)) {\n      names = name;\n    } else {\n      names = [name];\n    }\n\n    return names.some(batch => batches[batch] > 0);\n  }\n}, {\n  validations: {\n    multiLinks: function (graph, link) {\n      // Do not allow multiple links to have the same source and target.\n      var {\n        source,\n        target\n      } = link.attributes;\n\n      if (source.id && target.id) {\n        var sourceModel = link.getSourceCell();\n\n        if (sourceModel) {\n          var connectedLinks = graph.getConnectedLinks(sourceModel, {\n            outbound: true\n          });\n          var sameLinks = connectedLinks.filter(function (_link) {\n            var {\n              source: _source,\n              target: _target\n            } = _link.attributes;\n            return _source && _source.id === source.id && (!_source.port || _source.port === source.port) && _target && _target.id === target.id && (!_target.port || _target.port === target.port);\n          });\n\n          if (sameLinks.length > 1) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    },\n    linkPinning: function (_graph, link) {\n      var {\n        source,\n        target\n      } = link.attributes;\n      return source.id && target.id;\n    }\n  }\n});\nwrapWith(Graph.prototype, ['resetCells', 'addCells', 'removeCells'], wrappers.cells);","map":{"version":3,"names":["Backbone","util","g","Link","Element","wrappers","wrapWith","cloneCells","GraphCells","Collection","extend","initialize","models","opt","cellNamespace","joint","has","shapes","graph","model","attrs","collection","namespace","ModelClass","type","getByPath","cell","dry","comparator","get","Graph","Model","cells","cellModel","prototype","set","call","on","trigger","_sortOnChangeZ","_out","_in","_nodes","_edges","_batches","_restructureOnAdd","_restructureOnRemove","_restructureOnReset","_restructureOnChangeSource","_restructureOnChangeTarget","_removeCell","sort","isLink","id","source","target","attributes","forEach","link","prevSource","previous","prevTarget","getOutboundEdges","node","getInboundEdges","toJSON","json","apply","arguments","fromJSON","Error","key","val","hasOwnProperty","resetCells","omit","clear","assign","length","startBatch","sortBy","shift","remove","stopBatch","_prepareCell","isString","TypeError","minZIndex","firstCell","first","maxZIndex","lastCell","last","addCell","Array","isArray","addCells","z","undefined","add","flattenDeep","maxPosition","position","preparedCells","toArray","map","reset","removeCells","invoke","options","disconnectLinks","removeLinks","silent","getCell","getCells","getElements","filter","isElement","getLinks","getFirstCell","getLastCell","getConnectedLinks","indirect","inbound","outbound","links","edges","addOutbounds","addInbounds","forIn","_","edge","push","bind","outCell","getTargetCell","inCell","getSourceCell","deep","embeddedCells","getEmbeddedCells","embeddedElements","exists","edgeCell","sourceId","targetId","includeEnclosed","getNeighbors","neighbors","reduce","res","loop","hasLoop","sourceElement","isEmbeddedIn","targetElement","sourceCell","targetCell","getCommonAncestor","cellsAncestors","from","ancestors","parentId","a","b","commonAncestor","find","ancestor","every","cellAncestors","includes","getSuccessors","element","search","el","cloneSubgraph","subgraph","getSubgraph","cellMap","elements","embeds","embed","getPredecessors","iteratee","breadthFirst","bfs","dfs","visited","distance","queue","next","i","n","neighbor","pop","lastIndex","splice","getSources","sources","isEmpty","getSinks","sinks","isSource","isSink","isSuccessor","elementA","elementB","isPredecessor","isNeighbor","x","y","findModelsFromPoint","p","getBBox","rotate","containsPoint","findModelsInArea","rect","r","Rect","strict","method","findModelsUnderElement","searchBy","bbox","rotateAroundCenter","angle","getCellsBBox","memo","union","translate","dx","dy","isEmbedded","resize","width","height","resizeCells","sx","Math","max","sy","origin","name","data","batchName","hasActiveBatch","batches","names","Object","keys","some","batch","validations","multiLinks","sourceModel","connectedLinks","sameLinks","_link","_source","_target","port","linkPinning","_graph"],"sources":["C:/Users/Admin/dataflow-test/node_modules/jointjs/src/dia/Graph.mjs"],"sourcesContent":["import Backbone from 'backbone';\nimport * as util from '../util/index.mjs';\nimport * as g from '../g/index.mjs';\n\nimport { Link } from './Link.mjs';\nimport { Element } from './Element.mjs';\nimport { wrappers, wrapWith } from '../util/wrappers.mjs';\nimport { cloneCells } from '../util/index.mjs';\n\nconst GraphCells = Backbone.Collection.extend({\n\n    initialize: function(models, opt) {\n\n        // Set the optional namespace where all model classes are defined.\n        if (opt.cellNamespace) {\n            this.cellNamespace = opt.cellNamespace;\n        } else {\n            /* eslint-disable no-undef */\n            this.cellNamespace = typeof joint !== 'undefined' && util.has(joint, 'shapes') ? joint.shapes : null;\n            /* eslint-enable no-undef */\n        }\n\n\n        this.graph = opt.graph;\n    },\n\n    model: function(attrs, opt) {\n\n        var collection = opt.collection;\n        var namespace = collection.cellNamespace;\n\n        // Find the model class in the namespace or use the default one.\n        var ModelClass = (attrs.type === 'link')\n            ? Link\n            : util.getByPath(namespace, attrs.type, '.') || Element;\n\n        var cell = new ModelClass(attrs, opt);\n        // Add a reference to the graph. It is necessary to do this here because this is the earliest place\n        // where a new model is created from a plain JS object. For other objects, see `joint.dia.Graph>>_prepareCell()`.\n        if (!opt.dry) {\n            cell.graph = collection.graph;\n        }\n\n        return cell;\n    },\n\n    // `comparator` makes it easy to sort cells based on their `z` index.\n    comparator: function(model) {\n\n        return model.get('z') || 0;\n    }\n});\n\n\nexport const Graph = Backbone.Model.extend({\n\n    initialize: function(attrs, opt) {\n\n        opt = opt || {};\n\n        // Passing `cellModel` function in the options object to graph allows for\n        // setting models based on attribute objects. This is especially handy\n        // when processing JSON graphs that are in a different than JointJS format.\n        var cells = new GraphCells([], {\n            model: opt.cellModel,\n            cellNamespace: opt.cellNamespace,\n            graph: this\n        });\n        Backbone.Model.prototype.set.call(this, 'cells', cells);\n\n        // Make all the events fired in the `cells` collection available.\n        // to the outside world.\n        cells.on('all', this.trigger, this);\n\n        // Backbone automatically doesn't trigger re-sort if models attributes are changed later when\n        // they're already in the collection. Therefore, we're triggering sort manually here.\n        this.on('change:z', this._sortOnChangeZ, this);\n\n        // `joint.dia.Graph` keeps an internal data structure (an adjacency list)\n        // for fast graph queries. All changes that affect the structure of the graph\n        // must be reflected in the `al` object. This object provides fast answers to\n        // questions such as \"what are the neighbours of this node\" or \"what\n        // are the sibling links of this link\".\n\n        // Outgoing edges per node. Note that we use a hash-table for the list\n        // of outgoing edges for a faster lookup.\n        // [nodeId] -> Object [edgeId] -> true\n        this._out = {};\n        // Ingoing edges per node.\n        // [nodeId] -> Object [edgeId] -> true\n        this._in = {};\n        // `_nodes` is useful for quick lookup of all the elements in the graph, without\n        // having to go through the whole cells array.\n        // [node ID] -> true\n        this._nodes = {};\n        // `_edges` is useful for quick lookup of all the links in the graph, without\n        // having to go through the whole cells array.\n        // [edgeId] -> true\n        this._edges = {};\n\n        this._batches = {};\n\n        cells.on('add', this._restructureOnAdd, this);\n        cells.on('remove', this._restructureOnRemove, this);\n        cells.on('reset', this._restructureOnReset, this);\n        cells.on('change:source', this._restructureOnChangeSource, this);\n        cells.on('change:target', this._restructureOnChangeTarget, this);\n        cells.on('remove', this._removeCell, this);\n    },\n\n    _sortOnChangeZ: function() {\n\n        this.get('cells').sort();\n    },\n\n    _restructureOnAdd: function(cell) {\n\n        if (cell.isLink()) {\n            this._edges[cell.id] = true;\n            var { source, target } = cell.attributes;\n            if (source.id) {\n                (this._out[source.id] || (this._out[source.id] = {}))[cell.id] = true;\n            }\n            if (target.id) {\n                (this._in[target.id] || (this._in[target.id] = {}))[cell.id] = true;\n            }\n        } else {\n            this._nodes[cell.id] = true;\n        }\n    },\n\n    _restructureOnRemove: function(cell) {\n\n        if (cell.isLink()) {\n            delete this._edges[cell.id];\n            var { source, target } = cell.attributes;\n            if (source.id && this._out[source.id] && this._out[source.id][cell.id]) {\n                delete this._out[source.id][cell.id];\n            }\n            if (target.id && this._in[target.id] && this._in[target.id][cell.id]) {\n                delete this._in[target.id][cell.id];\n            }\n        } else {\n            delete this._nodes[cell.id];\n        }\n    },\n\n    _restructureOnReset: function(cells) {\n\n        // Normalize into an array of cells. The original `cells` is GraphCells Backbone collection.\n        cells = cells.models;\n\n        this._out = {};\n        this._in = {};\n        this._nodes = {};\n        this._edges = {};\n\n        cells.forEach(this._restructureOnAdd, this);\n    },\n\n    _restructureOnChangeSource: function(link) {\n\n        var prevSource = link.previous('source');\n        if (prevSource.id && this._out[prevSource.id]) {\n            delete this._out[prevSource.id][link.id];\n        }\n        var source = link.attributes.source;\n        if (source.id) {\n            (this._out[source.id] || (this._out[source.id] = {}))[link.id] = true;\n        }\n    },\n\n    _restructureOnChangeTarget: function(link) {\n\n        var prevTarget = link.previous('target');\n        if (prevTarget.id && this._in[prevTarget.id]) {\n            delete this._in[prevTarget.id][link.id];\n        }\n        var target = link.get('target');\n        if (target.id) {\n            (this._in[target.id] || (this._in[target.id] = {}))[link.id] = true;\n        }\n    },\n\n    // Return all outbound edges for the node. Return value is an object\n    // of the form: [edgeId] -> true\n    getOutboundEdges: function(node) {\n\n        return (this._out && this._out[node]) || {};\n    },\n\n    // Return all inbound edges for the node. Return value is an object\n    // of the form: [edgeId] -> true\n    getInboundEdges: function(node) {\n\n        return (this._in && this._in[node]) || {};\n    },\n\n    toJSON: function() {\n\n        // Backbone does not recursively call `toJSON()` on attributes that are themselves models/collections.\n        // It just clones the attributes. Therefore, we must call `toJSON()` on the cells collection explicitly.\n        var json = Backbone.Model.prototype.toJSON.apply(this, arguments);\n        json.cells = this.get('cells').toJSON();\n        return json;\n    },\n\n    fromJSON: function(json, opt) {\n\n        if (!json.cells) {\n\n            throw new Error('Graph JSON must contain cells array.');\n        }\n\n        return this.set(json, opt);\n    },\n\n    set: function(key, val, opt) {\n\n        var attrs;\n\n        // Handle both `key`, value and {key: value} style arguments.\n        if (typeof key === 'object') {\n            attrs = key;\n            opt = val;\n        } else {\n            (attrs = {})[key] = val;\n        }\n\n        // Make sure that `cells` attribute is handled separately via resetCells().\n        if (attrs.hasOwnProperty('cells')) {\n            this.resetCells(attrs.cells, opt);\n            attrs = util.omit(attrs, 'cells');\n        }\n\n        // The rest of the attributes are applied via original set method.\n        return Backbone.Model.prototype.set.call(this, attrs, opt);\n    },\n\n    clear: function(opt) {\n\n        opt = util.assign({}, opt, { clear: true });\n\n        var collection = this.get('cells');\n\n        if (collection.length === 0) return this;\n\n        this.startBatch('clear', opt);\n\n        // The elements come after the links.\n        var cells = collection.sortBy(function(cell) {\n            return cell.isLink() ? 1 : 2;\n        });\n\n        do {\n\n            // Remove all the cells one by one.\n            // Note that all the links are removed first, so it's\n            // safe to remove the elements without removing the connected\n            // links first.\n            cells.shift().remove(opt);\n\n        } while (cells.length > 0);\n\n        this.stopBatch('clear');\n\n        return this;\n    },\n\n    _prepareCell: function(cell, opt) {\n\n        var attrs;\n        if (cell instanceof Backbone.Model) {\n            attrs = cell.attributes;\n            if (!cell.graph && (!opt || !opt.dry)) {\n                // An element can not be member of more than one graph.\n                // A cell stops being the member of the graph after it's explicitly removed.\n                cell.graph = this;\n            }\n        } else {\n            // In case we're dealing with a plain JS object, we have to set the reference\n            // to the `graph` right after the actual model is created. This happens in the `model()` function\n            // of `joint.dia.GraphCells`.\n            attrs = cell;\n        }\n\n        if (!util.isString(attrs.type)) {\n            throw new TypeError('dia.Graph: cell type must be a string.');\n        }\n\n        return cell;\n    },\n\n    minZIndex: function() {\n\n        var firstCell = this.get('cells').first();\n        return firstCell ? (firstCell.get('z') || 0) : 0;\n    },\n\n    maxZIndex: function() {\n\n        var lastCell = this.get('cells').last();\n        return lastCell ? (lastCell.get('z') || 0) : 0;\n    },\n\n    addCell: function(cell, opt) {\n\n        if (Array.isArray(cell)) {\n\n            return this.addCells(cell, opt);\n        }\n\n        if (cell instanceof Backbone.Model) {\n\n            if (!cell.has('z')) {\n                cell.set('z', this.maxZIndex() + 1);\n            }\n\n        } else if (cell.z === undefined) {\n\n            cell.z = this.maxZIndex() + 1;\n        }\n\n        this.get('cells').add(this._prepareCell(cell, opt), opt || {});\n\n        return this;\n    },\n\n    addCells: function(cells, opt) {\n\n        if (cells.length === 0) return this;\n\n        cells = util.flattenDeep(cells);\n        opt.maxPosition = opt.position = cells.length - 1;\n\n        this.startBatch('add', opt);\n        cells.forEach(function(cell) {\n            this.addCell(cell, opt);\n            opt.position--;\n        }, this);\n        this.stopBatch('add', opt);\n\n        return this;\n    },\n\n    // When adding a lot of cells, it is much more efficient to\n    // reset the entire cells collection in one go.\n    // Useful for bulk operations and optimizations.\n    resetCells: function(cells, opt) {\n\n        var preparedCells = util.toArray(cells).map(function(cell) {\n            return this._prepareCell(cell, opt);\n        }, this);\n        this.get('cells').reset(preparedCells, opt);\n\n        return this;\n    },\n\n    removeCells: function(cells, opt) {\n\n        if (cells.length) {\n\n            this.startBatch('remove');\n            util.invoke(cells, 'remove', opt);\n            this.stopBatch('remove');\n        }\n\n        return this;\n    },\n\n    _removeCell: function(cell, collection, options) {\n\n        options = options || {};\n\n        if (!options.clear) {\n            // Applications might provide a `disconnectLinks` option set to `true` in order to\n            // disconnect links when a cell is removed rather then removing them. The default\n            // is to remove all the associated links.\n            if (options.disconnectLinks) {\n\n                this.disconnectLinks(cell, options);\n\n            } else {\n\n                this.removeLinks(cell, options);\n            }\n        }\n        // Silently remove the cell from the cells collection. Silently, because\n        // `joint.dia.Cell.prototype.remove` already triggers the `remove` event which is\n        // then propagated to the graph model. If we didn't remove the cell silently, two `remove` events\n        // would be triggered on the graph model.\n        this.get('cells').remove(cell, { silent: true });\n\n        if (cell.graph === this) {\n            // Remove the element graph reference only if the cell is the member of this graph.\n            cell.graph = null;\n        }\n    },\n\n    // Get a cell by `id`.\n    getCell: function(id) {\n\n        return this.get('cells').get(id);\n    },\n\n    getCells: function() {\n\n        return this.get('cells').toArray();\n    },\n\n    getElements: function() {\n\n        return this.get('cells').filter(cell => cell.isElement());\n    },\n\n    getLinks: function() {\n\n        return this.get('cells').filter(cell => cell.isLink());\n    },\n\n    getFirstCell: function() {\n\n        return this.get('cells').first();\n    },\n\n    getLastCell: function() {\n\n        return this.get('cells').last();\n    },\n\n    // Get all inbound and outbound links connected to the cell `model`.\n    getConnectedLinks: function(model, opt) {\n\n        opt = opt || {};\n\n        var indirect = opt.indirect;\n        var inbound = opt.inbound;\n        var outbound = opt.outbound;\n        if ((inbound === undefined) && (outbound === undefined)) {\n            inbound = outbound = true;\n        }\n\n        // the final array of connected link models\n        var links = [];\n        // a hash table of connected edges of the form: [edgeId] -> true\n        // used for quick lookups to check if we already added a link\n        var edges = {};\n\n        if (outbound) {\n            addOutbounds(this, model);\n        }\n        if (inbound) {\n            addInbounds(this, model);\n        }\n\n        function addOutbounds(graph, model) {\n            util.forIn(graph.getOutboundEdges(model.id), function(_, edge) {\n                // skip links that were already added\n                // (those must be self-loop links)\n                // (because they are inbound and outbound edges of the same two elements)\n                if (edges[edge]) return;\n                var link = graph.getCell(edge);\n                links.push(link);\n                edges[edge] = true;\n                if (indirect) {\n                    if (inbound) addInbounds(graph, link);\n                    if (outbound) addOutbounds(graph, link);\n                }\n            }.bind(graph));\n            if (indirect && model.isLink()) {\n                var outCell = model.getTargetCell();\n                if (outCell && outCell.isLink()) {\n                    if (!edges[outCell.id]) {\n                        links.push(outCell);\n                        addOutbounds(graph, outCell);\n                    }\n                }\n            }\n        }\n\n        function addInbounds(graph, model) {\n            util.forIn(graph.getInboundEdges(model.id), function(_, edge) {\n                // skip links that were already added\n                // (those must be self-loop links)\n                // (because they are inbound and outbound edges of the same two elements)\n                if (edges[edge]) return;\n                var link = graph.getCell(edge);\n                links.push(link);\n                edges[edge] = true;\n                if (indirect) {\n                    if (inbound) addInbounds(graph, link);\n                    if (outbound) addOutbounds(graph, link);\n                }\n            }.bind(graph));\n            if (indirect && model.isLink()) {\n                var inCell = model.getSourceCell();\n                if (inCell && inCell.isLink()) {\n                    if (!edges[inCell.id]) {\n                        links.push(inCell);\n                        addInbounds(graph, inCell);\n                    }\n                }\n            }\n        }\n\n        // if `deep` option is `true`, check also all the links that are connected to any of the descendant cells\n        if (opt.deep) {\n\n            var embeddedCells = model.getEmbeddedCells({ deep: true });\n\n            // in the first round, we collect all the embedded elements\n            var embeddedElements = {};\n            embeddedCells.forEach(function(cell) {\n                if (cell.isElement()) {\n                    embeddedElements[cell.id] = true;\n                }\n            });\n\n            embeddedCells.forEach(function(cell) {\n                if (cell.isLink()) return;\n                if (outbound) {\n                    util.forIn(this.getOutboundEdges(cell.id), function(exists, edge) {\n                        if (!edges[edge]) {\n                            var edgeCell = this.getCell(edge);\n                            var { source, target } = edgeCell.attributes;\n                            var sourceId = source.id;\n                            var targetId = target.id;\n\n                            // if `includeEnclosed` option is falsy, skip enclosed links\n                            if (!opt.includeEnclosed\n                                && (sourceId && embeddedElements[sourceId])\n                                && (targetId && embeddedElements[targetId])) {\n                                return;\n                            }\n\n                            links.push(this.getCell(edge));\n                            edges[edge] = true;\n                        }\n                    }.bind(this));\n                }\n                if (inbound) {\n                    util.forIn(this.getInboundEdges(cell.id), function(exists, edge) {\n                        if (!edges[edge]) {\n                            var edgeCell = this.getCell(edge);\n                            var { source, target } = edgeCell.attributes;\n                            var sourceId = source.id;\n                            var targetId = target.id;\n\n                            // if `includeEnclosed` option is falsy, skip enclosed links\n                            if (!opt.includeEnclosed\n                                && (sourceId && embeddedElements[sourceId])\n                                && (targetId && embeddedElements[targetId])) {\n                                return;\n                            }\n\n                            links.push(this.getCell(edge));\n                            edges[edge] = true;\n                        }\n                    }.bind(this));\n                }\n            }, this);\n        }\n\n        return links;\n    },\n\n    getNeighbors: function(model, opt) {\n\n        opt || (opt = {});\n\n        var inbound = opt.inbound;\n        var outbound = opt.outbound;\n        if (inbound === undefined && outbound === undefined) {\n            inbound = outbound = true;\n        }\n\n        var neighbors = this.getConnectedLinks(model, opt).reduce(function(res, link) {\n\n            var { source, target } = link.attributes;\n            var loop = link.hasLoop(opt);\n\n            // Discard if it is a point, or if the neighbor was already added.\n            if (inbound && util.has(source, 'id') && !res[source.id]) {\n\n                var sourceElement = this.getCell(source.id);\n                if (sourceElement.isElement()) {\n                    if (loop || (sourceElement && sourceElement !== model && (!opt.deep || !sourceElement.isEmbeddedIn(model)))) {\n                        res[source.id] = sourceElement;\n                    }\n                }\n            }\n\n            // Discard if it is a point, or if the neighbor was already added.\n            if (outbound && util.has(target, 'id') && !res[target.id]) {\n\n                var targetElement = this.getCell(target.id);\n                if (targetElement.isElement()) {\n                    if (loop || (targetElement && targetElement !== model && (!opt.deep || !targetElement.isEmbeddedIn(model)))) {\n                        res[target.id] = targetElement;\n                    }\n                }\n            }\n\n            return res;\n        }.bind(this), {});\n\n        if (model.isLink()) {\n            if (inbound) {\n                var sourceCell = model.getSourceCell();\n                if (sourceCell && sourceCell.isElement() && !neighbors[sourceCell.id]) {\n                    neighbors[sourceCell.id] = sourceCell;\n                }\n            }\n            if (outbound) {\n                var targetCell = model.getTargetCell();\n                if (targetCell && targetCell.isElement() && !neighbors[targetCell.id]) {\n                    neighbors[targetCell.id] = targetCell;\n                }\n            }\n        }\n\n        return util.toArray(neighbors);\n    },\n\n    getCommonAncestor: function(/* cells */) {\n\n        var cellsAncestors = Array.from(arguments).map(function(cell) {\n\n            var ancestors = [];\n            var parentId = cell.get('parent');\n\n            while (parentId) {\n\n                ancestors.push(parentId);\n                parentId = this.getCell(parentId).get('parent');\n            }\n\n            return ancestors;\n\n        }, this);\n\n        cellsAncestors = cellsAncestors.sort(function(a, b) {\n            return a.length - b.length;\n        });\n\n        var commonAncestor = util.toArray(cellsAncestors.shift()).find(function(ancestor) {\n            return cellsAncestors.every(function(cellAncestors) {\n                return cellAncestors.includes(ancestor);\n            });\n        });\n\n        return this.getCell(commonAncestor);\n    },\n\n    // Find the whole branch starting at `element`.\n    // If `opt.deep` is `true`, take into account embedded elements too.\n    // If `opt.breadthFirst` is `true`, use the Breadth-first search algorithm, otherwise use Depth-first search.\n    getSuccessors: function(element, opt) {\n\n        opt = opt || {};\n        var res = [];\n        // Modify the options so that it includes the `outbound` neighbors only. In other words, search forwards.\n        this.search(element, function(el) {\n            if (el !== element) {\n                res.push(el);\n            }\n        }, util.assign({}, opt, { outbound: true }));\n        return res;\n    },\n\n    cloneCells: cloneCells,\n    // Clone the whole subgraph (including all the connected links whose source/target is in the subgraph).\n    // If `opt.deep` is `true`, also take into account all the embedded cells of all the subgraph cells.\n    // Return a map of the form: [original cell ID] -> [clone].\n    cloneSubgraph: function(cells, opt) {\n\n        var subgraph = this.getSubgraph(cells, opt);\n        return this.cloneCells(subgraph);\n    },\n\n    // Return `cells` and all the connected links that connect cells in the `cells` array.\n    // If `opt.deep` is `true`, return all the cells including all their embedded cells\n    // and all the links that connect any of the returned cells.\n    // For example, for a single shallow element, the result is that very same element.\n    // For two elements connected with a link: `A --- L ---> B`, the result for\n    // `getSubgraph([A, B])` is `[A, L, B]`. The same goes for `getSubgraph([L])`, the result is again `[A, L, B]`.\n    getSubgraph: function(cells, opt) {\n\n        opt = opt || {};\n\n        var subgraph = [];\n        // `cellMap` is used for a quick lookup of existence of a cell in the `cells` array.\n        var cellMap = {};\n        var elements = [];\n        var links = [];\n\n        util.toArray(cells).forEach(function(cell) {\n            if (!cellMap[cell.id]) {\n                subgraph.push(cell);\n                cellMap[cell.id] = cell;\n                if (cell.isLink()) {\n                    links.push(cell);\n                } else {\n                    elements.push(cell);\n                }\n            }\n\n            if (opt.deep) {\n                var embeds = cell.getEmbeddedCells({ deep: true });\n                embeds.forEach(function(embed) {\n                    if (!cellMap[embed.id]) {\n                        subgraph.push(embed);\n                        cellMap[embed.id] = embed;\n                        if (embed.isLink()) {\n                            links.push(embed);\n                        } else {\n                            elements.push(embed);\n                        }\n                    }\n                });\n            }\n        });\n\n        links.forEach(function(link) {\n            // For links, return their source & target (if they are elements - not points).\n            var { source, target } = link.attributes;\n            if (source.id && !cellMap[source.id]) {\n                var sourceElement = this.getCell(source.id);\n                subgraph.push(sourceElement);\n                cellMap[sourceElement.id] = sourceElement;\n                elements.push(sourceElement);\n            }\n            if (target.id && !cellMap[target.id]) {\n                var targetElement = this.getCell(target.id);\n                subgraph.push(this.getCell(target.id));\n                cellMap[targetElement.id] = targetElement;\n                elements.push(targetElement);\n            }\n        }, this);\n\n        elements.forEach(function(element) {\n            // For elements, include their connected links if their source/target is in the subgraph;\n            var links = this.getConnectedLinks(element, opt);\n            links.forEach(function(link) {\n                var { source, target } = link.attributes;\n                if (!cellMap[link.id] && source.id && cellMap[source.id] && target.id && cellMap[target.id]) {\n                    subgraph.push(link);\n                    cellMap[link.id] = link;\n                }\n            });\n        }, this);\n\n        return subgraph;\n    },\n\n    // Find all the predecessors of `element`. This is a reverse operation of `getSuccessors()`.\n    // If `opt.deep` is `true`, take into account embedded elements too.\n    // If `opt.breadthFirst` is `true`, use the Breadth-first search algorithm, otherwise use Depth-first search.\n    getPredecessors: function(element, opt) {\n\n        opt = opt || {};\n        var res = [];\n        // Modify the options so that it includes the `inbound` neighbors only. In other words, search backwards.\n        this.search(element, function(el) {\n            if (el !== element) {\n                res.push(el);\n            }\n        }, util.assign({}, opt, { inbound: true }));\n        return res;\n    },\n\n    // Perform search on the graph.\n    // If `opt.breadthFirst` is `true`, use the Breadth-first Search algorithm, otherwise use Depth-first search.\n    // By setting `opt.inbound` to `true`, you can reverse the direction of the search.\n    // If `opt.deep` is `true`, take into account embedded elements too.\n    // `iteratee` is a function of the form `function(element) {}`.\n    // If `iteratee` explicitly returns `false`, the searching stops.\n    search: function(element, iteratee, opt) {\n\n        opt = opt || {};\n        if (opt.breadthFirst) {\n            this.bfs(element, iteratee, opt);\n        } else {\n            this.dfs(element, iteratee, opt);\n        }\n    },\n\n    // Breadth-first search.\n    // If `opt.deep` is `true`, take into account embedded elements too.\n    // If `opt.inbound` is `true`, reverse the search direction (it's like reversing all the link directions).\n    // `iteratee` is a function of the form `function(element, distance) {}`.\n    // where `element` is the currently visited element and `distance` is the distance of that element\n    // from the root `element` passed the `bfs()`, i.e. the element we started the search from.\n    // Note that the `distance` is not the shortest or longest distance, it is simply the number of levels\n    // crossed till we visited the `element` for the first time. It is especially useful for tree graphs.\n    // If `iteratee` explicitly returns `false`, the searching stops.\n    bfs: function(element, iteratee, opt = {}) {\n\n        const visited = {};\n        const distance = {};\n        const queue = [];\n\n        queue.push(element);\n        distance[element.id] = 0;\n\n        while (queue.length > 0) {\n            var next = queue.shift();\n            if (visited[next.id]) continue;\n            visited[next.id] = true;\n            if (iteratee.call(this, next, distance[next.id]) === false) continue;\n            const neighbors = this.getNeighbors(next, opt);\n            for (let i = 0, n = neighbors.length; i < n; i++) {\n                const neighbor = neighbors[i];\n                distance[neighbor.id] = distance[next.id] + 1;\n                queue.push(neighbor);\n            }\n        }\n    },\n\n    // Depth-first search.\n    // If `opt.deep` is `true`, take into account embedded elements too.\n    // If `opt.inbound` is `true`, reverse the search direction (it's like reversing all the link directions).\n    // `iteratee` is a function of the form `function(element, distance) {}`.\n    // If `iteratee` explicitly returns `false`, the search stops.\n    dfs: function(element, iteratee, opt = {}) {\n\n        const visited = {};\n        const distance = {};\n        const queue = [];\n\n        queue.push(element);\n        distance[element.id] = 0;\n\n        while (queue.length > 0) {\n            const next = queue.pop();\n            if (visited[next.id]) continue;\n            visited[next.id] = true;\n            if (iteratee.call(this, next, distance[next.id]) === false) continue;\n            const neighbors = this.getNeighbors(next, opt);\n            const lastIndex = queue.length;\n            for (let i = 0, n = neighbors.length; i < n; i++) {\n                const neighbor = neighbors[i];\n                distance[neighbor.id] = distance[next.id] + 1;\n                queue.splice(lastIndex, 0, neighbor);\n            }\n        }\n    },\n\n    // Get all the roots of the graph. Time complexity: O(|V|).\n    getSources: function() {\n\n        var sources = [];\n        util.forIn(this._nodes, function(exists, node) {\n            if (!this._in[node] || util.isEmpty(this._in[node])) {\n                sources.push(this.getCell(node));\n            }\n        }.bind(this));\n        return sources;\n    },\n\n    // Get all the leafs of the graph. Time complexity: O(|V|).\n    getSinks: function() {\n\n        var sinks = [];\n        util.forIn(this._nodes, function(exists, node) {\n            if (!this._out[node] || util.isEmpty(this._out[node])) {\n                sinks.push(this.getCell(node));\n            }\n        }.bind(this));\n        return sinks;\n    },\n\n    // Return `true` if `element` is a root. Time complexity: O(1).\n    isSource: function(element) {\n\n        return !this._in[element.id] || util.isEmpty(this._in[element.id]);\n    },\n\n    // Return `true` if `element` is a leaf. Time complexity: O(1).\n    isSink: function(element) {\n\n        return !this._out[element.id] || util.isEmpty(this._out[element.id]);\n    },\n\n    // Return `true` is `elementB` is a successor of `elementA`. Return `false` otherwise.\n    isSuccessor: function(elementA, elementB) {\n\n        var isSuccessor = false;\n        this.search(elementA, function(element) {\n            if (element === elementB && element !== elementA) {\n                isSuccessor = true;\n                return false;\n            }\n        }, { outbound: true });\n        return isSuccessor;\n    },\n\n    // Return `true` is `elementB` is a predecessor of `elementA`. Return `false` otherwise.\n    isPredecessor: function(elementA, elementB) {\n\n        var isPredecessor = false;\n        this.search(elementA, function(element) {\n            if (element === elementB && element !== elementA) {\n                isPredecessor = true;\n                return false;\n            }\n        }, { inbound: true });\n        return isPredecessor;\n    },\n\n    // Return `true` is `elementB` is a neighbor of `elementA`. Return `false` otherwise.\n    // `opt.deep` controls whether to take into account embedded elements as well. See `getNeighbors()`\n    // for more details.\n    // If `opt.outbound` is set to `true`, return `true` only if `elementB` is a successor neighbor.\n    // Similarly, if `opt.inbound` is set to `true`, return `true` only if `elementB` is a predecessor neighbor.\n    isNeighbor: function(elementA, elementB, opt) {\n\n        opt = opt || {};\n\n        var inbound = opt.inbound;\n        var outbound = opt.outbound;\n        if ((inbound === undefined) && (outbound === undefined)) {\n            inbound = outbound = true;\n        }\n\n        var isNeighbor = false;\n\n        this.getConnectedLinks(elementA, opt).forEach(function(link) {\n\n            var { source, target } = link.attributes;\n\n            // Discard if it is a point.\n            if (inbound && util.has(source, 'id') && (source.id === elementB.id)) {\n                isNeighbor = true;\n                return false;\n            }\n\n            // Discard if it is a point, or if the neighbor was already added.\n            if (outbound && util.has(target, 'id') && (target.id === elementB.id)) {\n                isNeighbor = true;\n                return false;\n            }\n        });\n\n        return isNeighbor;\n    },\n\n    // Disconnect links connected to the cell `model`.\n    disconnectLinks: function(model, opt) {\n\n        this.getConnectedLinks(model).forEach(function(link) {\n\n            link.set((link.attributes.source.id === model.id ? 'source' : 'target'), { x: 0, y: 0 }, opt);\n        });\n    },\n\n    // Remove links connected to the cell `model` completely.\n    removeLinks: function(model, opt) {\n\n        util.invoke(this.getConnectedLinks(model), 'remove', opt);\n    },\n\n    // Find all elements at given point\n    findModelsFromPoint: function(p) {\n        return this.getElements().filter(el => el.getBBox({ rotate: true }).containsPoint(p));\n    },\n\n    // Find all elements in given area\n    findModelsInArea: function(rect, opt = {}) {\n        const r = new g.Rect(rect);\n        const { strict = false } = opt;\n        const method = strict ? 'containsRect' : 'intersect';\n        return this.getElements().filter(el => r[method](el.getBBox({ rotate: true })));\n    },\n\n    // Find all elements under the given element.\n    findModelsUnderElement: function(element, opt = {}) {\n        const { searchBy = 'bbox' } = opt;\n        const bbox = element.getBBox().rotateAroundCenter(element.angle());\n        const elements = (searchBy === 'bbox')\n            ? this.findModelsInArea(bbox)\n            : this.findModelsFromPoint(bbox[searchBy]());\n        // don't account element itself or any of its descendants\n        return elements.filter(el => element.id !== el.id && !el.isEmbeddedIn(element));\n    },\n\n    // Return bounding box of all elements.\n    getBBox: function() {\n\n        return this.getCellsBBox(this.getCells());\n    },\n\n    // Return the bounding box of all cells in array provided.\n    getCellsBBox: function(cells, opt = {}) {\n        const { rotate = true } = opt;\n        return util.toArray(cells).reduce(function(memo, cell) {\n            const rect = cell.getBBox({ rotate });\n            if (!rect) return memo;\n            if (memo) {\n                return memo.union(rect);\n            }\n            return rect;\n        }, null);\n    },\n\n    translate: function(dx, dy, opt) {\n\n        // Don't translate cells that are embedded in any other cell.\n        var cells = this.getCells().filter(function(cell) {\n            return !cell.isEmbedded();\n        });\n\n        util.invoke(cells, 'translate', dx, dy, opt);\n\n        return this;\n    },\n\n    resize: function(width, height, opt) {\n\n        return this.resizeCells(width, height, this.getCells(), opt);\n    },\n\n    resizeCells: function(width, height, cells, opt) {\n\n        // `getBBox` method returns `null` if no elements provided.\n        // i.e. cells can be an array of links\n        var bbox = this.getCellsBBox(cells);\n        if (bbox) {\n            var sx = Math.max(width / bbox.width, 0);\n            var sy = Math.max(height / bbox.height, 0);\n            util.invoke(cells, 'scale', sx, sy, bbox.origin(), opt);\n        }\n\n        return this;\n    },\n\n    startBatch: function(name, data) {\n\n        data = data || {};\n        this._batches[name] = (this._batches[name] || 0) + 1;\n\n        return this.trigger('batch:start', util.assign({}, data, { batchName: name }));\n    },\n\n    stopBatch: function(name, data) {\n\n        data = data || {};\n        this._batches[name] = (this._batches[name] || 0) - 1;\n\n        return this.trigger('batch:stop', util.assign({}, data, { batchName: name }));\n    },\n\n    hasActiveBatch: function(name) {\n\n        const batches = this._batches;\n        let names;\n\n        if (arguments.length === 0) {\n            names = Object.keys(batches);\n        } else if (Array.isArray(name)) {\n            names = name;\n        } else {\n            names = [name];\n        }\n\n        return names.some((batch) => batches[batch] > 0);\n    }\n\n}, {\n\n    validations: {\n\n        multiLinks: function(graph, link) {\n\n            // Do not allow multiple links to have the same source and target.\n            var { source, target } = link.attributes;\n\n            if (source.id && target.id) {\n\n                var sourceModel = link.getSourceCell();\n                if (sourceModel) {\n\n                    var connectedLinks = graph.getConnectedLinks(sourceModel, { outbound: true });\n                    var sameLinks = connectedLinks.filter(function(_link) {\n\n                        var { source: _source, target: _target } = _link.attributes;\n                        return _source && _source.id === source.id &&\n                            (!_source.port || (_source.port === source.port)) &&\n                            _target && _target.id === target.id &&\n                            (!_target.port || (_target.port === target.port));\n\n                    });\n\n                    if (sameLinks.length > 1) {\n                        return false;\n                    }\n                }\n            }\n\n            return true;\n        },\n\n        linkPinning: function(_graph, link) {\n            var { source, target } = link.attributes;\n            return source.id && target.id;\n        }\n    }\n\n});\n\nwrapWith(Graph.prototype, ['resetCells', 'addCells', 'removeCells'], wrappers.cells);\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}