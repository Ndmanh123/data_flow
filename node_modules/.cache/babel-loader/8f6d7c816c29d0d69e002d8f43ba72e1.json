{"ast":null,"code":"import \"core-js/modules/es.array.includes.js\";\nimport * as util from '../util/index.mjs';\nimport * as g from '../g/index.mjs'; // default size of jump if not specified in options\n\nvar JUMP_SIZE = 5; // available jump types\n// first one taken as default\n\nvar JUMP_TYPES = ['arc', 'gap', 'cubic']; // default radius\n\nvar RADIUS = 0; // takes care of math. error for case when jump is too close to end of line\n\nvar CLOSE_PROXIMITY_PADDING = 1; // list of connector types not to jump over.\n\nvar IGNORED_CONNECTORS = ['smooth']; // internal constants for round segment\n\nvar _13 = 1 / 3;\n\nvar _23 = 2 / 3;\n/**\n * Transform start/end and route into series of lines\n * @param {g.point} sourcePoint start point\n * @param {g.point} targetPoint end point\n * @param {g.point[]} route optional list of route\n * @return {g.line[]} [description]\n */\n\n\nfunction createLines(sourcePoint, targetPoint, route) {\n  // make a flattened array of all points\n  var points = [].concat(sourcePoint, route, targetPoint);\n  return points.reduce(function (resultLines, point, idx) {\n    // if there is a next point, make a line with it\n    var nextPoint = points[idx + 1];\n\n    if (nextPoint != null) {\n      resultLines[idx] = g.line(point, nextPoint);\n    }\n\n    return resultLines;\n  }, []);\n}\n\nfunction setupUpdating(jumpOverLinkView) {\n  var paper = jumpOverLinkView.paper;\n  var updateList = paper._jumpOverUpdateList; // first time setup for this paper\n\n  if (updateList == null) {\n    updateList = paper._jumpOverUpdateList = [];\n    var graph = paper.model;\n    graph.on('batch:stop', function () {\n      if (this.hasActiveBatch()) return;\n      updateJumpOver(paper);\n    });\n    graph.on('reset', function () {\n      updateList = paper._jumpOverUpdateList = [];\n    });\n  } // add this link to a list so it can be updated when some other link is updated\n\n\n  if (updateList.indexOf(jumpOverLinkView) < 0) {\n    updateList.push(jumpOverLinkView); // watch for change of connector type or removal of link itself\n    // to remove the link from a list of jump over connectors\n\n    jumpOverLinkView.listenToOnce(jumpOverLinkView.model, 'change:connector remove', function () {\n      updateList.splice(updateList.indexOf(jumpOverLinkView), 1);\n    });\n  }\n}\n/**\n * Handler for a batch:stop event to force\n * update of all registered links with jump over connector\n * @param {object} batchEvent optional object with info about batch\n */\n\n\nfunction updateJumpOver(paper) {\n  var updateList = paper._jumpOverUpdateList;\n\n  for (var i = 0; i < updateList.length; i++) {\n    const linkView = updateList[i];\n    const updateFlag = linkView.getFlag(linkView.constructor.Flags.CONNECTOR);\n    linkView.requestUpdate(updateFlag);\n  }\n}\n/**\n * Utility function to collect all intersection points of a single\n * line against group of other lines.\n * @param {g.line} line where to find points\n * @param {g.line[]} crossCheckLines lines to cross\n * @return {g.point[]} list of intersection points\n */\n\n\nfunction findLineIntersections(line, crossCheckLines) {\n  return util.toArray(crossCheckLines).reduce(function (res, crossCheckLine) {\n    var intersection = line.intersection(crossCheckLine);\n\n    if (intersection) {\n      res.push(intersection);\n    }\n\n    return res;\n  }, []);\n}\n/**\n * Sorting function for list of points by their distance.\n * @param {g.point} p1 first point\n * @param {g.point} p2 second point\n * @return {number} squared distance between points\n */\n\n\nfunction sortPoints(p1, p2) {\n  return g.line(p1, p2).squaredLength();\n}\n/**\n * Split input line into multiple based on intersection points.\n * @param {g.line} line input line to split\n * @param {g.point[]} intersections points where to split the line\n * @param {number} jumpSize the size of jump arc (length empty spot on a line)\n * @return {g.line[]} list of lines being split\n */\n\n\nfunction createJumps(line, intersections, jumpSize) {\n  return intersections.reduce(function (resultLines, point, idx) {\n    // skipping points that were merged with the previous line\n    // to make bigger arc over multiple lines that are close to each other\n    if (point.skip === true) {\n      return resultLines;\n    } // always grab the last line from buffer and modify it\n\n\n    var lastLine = resultLines.pop() || line; // calculate start and end of jump by moving by a given size of jump\n\n    var jumpStart = g.point(point).move(lastLine.start, -jumpSize);\n    var jumpEnd = g.point(point).move(lastLine.start, +jumpSize); // now try to look at the next intersection point\n\n    var nextPoint = intersections[idx + 1];\n\n    if (nextPoint != null) {\n      var distance = jumpEnd.distance(nextPoint);\n\n      if (distance <= jumpSize) {\n        // next point is close enough, move the jump end by this\n        // difference and mark the next point to be skipped\n        jumpEnd = nextPoint.move(lastLine.start, distance);\n        nextPoint.skip = true;\n      }\n    } else {\n      // this block is inside of `else` as an optimization so the distance is\n      // not calculated when we know there are no other intersection points\n      var endDistance = jumpStart.distance(lastLine.end); // if the end is too close to possible jump, draw remaining line instead of a jump\n\n      if (endDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\n        resultLines.push(lastLine);\n        return resultLines;\n      }\n    }\n\n    var startDistance = jumpEnd.distance(lastLine.start);\n\n    if (startDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\n      // if the start of line is too close to jump, draw that line instead of a jump\n      resultLines.push(lastLine);\n      return resultLines;\n    } // finally create a jump line\n\n\n    var jumpLine = g.line(jumpStart, jumpEnd); // it's just simple line but with a `isJump` property\n\n    jumpLine.isJump = true;\n    resultLines.push(g.line(lastLine.start, jumpStart), jumpLine, g.line(jumpEnd, lastLine.end));\n    return resultLines;\n  }, []);\n}\n/**\n * Assemble `D` attribute of a SVG path by iterating given lines.\n * @param {g.line[]} lines source lines to use\n * @param {number} jumpSize the size of jump arc (length empty spot on a line)\n * @param {number} radius the radius\n * @return {string}\n */\n\n\nfunction buildPath(lines, jumpSize, jumpType, radius) {\n  var path = new g.Path();\n  var segment; // first move to the start of a first line\n\n  segment = g.Path.createSegment('M', lines[0].start);\n  path.appendSegment(segment); // make a paths from lines\n\n  util.toArray(lines).forEach(function (line, index) {\n    if (line.isJump) {\n      var angle, diff;\n      var control1, control2;\n\n      if (jumpType === 'arc') {\n        // approximates semicircle with 2 curves\n        angle = -90; // determine rotation of arc based on difference between points\n\n        diff = line.start.difference(line.end); // make sure the arc always points up (or right)\n\n        var xAxisRotate = Number(diff.x < 0 || diff.x === 0 && diff.y < 0);\n        if (xAxisRotate) angle += 180;\n        var midpoint = line.midpoint();\n        var centerLine = new g.Line(midpoint, line.end).rotate(midpoint, angle);\n        var halfLine; // first half\n\n        halfLine = new g.Line(line.start, midpoint);\n        control1 = halfLine.pointAt(2 / 3).rotate(line.start, angle);\n        control2 = centerLine.pointAt(1 / 3).rotate(centerLine.end, -angle);\n        segment = g.Path.createSegment('C', control1, control2, centerLine.end);\n        path.appendSegment(segment); // second half\n\n        halfLine = new g.Line(midpoint, line.end);\n        control1 = centerLine.pointAt(1 / 3).rotate(centerLine.end, angle);\n        control2 = halfLine.pointAt(1 / 3).rotate(line.end, -angle);\n        segment = g.Path.createSegment('C', control1, control2, line.end);\n        path.appendSegment(segment);\n      } else if (jumpType === 'gap') {\n        segment = g.Path.createSegment('M', line.end);\n        path.appendSegment(segment);\n      } else if (jumpType === 'cubic') {\n        // approximates semicircle with 1 curve\n        angle = line.start.theta(line.end);\n        var xOffset = jumpSize * 0.6;\n        var yOffset = jumpSize * 1.35; // determine rotation of arc based on difference between points\n\n        diff = line.start.difference(line.end); // make sure the arc always points up (or right)\n\n        xAxisRotate = Number(diff.x < 0 || diff.x === 0 && diff.y < 0);\n        if (xAxisRotate) yOffset *= -1;\n        control1 = g.Point(line.start.x + xOffset, line.start.y + yOffset).rotate(line.start, angle);\n        control2 = g.Point(line.end.x - xOffset, line.end.y + yOffset).rotate(line.end, angle);\n        segment = g.Path.createSegment('C', control1, control2, line.end);\n        path.appendSegment(segment);\n      }\n    } else {\n      var nextLine = lines[index + 1];\n\n      if (radius == 0 || !nextLine || nextLine.isJump) {\n        segment = g.Path.createSegment('L', line.end);\n        path.appendSegment(segment);\n      } else {\n        buildRoundedSegment(radius, path, line.end, line.start, nextLine.end);\n      }\n    }\n  });\n  return path;\n}\n\nfunction buildRoundedSegment(offset, path, curr, prev, next) {\n  var prevDistance = curr.distance(prev) / 2;\n  var nextDistance = curr.distance(next) / 2;\n  var startMove = -Math.min(offset, prevDistance);\n  var endMove = -Math.min(offset, nextDistance);\n  var roundedStart = curr.clone().move(prev, startMove).round();\n  var roundedEnd = curr.clone().move(next, endMove).round();\n  var control1 = new g.Point(_13 * roundedStart.x + _23 * curr.x, _23 * curr.y + _13 * roundedStart.y);\n  var control2 = new g.Point(_13 * roundedEnd.x + _23 * curr.x, _23 * curr.y + _13 * roundedEnd.y);\n  var segment;\n  segment = g.Path.createSegment('L', roundedStart);\n  path.appendSegment(segment);\n  segment = g.Path.createSegment('C', control1, control2, roundedEnd);\n  path.appendSegment(segment);\n}\n/**\n * Actual connector function that will be run on every update.\n * @param {g.point} sourcePoint start point of this link\n * @param {g.point} targetPoint end point of this link\n * @param {g.point[]} route of this link\n * @param {object} opt options\n * @property {number} size optional size of a jump arc\n * @return {string} created `D` attribute of SVG path\n */\n\n\nexport const jumpover = function (sourcePoint, targetPoint, route, opt) {\n  // eslint-disable-line max-params\n  setupUpdating(this);\n  var raw = opt.raw;\n  var jumpSize = opt.size || JUMP_SIZE;\n  var jumpType = opt.jump && ('' + opt.jump).toLowerCase();\n  var radius = opt.radius || RADIUS;\n  var ignoreConnectors = opt.ignoreConnectors || IGNORED_CONNECTORS; // grab the first jump type as a default if specified one is invalid\n\n  if (JUMP_TYPES.indexOf(jumpType) === -1) {\n    jumpType = JUMP_TYPES[0];\n  }\n\n  var paper = this.paper;\n  var graph = paper.model;\n  var allLinks = graph.getLinks(); // there is just one link, draw it directly\n\n  if (allLinks.length === 1) {\n    return buildPath(createLines(sourcePoint, targetPoint, route), jumpSize, jumpType, radius);\n  }\n\n  var thisModel = this.model;\n  var thisIndex = allLinks.indexOf(thisModel);\n  var defaultConnector = paper.options.defaultConnector || {}; // not all links are meant to be jumped over.\n\n  var links = allLinks.filter(function (link, idx) {\n    var connector = link.get('connector') || defaultConnector; // avoid jumping over links with connector type listed in `ignored connectors`.\n\n    if (util.toArray(ignoreConnectors).includes(connector.name)) {\n      return false;\n    } // filter out links that are above this one and  have the same connector type\n    // otherwise there would double hoops for each intersection\n\n\n    if (idx > thisIndex) {\n      return connector.name !== 'jumpover';\n    }\n\n    return true;\n  }); // find views for all links\n\n  var linkViews = links.map(function (link) {\n    return paper.findViewByModel(link);\n  }); // create lines for this link\n\n  var thisLines = createLines(sourcePoint, targetPoint, route); // create lines for all other links\n\n  var linkLines = linkViews.map(function (linkView) {\n    if (linkView == null) {\n      return [];\n    }\n\n    if (linkView === this) {\n      return thisLines;\n    }\n\n    return createLines(linkView.sourcePoint, linkView.targetPoint, linkView.route);\n  }, this); // transform lines for this link by splitting with jump lines at\n  // points of intersection with other links\n\n  var jumpingLines = thisLines.reduce(function (resultLines, thisLine) {\n    // iterate all links and grab the intersections with this line\n    // these are then sorted by distance so the line can be split more easily\n    var intersections = links.reduce(function (res, link, i) {\n      // don't intersection with itself\n      if (link !== thisModel) {\n        var lineIntersections = findLineIntersections(thisLine, linkLines[i]);\n        res.push.apply(res, lineIntersections);\n      }\n\n      return res;\n    }, []).sort(function (a, b) {\n      return sortPoints(thisLine.start, a) - sortPoints(thisLine.start, b);\n    });\n\n    if (intersections.length > 0) {\n      // split the line based on found intersection points\n      resultLines.push.apply(resultLines, createJumps(thisLine, intersections, jumpSize));\n    } else {\n      // without any intersection the line goes uninterrupted\n      resultLines.push(thisLine);\n    }\n\n    return resultLines;\n  }, []);\n  var path = buildPath(jumpingLines, jumpSize, jumpType, radius);\n  return raw ? path : path.serialize();\n};","map":{"version":3,"names":["util","g","JUMP_SIZE","JUMP_TYPES","RADIUS","CLOSE_PROXIMITY_PADDING","IGNORED_CONNECTORS","_13","_23","createLines","sourcePoint","targetPoint","route","points","concat","reduce","resultLines","point","idx","nextPoint","line","setupUpdating","jumpOverLinkView","paper","updateList","_jumpOverUpdateList","graph","model","on","hasActiveBatch","updateJumpOver","indexOf","push","listenToOnce","splice","i","length","linkView","updateFlag","getFlag","constructor","Flags","CONNECTOR","requestUpdate","findLineIntersections","crossCheckLines","toArray","res","crossCheckLine","intersection","sortPoints","p1","p2","squaredLength","createJumps","intersections","jumpSize","skip","lastLine","pop","jumpStart","move","start","jumpEnd","distance","endDistance","end","startDistance","jumpLine","isJump","buildPath","lines","jumpType","radius","path","Path","segment","createSegment","appendSegment","forEach","index","angle","diff","control1","control2","difference","xAxisRotate","Number","x","y","midpoint","centerLine","Line","rotate","halfLine","pointAt","theta","xOffset","yOffset","Point","nextLine","buildRoundedSegment","offset","curr","prev","next","prevDistance","nextDistance","startMove","Math","min","endMove","roundedStart","clone","round","roundedEnd","jumpover","opt","raw","size","jump","toLowerCase","ignoreConnectors","allLinks","getLinks","thisModel","thisIndex","defaultConnector","options","links","filter","link","connector","get","includes","name","linkViews","map","findViewByModel","thisLines","linkLines","jumpingLines","thisLine","lineIntersections","apply","sort","a","b","serialize"],"sources":["C:/Users/Admin/dataflow-test/node_modules/jointjs/src/connectors/jumpover.mjs"],"sourcesContent":["import * as util from '../util/index.mjs';\nimport * as g from '../g/index.mjs';\n\n// default size of jump if not specified in options\nvar JUMP_SIZE = 5;\n\n// available jump types\n// first one taken as default\nvar JUMP_TYPES = ['arc', 'gap', 'cubic'];\n\n// default radius\nvar RADIUS = 0;\n\n// takes care of math. error for case when jump is too close to end of line\nvar CLOSE_PROXIMITY_PADDING = 1;\n\n// list of connector types not to jump over.\nvar IGNORED_CONNECTORS = ['smooth'];\n\n// internal constants for round segment\nvar _13 = 1 / 3;\nvar _23 = 2 / 3;\n\n/**\n * Transform start/end and route into series of lines\n * @param {g.point} sourcePoint start point\n * @param {g.point} targetPoint end point\n * @param {g.point[]} route optional list of route\n * @return {g.line[]} [description]\n */\nfunction createLines(sourcePoint, targetPoint, route) {\n    // make a flattened array of all points\n    var points = [].concat(sourcePoint, route, targetPoint);\n    return points.reduce(function(resultLines, point, idx) {\n        // if there is a next point, make a line with it\n        var nextPoint = points[idx + 1];\n        if (nextPoint != null) {\n            resultLines[idx] = g.line(point, nextPoint);\n        }\n        return resultLines;\n    }, []);\n}\n\nfunction setupUpdating(jumpOverLinkView) {\n    var paper = jumpOverLinkView.paper;\n    var updateList = paper._jumpOverUpdateList;\n\n    // first time setup for this paper\n    if (updateList == null) {\n        updateList = paper._jumpOverUpdateList = [];\n        var graph = paper.model;\n        graph.on('batch:stop', function() {\n            if (this.hasActiveBatch()) return;\n            updateJumpOver(paper);\n        });\n        graph.on('reset', function() {\n            updateList = paper._jumpOverUpdateList = [];\n        });\n    }\n\n    // add this link to a list so it can be updated when some other link is updated\n    if (updateList.indexOf(jumpOverLinkView) < 0) {\n        updateList.push(jumpOverLinkView);\n\n        // watch for change of connector type or removal of link itself\n        // to remove the link from a list of jump over connectors\n        jumpOverLinkView.listenToOnce(jumpOverLinkView.model, 'change:connector remove', function() {\n            updateList.splice(updateList.indexOf(jumpOverLinkView), 1);\n        });\n    }\n}\n\n/**\n * Handler for a batch:stop event to force\n * update of all registered links with jump over connector\n * @param {object} batchEvent optional object with info about batch\n */\nfunction updateJumpOver(paper) {\n    var updateList = paper._jumpOverUpdateList;\n    for (var i = 0; i < updateList.length; i++) {\n        const linkView = updateList[i];\n        const updateFlag = linkView.getFlag(linkView.constructor.Flags.CONNECTOR);\n        linkView.requestUpdate(updateFlag);\n    }\n}\n\n/**\n * Utility function to collect all intersection points of a single\n * line against group of other lines.\n * @param {g.line} line where to find points\n * @param {g.line[]} crossCheckLines lines to cross\n * @return {g.point[]} list of intersection points\n */\nfunction findLineIntersections(line, crossCheckLines) {\n    return util.toArray(crossCheckLines).reduce(function(res, crossCheckLine) {\n        var intersection = line.intersection(crossCheckLine);\n        if (intersection) {\n            res.push(intersection);\n        }\n        return res;\n    }, []);\n}\n\n/**\n * Sorting function for list of points by their distance.\n * @param {g.point} p1 first point\n * @param {g.point} p2 second point\n * @return {number} squared distance between points\n */\nfunction sortPoints(p1, p2) {\n    return g.line(p1, p2).squaredLength();\n}\n\n/**\n * Split input line into multiple based on intersection points.\n * @param {g.line} line input line to split\n * @param {g.point[]} intersections points where to split the line\n * @param {number} jumpSize the size of jump arc (length empty spot on a line)\n * @return {g.line[]} list of lines being split\n */\nfunction createJumps(line, intersections, jumpSize) {\n    return intersections.reduce(function(resultLines, point, idx) {\n        // skipping points that were merged with the previous line\n        // to make bigger arc over multiple lines that are close to each other\n        if (point.skip === true) {\n            return resultLines;\n        }\n\n        // always grab the last line from buffer and modify it\n        var lastLine = resultLines.pop() || line;\n\n        // calculate start and end of jump by moving by a given size of jump\n        var jumpStart = g.point(point).move(lastLine.start, -(jumpSize));\n        var jumpEnd = g.point(point).move(lastLine.start, +(jumpSize));\n\n        // now try to look at the next intersection point\n        var nextPoint = intersections[idx + 1];\n        if (nextPoint != null) {\n            var distance = jumpEnd.distance(nextPoint);\n            if (distance <= jumpSize) {\n                // next point is close enough, move the jump end by this\n                // difference and mark the next point to be skipped\n                jumpEnd = nextPoint.move(lastLine.start, distance);\n                nextPoint.skip = true;\n            }\n        } else {\n            // this block is inside of `else` as an optimization so the distance is\n            // not calculated when we know there are no other intersection points\n            var endDistance = jumpStart.distance(lastLine.end);\n            // if the end is too close to possible jump, draw remaining line instead of a jump\n            if (endDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\n                resultLines.push(lastLine);\n                return resultLines;\n            }\n        }\n\n        var startDistance = jumpEnd.distance(lastLine.start);\n        if (startDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\n            // if the start of line is too close to jump, draw that line instead of a jump\n            resultLines.push(lastLine);\n            return resultLines;\n        }\n\n        // finally create a jump line\n        var jumpLine = g.line(jumpStart, jumpEnd);\n        // it's just simple line but with a `isJump` property\n        jumpLine.isJump = true;\n\n        resultLines.push(\n            g.line(lastLine.start, jumpStart),\n            jumpLine,\n            g.line(jumpEnd, lastLine.end)\n        );\n        return resultLines;\n    }, []);\n}\n\n/**\n * Assemble `D` attribute of a SVG path by iterating given lines.\n * @param {g.line[]} lines source lines to use\n * @param {number} jumpSize the size of jump arc (length empty spot on a line)\n * @param {number} radius the radius\n * @return {string}\n */\nfunction buildPath(lines, jumpSize, jumpType, radius) {\n\n    var path = new g.Path();\n    var segment;\n\n    // first move to the start of a first line\n    segment = g.Path.createSegment('M', lines[0].start);\n    path.appendSegment(segment);\n\n    // make a paths from lines\n    util.toArray(lines).forEach(function(line, index) {\n\n        if (line.isJump) {\n            var angle, diff;\n\n            var control1, control2;\n\n            if (jumpType === 'arc') { // approximates semicircle with 2 curves\n                angle = -90;\n                // determine rotation of arc based on difference between points\n                diff = line.start.difference(line.end);\n                // make sure the arc always points up (or right)\n                var xAxisRotate = Number((diff.x < 0) || (diff.x === 0 && diff.y < 0));\n                if (xAxisRotate) angle += 180;\n\n                var midpoint = line.midpoint();\n                var centerLine = new g.Line(midpoint, line.end).rotate(midpoint, angle);\n\n                var halfLine;\n\n                // first half\n                halfLine = new g.Line(line.start, midpoint);\n\n                control1 = halfLine.pointAt(2 / 3).rotate(line.start, angle);\n                control2 = centerLine.pointAt(1 / 3).rotate(centerLine.end, -angle);\n\n                segment = g.Path.createSegment('C', control1, control2, centerLine.end);\n                path.appendSegment(segment);\n\n                // second half\n                halfLine = new g.Line(midpoint, line.end);\n\n                control1 = centerLine.pointAt(1 / 3).rotate(centerLine.end, angle);\n                control2 = halfLine.pointAt(1 / 3).rotate(line.end, -angle);\n\n                segment = g.Path.createSegment('C', control1, control2, line.end);\n                path.appendSegment(segment);\n\n            } else if (jumpType === 'gap') {\n                segment = g.Path.createSegment('M', line.end);\n                path.appendSegment(segment);\n\n            } else if (jumpType === 'cubic') { // approximates semicircle with 1 curve\n                angle = line.start.theta(line.end);\n\n                var xOffset = jumpSize * 0.6;\n                var yOffset = jumpSize * 1.35;\n\n                // determine rotation of arc based on difference between points\n                diff = line.start.difference(line.end);\n                // make sure the arc always points up (or right)\n                xAxisRotate = Number((diff.x < 0) || (diff.x === 0 && diff.y < 0));\n                if (xAxisRotate) yOffset *= -1;\n\n                control1 = g.Point(line.start.x + xOffset, line.start.y + yOffset).rotate(line.start, angle);\n                control2 = g.Point(line.end.x - xOffset, line.end.y + yOffset).rotate(line.end, angle);\n\n                segment = g.Path.createSegment('C', control1, control2, line.end);\n                path.appendSegment(segment);\n            }\n\n        } else {\n            var nextLine = lines[index + 1];\n            if (radius == 0 || !nextLine || nextLine.isJump) {\n                segment = g.Path.createSegment('L', line.end);\n                path.appendSegment(segment);\n            } else {\n                buildRoundedSegment(radius, path, line.end, line.start, nextLine.end);\n            }\n        }\n    });\n\n    return path;\n}\n\nfunction buildRoundedSegment(offset, path, curr, prev, next) {\n    var prevDistance = curr.distance(prev) / 2;\n    var nextDistance = curr.distance(next) / 2;\n\n    var startMove = -Math.min(offset, prevDistance);\n    var endMove = -Math.min(offset, nextDistance);\n\n    var roundedStart = curr.clone().move(prev, startMove).round();\n    var roundedEnd = curr.clone().move(next, endMove).round();\n\n    var control1 = new g.Point((_13 * roundedStart.x) + (_23 * curr.x), (_23 * curr.y) + (_13 * roundedStart.y));\n    var control2 = new g.Point((_13 * roundedEnd.x) + (_23 * curr.x), (_23 * curr.y) + (_13 * roundedEnd.y));\n\n    var segment;\n    segment = g.Path.createSegment('L', roundedStart);\n    path.appendSegment(segment);\n\n    segment = g.Path.createSegment('C', control1, control2, roundedEnd);\n    path.appendSegment(segment);\n}\n\n/**\n * Actual connector function that will be run on every update.\n * @param {g.point} sourcePoint start point of this link\n * @param {g.point} targetPoint end point of this link\n * @param {g.point[]} route of this link\n * @param {object} opt options\n * @property {number} size optional size of a jump arc\n * @return {string} created `D` attribute of SVG path\n */\nexport const jumpover = function(sourcePoint, targetPoint, route, opt) { // eslint-disable-line max-params\n\n    setupUpdating(this);\n\n    var raw = opt.raw;\n    var jumpSize = opt.size || JUMP_SIZE;\n    var jumpType = opt.jump && ('' + opt.jump).toLowerCase();\n    var radius = opt.radius || RADIUS;\n    var ignoreConnectors = opt.ignoreConnectors || IGNORED_CONNECTORS;\n\n    // grab the first jump type as a default if specified one is invalid\n    if (JUMP_TYPES.indexOf(jumpType) === -1) {\n        jumpType = JUMP_TYPES[0];\n    }\n\n    var paper = this.paper;\n    var graph = paper.model;\n    var allLinks = graph.getLinks();\n\n    // there is just one link, draw it directly\n    if (allLinks.length === 1) {\n        return buildPath(\n            createLines(sourcePoint, targetPoint, route),\n            jumpSize, jumpType, radius\n        );\n    }\n\n    var thisModel = this.model;\n    var thisIndex = allLinks.indexOf(thisModel);\n    var defaultConnector = paper.options.defaultConnector || {};\n\n    // not all links are meant to be jumped over.\n    var links = allLinks.filter(function(link, idx) {\n\n        var connector = link.get('connector') || defaultConnector;\n\n        // avoid jumping over links with connector type listed in `ignored connectors`.\n        if (util.toArray(ignoreConnectors).includes(connector.name)) {\n            return false;\n        }\n        // filter out links that are above this one and  have the same connector type\n        // otherwise there would double hoops for each intersection\n        if (idx > thisIndex) {\n            return connector.name !== 'jumpover';\n        }\n        return true;\n    });\n\n    // find views for all links\n    var linkViews = links.map(function(link) {\n        return paper.findViewByModel(link);\n    });\n\n    // create lines for this link\n    var thisLines = createLines(\n        sourcePoint,\n        targetPoint,\n        route\n    );\n\n    // create lines for all other links\n    var linkLines = linkViews.map(function(linkView) {\n        if (linkView == null) {\n            return [];\n        }\n        if (linkView === this) {\n            return thisLines;\n        }\n        return createLines(\n            linkView.sourcePoint,\n            linkView.targetPoint,\n            linkView.route\n        );\n    }, this);\n\n    // transform lines for this link by splitting with jump lines at\n    // points of intersection with other links\n    var jumpingLines = thisLines.reduce(function(resultLines, thisLine) {\n        // iterate all links and grab the intersections with this line\n        // these are then sorted by distance so the line can be split more easily\n\n        var intersections = links.reduce(function(res, link, i) {\n            // don't intersection with itself\n            if (link !== thisModel) {\n\n                var lineIntersections = findLineIntersections(thisLine, linkLines[i]);\n                res.push.apply(res, lineIntersections);\n            }\n            return res;\n        }, []).sort(function(a, b) {\n            return sortPoints(thisLine.start, a) - sortPoints(thisLine.start, b);\n        });\n\n        if (intersections.length > 0) {\n            // split the line based on found intersection points\n            resultLines.push.apply(resultLines, createJumps(thisLine, intersections, jumpSize));\n        } else {\n            // without any intersection the line goes uninterrupted\n            resultLines.push(thisLine);\n        }\n        return resultLines;\n    }, []);\n\n    var path = buildPath(jumpingLines, jumpSize, jumpType, radius);\n    return (raw) ? path : path.serialize();\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}