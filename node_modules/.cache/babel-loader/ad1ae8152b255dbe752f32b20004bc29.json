{"ast":null,"code":"import { Rect } from './rect.mjs';\nimport { Point } from './point.mjs';\nimport { types } from './types.mjs';\nconst {\n  sqrt,\n  round,\n  pow\n} = Math;\nexport const Ellipse = function (c, a, b) {\n  if (!(this instanceof Ellipse)) {\n    return new Ellipse(c, a, b);\n  }\n\n  if (c instanceof Ellipse) {\n    return new Ellipse(new Point(c.x, c.y), c.a, c.b);\n  }\n\n  c = new Point(c);\n  this.x = c.x;\n  this.y = c.y;\n  this.a = a;\n  this.b = b;\n};\n\nEllipse.fromRect = function (rect) {\n  rect = new Rect(rect);\n  return new Ellipse(rect.center(), rect.width / 2, rect.height / 2);\n};\n\nEllipse.prototype = {\n  type: types.Ellipse,\n  bbox: function () {\n    return new Rect(this.x - this.a, this.y - this.b, 2 * this.a, 2 * this.b);\n  },\n\n  /**\n   * @returns {g.Point}\n   */\n  center: function () {\n    return new Point(this.x, this.y);\n  },\n  clone: function () {\n    return new Ellipse(this);\n  },\n\n  /**\n   * @param {g.Point} p\n   * @returns {boolean}\n   */\n  containsPoint: function (p) {\n    return this.normalizedDistance(p) <= 1;\n  },\n  equals: function (ellipse) {\n    return !!ellipse && ellipse.x === this.x && ellipse.y === this.y && ellipse.a === this.a && ellipse.b === this.b;\n  },\n  // inflate by dx and dy\n  // @param dx {delta_x} representing additional size to x\n  // @param dy {delta_y} representing additional size to y -\n  // dy param is not required -> in that case y is sized by dx\n  inflate: function (dx, dy) {\n    if (dx === undefined) {\n      dx = 0;\n    }\n\n    if (dy === undefined) {\n      dy = dx;\n    }\n\n    this.a += 2 * dx;\n    this.b += 2 * dy;\n    return this;\n  },\n  intersectionWithLine: function (line) {\n    var intersections = [];\n    var a1 = line.start;\n    var a2 = line.end;\n    var rx = this.a;\n    var ry = this.b;\n    var dir = line.vector();\n    var diff = a1.difference(new Point(this));\n    var mDir = new Point(dir.x / (rx * rx), dir.y / (ry * ry));\n    var mDiff = new Point(diff.x / (rx * rx), diff.y / (ry * ry));\n    var a = dir.dot(mDir);\n    var b = dir.dot(mDiff);\n    var c = diff.dot(mDiff) - 1.0;\n    var d = b * b - a * c;\n\n    if (d < 0) {\n      return null;\n    } else if (d > 0) {\n      var root = sqrt(d);\n      var ta = (-b - root) / a;\n      var tb = (-b + root) / a;\n\n      if ((ta < 0 || 1 < ta) && (tb < 0 || 1 < tb)) {\n        // if ((ta < 0 && tb < 0) || (ta > 1 && tb > 1)) outside else inside\n        return null;\n      } else {\n        if (0 <= ta && ta <= 1) intersections.push(a1.lerp(a2, ta));\n        if (0 <= tb && tb <= 1) intersections.push(a1.lerp(a2, tb));\n      }\n    } else {\n      var t = -b / a;\n\n      if (0 <= t && t <= 1) {\n        intersections.push(a1.lerp(a2, t));\n      } else {\n        // outside\n        return null;\n      }\n    }\n\n    return intersections;\n  },\n  // Find point on me where line from my center to\n  // point p intersects my boundary.\n  // @param {number} angle If angle is specified, intersection with rotated ellipse is computed.\n  intersectionWithLineFromCenterToPoint: function (p, angle) {\n    p = new Point(p);\n    if (angle) p.rotate(new Point(this.x, this.y), angle);\n    var dx = p.x - this.x;\n    var dy = p.y - this.y;\n    var result;\n\n    if (dx === 0) {\n      result = this.bbox().pointNearestToPoint(p);\n      if (angle) return result.rotate(new Point(this.x, this.y), -angle);\n      return result;\n    }\n\n    var m = dy / dx;\n    var mSquared = m * m;\n    var aSquared = this.a * this.a;\n    var bSquared = this.b * this.b;\n    var x = sqrt(1 / (1 / aSquared + mSquared / bSquared));\n    x = dx < 0 ? -x : x;\n    var y = m * x;\n    result = new Point(this.x + x, this.y + y);\n    if (angle) return result.rotate(new Point(this.x, this.y), -angle);\n    return result;\n  },\n\n  /**\n   * @param {g.Point} point\n   * @returns {number} result < 1 - inside ellipse, result == 1 - on ellipse boundary, result > 1 - outside\n   */\n  normalizedDistance: function (point) {\n    var x0 = point.x;\n    var y0 = point.y;\n    var a = this.a;\n    var b = this.b;\n    var x = this.x;\n    var y = this.y;\n    return (x0 - x) * (x0 - x) / (a * a) + (y0 - y) * (y0 - y) / (b * b);\n  },\n  round: function (precision) {\n    let f = 1; // case 0\n\n    if (precision) {\n      switch (precision) {\n        case 1:\n          f = 10;\n          break;\n\n        case 2:\n          f = 100;\n          break;\n\n        case 3:\n          f = 1000;\n          break;\n\n        default:\n          f = pow(10, precision);\n          break;\n      }\n    }\n\n    this.x = round(this.x * f) / f;\n    this.y = round(this.y * f) / f;\n    this.a = round(this.a * f) / f;\n    this.b = round(this.b * f) / f;\n    return this;\n  },\n\n  /** Compute angle between tangent and x axis\n   * @param {g.Point} p Point of tangency, it has to be on ellipse boundaries.\n   * @returns {number} angle between tangent and x axis\n   */\n  tangentTheta: function (p) {\n    var refPointDelta = 30;\n    var x0 = p.x;\n    var y0 = p.y;\n    var a = this.a;\n    var b = this.b;\n    var center = this.bbox().center();\n    var m = center.x;\n    var n = center.y;\n    var q1 = x0 > center.x + a / 2;\n    var q3 = x0 < center.x - a / 2;\n    var y, x;\n\n    if (q1 || q3) {\n      y = x0 > center.x ? y0 - refPointDelta : y0 + refPointDelta;\n      x = a * a / (x0 - m) - a * a * (y0 - n) * (y - n) / (b * b * (x0 - m)) + m;\n    } else {\n      x = y0 > center.y ? x0 + refPointDelta : x0 - refPointDelta;\n      y = b * b / (y0 - n) - b * b * (x0 - m) * (x - m) / (a * a * (y0 - n)) + n;\n    }\n\n    return new Point(x, y).theta(p);\n  },\n  toString: function () {\n    return new Point(this.x, this.y).toString() + ' ' + this.a + ' ' + this.b;\n  }\n}; // For backwards compatibility:\n\nexport const ellipse = Ellipse;","map":{"version":3,"names":["Rect","Point","types","sqrt","round","pow","Math","Ellipse","c","a","b","x","y","fromRect","rect","center","width","height","prototype","type","bbox","clone","containsPoint","p","normalizedDistance","equals","ellipse","inflate","dx","dy","undefined","intersectionWithLine","line","intersections","a1","start","a2","end","rx","ry","dir","vector","diff","difference","mDir","mDiff","dot","d","root","ta","tb","push","lerp","t","intersectionWithLineFromCenterToPoint","angle","rotate","result","pointNearestToPoint","m","mSquared","aSquared","bSquared","point","x0","y0","precision","f","tangentTheta","refPointDelta","n","q1","q3","theta","toString"],"sources":["C:/Users/Admin/dataflow-test/node_modules/jointjs/src/g/ellipse.mjs"],"sourcesContent":["import { Rect } from './rect.mjs';\nimport { Point } from './point.mjs';\nimport { types } from './types.mjs';\n\nconst {\n    sqrt,\n    round,\n    pow\n} = Math;\n\nexport const Ellipse = function(c, a, b) {\n\n    if (!(this instanceof Ellipse)) {\n        return new Ellipse(c, a, b);\n    }\n\n    if (c instanceof Ellipse) {\n        return new Ellipse(new Point(c.x, c.y), c.a, c.b);\n    }\n\n    c = new Point(c);\n    this.x = c.x;\n    this.y = c.y;\n    this.a = a;\n    this.b = b;\n};\n\nEllipse.fromRect = function(rect) {\n\n    rect = new Rect(rect);\n    return new Ellipse(rect.center(), rect.width / 2, rect.height / 2);\n};\n\nEllipse.prototype = {\n\n    type: types.Ellipse,\n\n    bbox: function() {\n\n        return new Rect(this.x - this.a, this.y - this.b, 2 * this.a, 2 * this.b);\n    },\n\n    /**\n     * @returns {g.Point}\n     */\n    center: function() {\n\n        return new Point(this.x, this.y);\n    },\n\n    clone: function() {\n\n        return new Ellipse(this);\n    },\n\n    /**\n     * @param {g.Point} p\n     * @returns {boolean}\n     */\n    containsPoint: function(p) {\n\n        return this.normalizedDistance(p) <= 1;\n    },\n\n    equals: function(ellipse) {\n\n        return !!ellipse &&\n            ellipse.x === this.x &&\n            ellipse.y === this.y &&\n            ellipse.a === this.a &&\n            ellipse.b === this.b;\n    },\n\n    // inflate by dx and dy\n    // @param dx {delta_x} representing additional size to x\n    // @param dy {delta_y} representing additional size to y -\n    // dy param is not required -> in that case y is sized by dx\n    inflate: function(dx, dy) {\n        if (dx === undefined) {\n            dx = 0;\n        }\n\n        if (dy === undefined) {\n            dy = dx;\n        }\n\n        this.a += 2 * dx;\n        this.b += 2 * dy;\n\n        return this;\n    },\n\n    intersectionWithLine: function(line) {\n\n        var intersections = [];\n        var a1 = line.start;\n        var a2 = line.end;\n        var rx = this.a;\n        var ry = this.b;\n        var dir = line.vector();\n        var diff = a1.difference(new Point(this));\n        var mDir = new Point(dir.x / (rx * rx), dir.y / (ry * ry));\n        var mDiff = new Point(diff.x / (rx * rx), diff.y / (ry * ry));\n\n        var a = dir.dot(mDir);\n        var b = dir.dot(mDiff);\n        var c = diff.dot(mDiff) - 1.0;\n        var d = b * b - a * c;\n\n        if (d < 0) {\n            return null;\n        } else if (d > 0) {\n            var root = sqrt(d);\n            var ta = (-b - root) / a;\n            var tb = (-b + root) / a;\n\n            if ((ta < 0 || 1 < ta) && (tb < 0 || 1 < tb)) {\n                // if ((ta < 0 && tb < 0) || (ta > 1 && tb > 1)) outside else inside\n                return null;\n            } else {\n                if (0 <= ta && ta <= 1) intersections.push(a1.lerp(a2, ta));\n                if (0 <= tb && tb <= 1) intersections.push(a1.lerp(a2, tb));\n            }\n        } else {\n            var t = -b / a;\n            if (0 <= t && t <= 1) {\n                intersections.push(a1.lerp(a2, t));\n            } else {\n                // outside\n                return null;\n            }\n        }\n\n        return intersections;\n    },\n\n    // Find point on me where line from my center to\n    // point p intersects my boundary.\n    // @param {number} angle If angle is specified, intersection with rotated ellipse is computed.\n    intersectionWithLineFromCenterToPoint: function(p, angle) {\n\n        p = new Point(p);\n\n        if (angle) p.rotate(new Point(this.x, this.y), angle);\n\n        var dx = p.x - this.x;\n        var dy = p.y - this.y;\n        var result;\n\n        if (dx === 0) {\n            result = this.bbox().pointNearestToPoint(p);\n            if (angle) return result.rotate(new Point(this.x, this.y), -angle);\n            return result;\n        }\n\n        var m = dy / dx;\n        var mSquared = m * m;\n        var aSquared = this.a * this.a;\n        var bSquared = this.b * this.b;\n\n        var x = sqrt(1 / ((1 / aSquared) + (mSquared / bSquared)));\n        x = dx < 0 ? -x : x;\n\n        var y = m * x;\n        result = new Point(this.x + x, this.y + y);\n\n        if (angle) return result.rotate(new Point(this.x, this.y), -angle);\n        return result;\n    },\n\n    /**\n     * @param {g.Point} point\n     * @returns {number} result < 1 - inside ellipse, result == 1 - on ellipse boundary, result > 1 - outside\n     */\n    normalizedDistance: function(point) {\n\n        var x0 = point.x;\n        var y0 = point.y;\n        var a = this.a;\n        var b = this.b;\n        var x = this.x;\n        var y = this.y;\n\n        return ((x0 - x) * (x0 - x)) / (a * a) + ((y0 - y) * (y0 - y)) / (b * b);\n    },\n\n    round: function(precision) {\n\n        let f = 1; // case 0\n        if (precision) {\n            switch (precision) {\n                case 1: f = 10; break;\n                case 2: f = 100; break;\n                case 3: f = 1000; break;\n                default: f = pow(10, precision); break;\n            }\n        }\n\n        this.x = round(this.x * f) / f;\n        this.y = round(this.y * f) / f;\n        this.a = round(this.a * f) / f;\n        this.b = round(this.b * f) / f;\n        return this;\n    },\n\n    /** Compute angle between tangent and x axis\n     * @param {g.Point} p Point of tangency, it has to be on ellipse boundaries.\n     * @returns {number} angle between tangent and x axis\n     */\n    tangentTheta: function(p) {\n\n        var refPointDelta = 30;\n        var x0 = p.x;\n        var y0 = p.y;\n        var a = this.a;\n        var b = this.b;\n        var center = this.bbox().center();\n        var m = center.x;\n        var n = center.y;\n\n        var q1 = x0 > center.x + a / 2;\n        var q3 = x0 < center.x - a / 2;\n\n        var y, x;\n        if (q1 || q3) {\n            y = x0 > center.x ? y0 - refPointDelta : y0 + refPointDelta;\n            x = (a * a / (x0 - m)) - (a * a * (y0 - n) * (y - n)) / (b * b * (x0 - m)) + m;\n\n        } else {\n            x = y0 > center.y ? x0 + refPointDelta : x0 - refPointDelta;\n            y = (b * b / (y0 - n)) - (b * b * (x0 - m) * (x - m)) / (a * a * (y0 - n)) + n;\n        }\n\n        return (new Point(x, y)).theta(p);\n\n    },\n\n    toString: function() {\n\n        return (new Point(this.x, this.y)).toString() + ' ' + this.a + ' ' + this.b;\n    }\n};\n\n// For backwards compatibility:\nexport const ellipse = Ellipse;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}