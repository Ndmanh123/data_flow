{"ast":null,"code":"import { assign } from '../util/index.mjs';\nimport V from '../V/index.mjs';\nimport { HighlighterView } from '../dia/HighlighterView.mjs';\nexport const stroke = HighlighterView.extend({\n  tagName: 'path',\n  className: 'highlight-stroke',\n  attributes: {\n    'pointer-events': 'none',\n    'vector-effect': 'non-scaling-stroke',\n    'fill': 'none'\n  },\n  options: {\n    padding: 3,\n    rx: 0,\n    ry: 0,\n    useFirstSubpath: false,\n    attrs: {\n      'stroke-width': 3,\n      'stroke': '#FEB663'\n    }\n  },\n\n  getPathData(cellView, node) {\n    const {\n      options\n    } = this;\n    const {\n      useFirstSubpath\n    } = options;\n    let d;\n\n    try {\n      const vNode = V(node);\n      d = vNode.convertToPathData().trim();\n\n      if (vNode.tagName() === 'PATH' && useFirstSubpath) {\n        const secondSubpathIndex = d.search(/.M/i) + 1;\n\n        if (secondSubpathIndex > 0) {\n          d = d.substr(0, secondSubpathIndex);\n        }\n      }\n    } catch (error) {\n      // Failed to get path data from magnet element.\n      // Draw a rectangle around the node instead.\n      const nodeBBox = cellView.getNodeBoundingRect(node);\n      d = V.rectToPath(assign({}, options, nodeBBox.toJSON()));\n    }\n\n    return d;\n  },\n\n  highlightConnection(cellView) {\n    this.vel.attr('d', cellView.getSerializedConnection());\n  },\n\n  highlightNode(cellView, node) {\n    const {\n      vel,\n      options\n    } = this;\n    const {\n      padding,\n      layer\n    } = options;\n    let highlightMatrix = cellView.getNodeMatrix(node); // Add padding to the highlight element.\n\n    if (padding) {\n      if (!layer && node === cellView.el) {\n        // If the highlighter is appended to the cellView\n        // and we measure the size of the cellView wrapping group\n        // it's necessary to remove the highlighter first\n        vel.remove();\n      }\n\n      let nodeBBox = cellView.getNodeBoundingRect(node);\n      const cx = nodeBBox.x + nodeBBox.width / 2;\n      const cy = nodeBBox.y + nodeBBox.height / 2;\n      nodeBBox = V.transformRect(nodeBBox, highlightMatrix);\n      const width = Math.max(nodeBBox.width, 1);\n      const height = Math.max(nodeBBox.height, 1);\n      const sx = (width + padding) / width;\n      const sy = (height + padding) / height;\n      const paddingMatrix = V.createSVGMatrix({\n        a: sx,\n        b: 0,\n        c: 0,\n        d: sy,\n        e: cx - sx * cx,\n        f: cy - sy * cy\n      });\n      highlightMatrix = highlightMatrix.multiply(paddingMatrix);\n    }\n\n    vel.attr({\n      'd': this.getPathData(cellView, node),\n      'transform': V.matrixToTransformString(highlightMatrix)\n    });\n  },\n\n  highlight(cellView, node) {\n    const {\n      vel,\n      options\n    } = this;\n    vel.attr(options.attrs);\n\n    if (cellView.isNodeConnection(node)) {\n      this.highlightConnection(cellView);\n    } else {\n      this.highlightNode(cellView, node);\n    }\n  }\n\n});","map":{"version":3,"names":["assign","V","HighlighterView","stroke","extend","tagName","className","attributes","options","padding","rx","ry","useFirstSubpath","attrs","getPathData","cellView","node","d","vNode","convertToPathData","trim","secondSubpathIndex","search","substr","error","nodeBBox","getNodeBoundingRect","rectToPath","toJSON","highlightConnection","vel","attr","getSerializedConnection","highlightNode","layer","highlightMatrix","getNodeMatrix","el","remove","cx","x","width","cy","y","height","transformRect","Math","max","sx","sy","paddingMatrix","createSVGMatrix","a","b","c","e","f","multiply","matrixToTransformString","highlight","isNodeConnection"],"sources":["C:/Users/Admin/dataflow-test/node_modules/jointjs/src/highlighters/stroke.mjs"],"sourcesContent":["import { assign } from '../util/index.mjs';\nimport V from '../V/index.mjs';\nimport { HighlighterView } from '../dia/HighlighterView.mjs';\n\nexport const stroke = HighlighterView.extend({\n\n    tagName: 'path',\n    className: 'highlight-stroke',\n    attributes: {\n        'pointer-events': 'none',\n        'vector-effect': 'non-scaling-stroke',\n        'fill': 'none'\n    },\n\n    options: {\n        padding: 3,\n        rx: 0,\n        ry: 0,\n        useFirstSubpath: false,\n        attrs: {\n            'stroke-width': 3,\n            'stroke': '#FEB663'\n        }\n    },\n\n    getPathData(cellView, node) {\n        const { options } = this;\n        const { useFirstSubpath } = options;\n        let d;\n        try {\n            const vNode = V(node);\n            d = vNode.convertToPathData().trim();\n            if (vNode.tagName() === 'PATH' && useFirstSubpath) {\n                const secondSubpathIndex = d.search(/.M/i) + 1;\n                if (secondSubpathIndex > 0) {\n                    d = d.substr(0, secondSubpathIndex);\n                }\n            }\n        } catch (error) {\n            // Failed to get path data from magnet element.\n            // Draw a rectangle around the node instead.\n            const nodeBBox = cellView.getNodeBoundingRect(node);\n            d = V.rectToPath(assign({}, options, nodeBBox.toJSON()));\n        }\n        return d;\n    },\n\n    highlightConnection(cellView) {\n        this.vel.attr('d', cellView.getSerializedConnection());\n    },\n\n    highlightNode(cellView, node) {\n        const { vel, options } = this;\n        const { padding, layer } = options;\n        let highlightMatrix = cellView.getNodeMatrix(node);\n        // Add padding to the highlight element.\n        if (padding) {\n            if (!layer && node === cellView.el) {\n                // If the highlighter is appended to the cellView\n                // and we measure the size of the cellView wrapping group\n                // it's necessary to remove the highlighter first\n                vel.remove();\n            }\n            let nodeBBox = cellView.getNodeBoundingRect(node);\n            const cx = nodeBBox.x + (nodeBBox.width / 2);\n            const cy = nodeBBox.y + (nodeBBox.height / 2);\n            nodeBBox = V.transformRect(nodeBBox, highlightMatrix);\n            const width = Math.max(nodeBBox.width, 1);\n            const height = Math.max(nodeBBox.height, 1);\n            const sx = (width + padding) / width;\n            const sy = (height + padding) / height;\n            const paddingMatrix = V.createSVGMatrix({\n                a: sx,\n                b: 0,\n                c: 0,\n                d: sy,\n                e: cx - sx * cx,\n                f: cy - sy * cy\n            });\n            highlightMatrix = highlightMatrix.multiply(paddingMatrix);\n        }\n        vel.attr({\n            'd': this.getPathData(cellView, node),\n            'transform': V.matrixToTransformString(highlightMatrix)\n        });\n    },\n\n    highlight(cellView, node) {\n        const { vel, options } = this;\n        vel.attr(options.attrs);\n        if (cellView.isNodeConnection(node)) {\n            this.highlightConnection(cellView);\n        } else {\n            this.highlightNode(cellView, node);\n        }\n    }\n\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}