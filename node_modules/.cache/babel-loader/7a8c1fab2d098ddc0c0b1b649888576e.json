{"ast":null,"code":"import * as g from '../g/index.mjs';\nimport V from '../V/index.mjs';\nimport * as util from '../util/index.mjs';\n\nfunction offsetPoint(p1, p2, offset) {\n  if (util.isPlainObject(offset)) {\n    const {\n      x,\n      y\n    } = offset;\n\n    if (isFinite(y)) {\n      const line = new g.Line(p2, p1);\n      const {\n        start,\n        end\n      } = line.parallel(y);\n      p2 = start;\n      p1 = end;\n    }\n\n    offset = x;\n  }\n\n  if (!isFinite(offset)) return p1;\n  var length = p1.distance(p2);\n  if (offset === 0 && length > 0) return p1;\n  return p1.move(p2, -Math.min(offset, length - 1));\n}\n\nfunction stroke(magnet) {\n  var stroke = magnet.getAttribute('stroke-width');\n  if (stroke === null) return 0;\n  return parseFloat(stroke) || 0;\n}\n\nfunction alignLine(line, type, offset = 0) {\n  let coordinate, a, b, direction;\n  const {\n    start,\n    end\n  } = line;\n\n  switch (type) {\n    case 'left':\n      coordinate = 'x';\n      a = end;\n      b = start;\n      direction = -1;\n      break;\n\n    case 'right':\n      coordinate = 'x';\n      a = start;\n      b = end;\n      direction = 1;\n      break;\n\n    case 'top':\n      coordinate = 'y';\n      a = end;\n      b = start;\n      direction = -1;\n      break;\n\n    case 'bottom':\n      coordinate = 'y';\n      a = start;\n      b = end;\n      direction = 1;\n      break;\n\n    default:\n      return;\n  }\n\n  if (start[coordinate] < end[coordinate]) {\n    a[coordinate] = b[coordinate];\n  } else {\n    b[coordinate] = a[coordinate];\n  }\n\n  if (isFinite(offset)) {\n    a[coordinate] += direction * offset;\n    b[coordinate] += direction * offset;\n  }\n} // Connection Points\n\n\nfunction anchorConnectionPoint(line, _view, _magnet, opt) {\n  let {\n    offset,\n    alignOffset,\n    align\n  } = opt;\n  if (align) alignLine(line, align, alignOffset);\n  return offsetPoint(line.end, line.start, offset);\n}\n\nfunction bboxIntersection(line, view, magnet, opt) {\n  var bbox = view.getNodeBBox(magnet);\n  if (opt.stroke) bbox.inflate(stroke(magnet) / 2);\n  var intersections = line.intersect(bbox);\n  var cp = intersections ? line.start.chooseClosest(intersections) : line.end;\n  return offsetPoint(cp, line.start, opt.offset);\n}\n\nfunction rectangleIntersection(line, view, magnet, opt) {\n  var angle = view.model.angle();\n\n  if (angle === 0) {\n    return bboxIntersection(line, view, magnet, opt);\n  }\n\n  var bboxWORotation = view.getNodeUnrotatedBBox(magnet);\n  if (opt.stroke) bboxWORotation.inflate(stroke(magnet) / 2);\n  var center = bboxWORotation.center();\n  var lineWORotation = line.clone().rotate(center, angle);\n  var intersections = lineWORotation.setLength(1e6).intersect(bboxWORotation);\n  var cp = intersections ? lineWORotation.start.chooseClosest(intersections).rotate(center, -angle) : line.end;\n  return offsetPoint(cp, line.start, opt.offset);\n}\n\nfunction findShapeNode(magnet) {\n  if (!magnet) return null;\n  var node = magnet;\n\n  do {\n    var tagName = node.tagName;\n    if (typeof tagName !== 'string') return null;\n    tagName = tagName.toUpperCase();\n\n    if (tagName === 'G') {\n      node = node.firstElementChild;\n    } else if (tagName === 'TITLE') {\n      node = node.nextElementSibling;\n    } else break;\n  } while (node);\n\n  return node;\n}\n\nvar BNDR_SUBDIVISIONS = 'segmentSubdivisons';\nvar BNDR_SHAPE_BBOX = 'shapeBBox';\n\nfunction boundaryIntersection(line, view, magnet, opt) {\n  var node, intersection;\n  var selector = opt.selector;\n  var anchor = line.end;\n\n  if (typeof selector === 'string') {\n    node = view.findBySelector(selector)[0];\n  } else if (Array.isArray(selector)) {\n    node = util.getByPath(magnet, selector);\n  } else {\n    node = findShapeNode(magnet);\n  }\n\n  if (!V.isSVGGraphicsElement(node)) {\n    if (node === magnet || !V.isSVGGraphicsElement(magnet)) return anchor;\n    node = magnet;\n  }\n\n  var localShape = view.getNodeShape(node);\n  var magnetMatrix = view.getNodeMatrix(node);\n  var translateMatrix = view.getRootTranslateMatrix();\n  var rotateMatrix = view.getRootRotateMatrix();\n  var targetMatrix = translateMatrix.multiply(rotateMatrix).multiply(magnetMatrix);\n  var localMatrix = targetMatrix.inverse();\n  var localLine = V.transformLine(line, localMatrix);\n  var localRef = localLine.start.clone();\n  var data = view.getNodeData(node);\n\n  if (opt.insideout === false) {\n    if (!data[BNDR_SHAPE_BBOX]) data[BNDR_SHAPE_BBOX] = localShape.bbox();\n    var localBBox = data[BNDR_SHAPE_BBOX];\n    if (localBBox.containsPoint(localRef)) return anchor;\n  } // Caching segment subdivisions for paths\n\n\n  var pathOpt;\n\n  if (localShape instanceof g.Path) {\n    var precision = opt.precision || 2;\n    if (!data[BNDR_SUBDIVISIONS]) data[BNDR_SUBDIVISIONS] = localShape.getSegmentSubdivisions({\n      precision: precision\n    });\n    pathOpt = {\n      precision: precision,\n      segmentSubdivisions: data[BNDR_SUBDIVISIONS]\n    };\n  }\n\n  if (opt.extrapolate === true) localLine.setLength(1e6);\n  intersection = localLine.intersect(localShape, pathOpt);\n\n  if (intersection) {\n    // More than one intersection\n    if (V.isArray(intersection)) intersection = localRef.chooseClosest(intersection);\n  } else if (opt.sticky === true) {\n    // No intersection, find the closest point instead\n    if (localShape instanceof g.Rect) {\n      intersection = localShape.pointNearestToPoint(localRef);\n    } else if (localShape instanceof g.Ellipse) {\n      intersection = localShape.intersectionWithLineFromCenterToPoint(localRef);\n    } else {\n      intersection = localShape.closestPoint(localRef, pathOpt);\n    }\n  }\n\n  var cp = intersection ? V.transformPoint(intersection, targetMatrix) : anchor;\n  var cpOffset = opt.offset || 0;\n  if (opt.stroke) cpOffset += stroke(node) / 2;\n  return offsetPoint(cp, line.start, cpOffset);\n}\n\nexport const anchor = anchorConnectionPoint;\nexport const bbox = bboxIntersection;\nexport const rectangle = rectangleIntersection;\nexport const boundary = boundaryIntersection;","map":{"version":3,"names":["g","V","util","offsetPoint","p1","p2","offset","isPlainObject","x","y","isFinite","line","Line","start","end","parallel","length","distance","move","Math","min","stroke","magnet","getAttribute","parseFloat","alignLine","type","coordinate","a","b","direction","anchorConnectionPoint","_view","_magnet","opt","alignOffset","align","bboxIntersection","view","bbox","getNodeBBox","inflate","intersections","intersect","cp","chooseClosest","rectangleIntersection","angle","model","bboxWORotation","getNodeUnrotatedBBox","center","lineWORotation","clone","rotate","setLength","findShapeNode","node","tagName","toUpperCase","firstElementChild","nextElementSibling","BNDR_SUBDIVISIONS","BNDR_SHAPE_BBOX","boundaryIntersection","intersection","selector","anchor","findBySelector","Array","isArray","getByPath","isSVGGraphicsElement","localShape","getNodeShape","magnetMatrix","getNodeMatrix","translateMatrix","getRootTranslateMatrix","rotateMatrix","getRootRotateMatrix","targetMatrix","multiply","localMatrix","inverse","localLine","transformLine","localRef","data","getNodeData","insideout","localBBox","containsPoint","pathOpt","Path","precision","getSegmentSubdivisions","segmentSubdivisions","extrapolate","sticky","Rect","pointNearestToPoint","Ellipse","intersectionWithLineFromCenterToPoint","closestPoint","transformPoint","cpOffset","rectangle","boundary"],"sources":["C:/Users/Admin/dataflow-test/node_modules/jointjs/src/connectionPoints/index.mjs"],"sourcesContent":["import * as g from '../g/index.mjs';\nimport V from '../V/index.mjs';\nimport * as util from '../util/index.mjs';\n\nfunction offsetPoint(p1, p2, offset) {\n    if (util.isPlainObject(offset)) {\n        const { x, y } = offset;\n        if (isFinite(y)) {\n            const line =  new g.Line(p2, p1);\n            const { start, end } = line.parallel(y);\n            p2 = start;\n            p1 = end;\n        }\n        offset = x;\n    }\n    if (!isFinite(offset)) return p1;\n    var length = p1.distance(p2);\n    if (offset === 0 && length > 0) return p1;\n    return p1.move(p2, -Math.min(offset, length - 1));\n}\n\nfunction stroke(magnet) {\n\n    var stroke = magnet.getAttribute('stroke-width');\n    if (stroke === null) return 0;\n    return parseFloat(stroke) || 0;\n}\n\nfunction alignLine(line, type, offset = 0) {\n    let coordinate, a, b, direction;\n    const { start, end } = line;\n    switch (type) {\n        case 'left':\n            coordinate = 'x';\n            a = end;\n            b = start;\n            direction = -1;\n            break;\n        case 'right':\n            coordinate = 'x';\n            a = start;\n            b = end;\n            direction = 1;\n            break;\n        case 'top':\n            coordinate = 'y';\n            a = end;\n            b = start;\n            direction = -1;\n            break;\n        case 'bottom':\n            coordinate = 'y';\n            a = start;\n            b = end;\n            direction = 1;\n            break;\n        default:\n            return;\n    }\n    if (start[coordinate] < end[coordinate]) {\n        a[coordinate] = b[coordinate];\n    } else {\n        b[coordinate] = a[coordinate];\n    }\n    if (isFinite(offset)) {\n        a[coordinate] += direction * offset;\n        b[coordinate] += direction * offset;\n    }\n}\n\n// Connection Points\n\nfunction anchorConnectionPoint(line, _view, _magnet, opt) {\n    let { offset, alignOffset, align } = opt;\n    if (align) alignLine(line, align, alignOffset);\n    return offsetPoint(line.end, line.start, offset);\n}\n\nfunction bboxIntersection(line, view, magnet, opt) {\n\n    var bbox = view.getNodeBBox(magnet);\n    if (opt.stroke) bbox.inflate(stroke(magnet) / 2);\n    var intersections = line.intersect(bbox);\n    var cp = (intersections)\n        ? line.start.chooseClosest(intersections)\n        : line.end;\n    return offsetPoint(cp, line.start, opt.offset);\n}\n\nfunction rectangleIntersection(line, view, magnet, opt) {\n\n    var angle = view.model.angle();\n    if (angle === 0) {\n        return bboxIntersection(line, view, magnet, opt);\n    }\n\n    var bboxWORotation = view.getNodeUnrotatedBBox(magnet);\n    if (opt.stroke) bboxWORotation.inflate(stroke(magnet) / 2);\n    var center = bboxWORotation.center();\n    var lineWORotation = line.clone().rotate(center, angle);\n    var intersections = lineWORotation.setLength(1e6).intersect(bboxWORotation);\n    var cp = (intersections)\n        ? lineWORotation.start.chooseClosest(intersections).rotate(center, -angle)\n        : line.end;\n    return offsetPoint(cp, line.start, opt.offset);\n}\n\nfunction findShapeNode(magnet) {\n    if (!magnet) return null;\n    var node = magnet;\n    do {\n        var tagName = node.tagName;\n        if (typeof tagName !== 'string') return null;\n        tagName = tagName.toUpperCase();\n        if (tagName === 'G') {\n            node = node.firstElementChild;\n        } else if (tagName === 'TITLE') {\n            node = node.nextElementSibling;\n        } else break;\n    } while (node);\n    return node;\n}\n\nvar BNDR_SUBDIVISIONS = 'segmentSubdivisons';\nvar BNDR_SHAPE_BBOX = 'shapeBBox';\n\nfunction boundaryIntersection(line, view, magnet, opt) {\n\n    var node, intersection;\n    var selector = opt.selector;\n    var anchor = line.end;\n\n    if (typeof selector === 'string') {\n        node = view.findBySelector(selector)[0];\n    } else if (Array.isArray(selector)) {\n        node = util.getByPath(magnet, selector);\n    } else {\n        node = findShapeNode(magnet);\n    }\n\n    if (!V.isSVGGraphicsElement(node)) {\n        if (node === magnet || !V.isSVGGraphicsElement(magnet)) return anchor;\n        node = magnet;\n    }\n\n    var localShape = view.getNodeShape(node);\n    var magnetMatrix = view.getNodeMatrix(node);\n    var translateMatrix = view.getRootTranslateMatrix();\n    var rotateMatrix = view.getRootRotateMatrix();\n    var targetMatrix = translateMatrix.multiply(rotateMatrix).multiply(magnetMatrix);\n    var localMatrix = targetMatrix.inverse();\n    var localLine = V.transformLine(line, localMatrix);\n    var localRef = localLine.start.clone();\n    var data = view.getNodeData(node);\n\n    if (opt.insideout === false) {\n        if (!data[BNDR_SHAPE_BBOX]) data[BNDR_SHAPE_BBOX] = localShape.bbox();\n        var localBBox = data[BNDR_SHAPE_BBOX];\n        if (localBBox.containsPoint(localRef)) return anchor;\n    }\n\n    // Caching segment subdivisions for paths\n    var pathOpt;\n    if (localShape instanceof g.Path) {\n        var precision = opt.precision || 2;\n        if (!data[BNDR_SUBDIVISIONS]) data[BNDR_SUBDIVISIONS] = localShape.getSegmentSubdivisions({ precision: precision });\n        pathOpt = {\n            precision: precision,\n            segmentSubdivisions: data[BNDR_SUBDIVISIONS]\n        };\n    }\n\n    if (opt.extrapolate === true) localLine.setLength(1e6);\n\n    intersection = localLine.intersect(localShape, pathOpt);\n    if (intersection) {\n        // More than one intersection\n        if (V.isArray(intersection)) intersection = localRef.chooseClosest(intersection);\n    } else if (opt.sticky === true) {\n        // No intersection, find the closest point instead\n        if (localShape instanceof g.Rect) {\n            intersection = localShape.pointNearestToPoint(localRef);\n        } else if (localShape instanceof g.Ellipse) {\n            intersection = localShape.intersectionWithLineFromCenterToPoint(localRef);\n        } else {\n            intersection = localShape.closestPoint(localRef, pathOpt);\n        }\n    }\n\n    var cp = (intersection) ? V.transformPoint(intersection, targetMatrix) : anchor;\n    var cpOffset = opt.offset || 0;\n    if (opt.stroke) cpOffset += stroke(node) / 2;\n\n    return offsetPoint(cp, line.start, cpOffset);\n}\n\nexport const anchor = anchorConnectionPoint;\nexport const bbox = bboxIntersection;\nexport const rectangle = rectangleIntersection;\nexport const boundary = boundaryIntersection;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}